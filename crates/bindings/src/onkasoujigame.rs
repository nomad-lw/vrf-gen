///Module containing a contract's types and functions.
/**

```solidity
library EntropyStructs {
    struct Request { address provider; uint64 sequenceNumber; uint32 numHashes; bytes32 commitment; uint64 blockNumber; address requester; bool useBlockhash; bool isRequestWithCallback; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod EntropyStructs {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Request { address provider; uint64 sequenceNumber; uint32 numHashes; bytes32 commitment; uint64 blockNumber; address requester; bool useBlockhash; bool isRequestWithCallback; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Request {
        #[allow(missing_docs)]
        pub provider: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sequenceNumber: u64,
        #[allow(missing_docs)]
        pub numHashes: u32,
        #[allow(missing_docs)]
        pub commitment: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockNumber: u64,
        #[allow(missing_docs)]
        pub requester: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub useBlockhash: bool,
        #[allow(missing_docs)]
        pub isRequestWithCallback: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            u64,
            u32,
            alloy::sol_types::private::FixedBytes<32>,
            u64,
            alloy::sol_types::private::Address,
            bool,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Request> for UnderlyingRustTuple<'_> {
            fn from(value: Request) -> Self {
                (
                    value.provider,
                    value.sequenceNumber,
                    value.numHashes,
                    value.commitment,
                    value.blockNumber,
                    value.requester,
                    value.useBlockhash,
                    value.isRequestWithCallback,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Request {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    provider: tuple.0,
                    sequenceNumber: tuple.1,
                    numHashes: tuple.2,
                    commitment: tuple.3,
                    blockNumber: tuple.4,
                    requester: tuple.5,
                    useBlockhash: tuple.6,
                    isRequestWithCallback: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Request {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Request {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.provider,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequenceNumber),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.numHashes),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.commitment),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.requester,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.useBlockhash,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isRequestWithCallback,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Request {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Request {
            const NAME: &'static str = "Request";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Request(address provider,uint64 sequenceNumber,uint32 numHashes,bytes32 commitment,uint64 blockNumber,address requester,bool useBlockhash,bool isRequestWithCallback)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.provider,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sequenceNumber,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.numHashes)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.commitment)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockNumber)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.requester,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.useBlockhash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isRequestWithCallback,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Request {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.provider,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequenceNumber,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numHashes,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.commitment,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockNumber,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requester,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.useBlockhash,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isRequestWithCallback,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.provider,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequenceNumber,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numHashes,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.commitment,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockNumber,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requester,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.useBlockhash,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isRequestWithCallback,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`EntropyStructs`](self) contract instance.

See the [wrapper's documentation](`EntropyStructsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> EntropyStructsInstance<T, P, N> {
        EntropyStructsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`EntropyStructs`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`EntropyStructs`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct EntropyStructsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for EntropyStructsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("EntropyStructsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EntropyStructsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`EntropyStructs`](self) contract instance.

See the [wrapper's documentation](`EntropyStructsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> EntropyStructsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> EntropyStructsInstance<T, P, N> {
            EntropyStructsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EntropyStructsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EntropyStructsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library EntropyStructs {
    struct Request {
        address provider;
        uint64 sequenceNumber;
        uint32 numHashes;
        bytes32 commitment;
        uint64 blockNumber;
        address requester;
        bool useBlockhash;
        bool isRequestWithCallback;
    }
}

interface OnkasOujiGame {
    type GameStatus is uint8;
    struct GameData {
        Player[2] players;
        Speculation[] speculations;
        uint256 amount;
        GameStatus status;
        RoundResult[] rounds;
        uint8 p1_wins;
        uint8 p2_wins;
        uint256 bet_pool;
        bytes32 alpha_prefix;
    }
    struct OnkaStats {
        uint256 plays;
        uint256 wins;
        uint256 losses;
    }
    struct Player {
        address addr;
        uint256 nft_id;
    }
    struct RoundResult {
        uint8 roll_p1;
        uint8 roll_p2;
        bool p1_won;
    }
    struct Speculation {
        address speculator;
        bool prediction;
        uint256 amount;
    }

    error AlreadyInitialized();
    error GameExecNotReady();
    error InsufficientBalance(uint256 balance, uint256 required, address addr);
    error InsufficientFee(uint256 fee_supplied, uint256 required);
    error InvalidAmount();
    error InvalidGame();
    error InvalidGameID();
    error InvalidGameStatus(uint256 game_id, GameStatus current, GameStatus required);
    error InvalidInput();
    error InvalidNFTOwnership(address player, uint256 nft_id);
    error InvalidPrediction();
    error InvalidRequest();
    error InvalidVRFProof(string);
    error NewOwnerIsZeroAddress();
    error NoHandoverRequest();
    error ReentrancyGuardReentrantCall();
    error RegistrationFailed(string reason);
    error RequestCollision(uint256 req_id);
    error Unauthorized();
    error UnauthorizedCaller();

    event BetPlaced(uint256 indexed game_id, address indexed addr, bool indexed prediction, uint256 amount);
    event CallbackOnInactiveGame(uint256 indexed game_id, GameStatus indexed status);
    event CallbackOnInactiveRequest(uint256 indexed req_id, uint8 indexed flag, uint256 sequence_number);
    event GameAborted(uint256 indexed game_id);
    event GameCompleted(uint256 indexed game_id, uint8 indexed winner, RoundResult[5] rounds);
    event GameCreated(uint256 indexed game_id, Player[2] players, uint256 amount);
    event GameExecuted(uint256 indexed game_id);
    event GameStarted(uint256 indexed game_id);
    event OwnershipHandoverCanceled(address indexed pendingOwner);
    event OwnershipHandoverRequested(address indexed pendingOwner);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
    event RandomnessGenerated(uint256 indexed req_id, uint8 indexed flag);
    event RandomnessRequested(uint256 indexed req_id, uint8 indexed flag);
    event RandomnessSourcesUpdated(uint8 old_sources, uint8 new_sources);
    event RequestAborted(uint256 indexed req_id);
    event RequestCompleted(uint256 indexed req_id);
    event RevenueSet(uint256 indexed bps);
    event RolesUpdated(address indexed user, uint256 indexed roles);
    event SAVPublicKeyUpdated(uint256[2] newPublicKey);
    event TokenNotSupported(address indexed token, string reason);
    event UserRegistered(bytes32 indexed secret, address indexed addr);

    constructor(address _nft_contract, address _token_contract, address _pyth_entropy, address _pyth_provider, address _randomizer, uint256[2] _sav_pk, address _revenue_wallet);

    function BATTLE_ROUNDS() external view returns (uint256);
    function HEALTH_PER_LIFE() external view returns (uint256);
    function INITIAL_HEALTH() external view returns (uint256);
    function NFT_CONTRACT() external view returns (address);
    function PYTH_ENTROPY() external view returns (address);
    function PYTH_PROVIDER() external view returns (address);
    function RANDOMIZER() external view returns (address);
    function SAV_PUB_KEY(uint256) external view returns (uint256);
    function TOKEN_CONTRACT() external view returns (address);
    function WINS_REQUIRED() external view returns (uint256);
    function _entropyCallback(uint64 sequence, address provider, bytes32 randomNumber) external;
    function abort_game(uint256 game_id) external;
    function abort_request(uint256 req_id) external;
    function calc_book(uint256 game_id) external view returns (uint256 p1_odds, uint256 p2_odds, uint256 p1_depth, uint256 p2_depth);
    function calc_fee() external view returns (uint256 total, uint128 fee_pyth, uint256 fee_randomizer);
    function cancelOwnershipHandover() external payable;
    function completeOwnershipHandover(address pendingOwner) external payable;
    function compute_alpha(uint256 game_id) external view returns (bytes32);
    function compute_fast_verify_params(uint256[4] memory _proof, bytes memory _alpha) external view returns (uint256[2] memory U, uint256[4] memory V);
    function decoded_proof_to_hash(uint256[4] memory pi) external pure returns (bytes32);
    function end_game(uint256 game_id) external;
    function exec_game(uint256 game_id) external;
    function get_active_game_ids() external view returns (uint256[] memory);
    function get_active_sources() external view returns (uint8);
    function get_alpha(uint256 game_id) external view returns (bytes32);
    function get_current_game_id() external view returns (uint256);
    function get_game(uint256 game_id) external view returns (GameData memory);
    function get_onka_stats(uint256 nft_id) external view returns (OnkaStats memory);
    function get_pyth_fee() external view returns (uint128);
    function get_pyth_request(uint64 src_id) external view returns (EntropyStructs.Request memory req);
    function get_random_value(uint256 req_id) external view returns (bytes32 rand, bool completed);
    function get_randomizer_balance(bool liquid) external view returns (uint256);
    function get_randomizer_fee(bool atomic) external view returns (uint256);
    function get_request_status(uint256 req_id) external view returns (bool active, uint8 remaining_sources);
    function get_revenue_bps() external view returns (uint256);
    function get_speculations(uint256 game_id) external view returns (Speculation[] memory);
    function grantRoles(address user, uint256 roles) external payable;
    function hasAllRoles(address user, uint256 roles) external view returns (bool);
    function hasAnyRole(address user, uint256 roles) external view returns (bool);
    function new_game(Player[2] memory players, uint256 amount, bytes32 alpha_prefix) external payable returns (uint256 game_id);
    function owner() external view returns (address result);
    function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256 result);
    function place_bet(uint256 game_id, address speculator, bool prediction, uint256 amount) external;
    function pyth_enabled() external view returns (bool);
    function randomizerCallback(uint256 _id, bytes32 _beta) external;
    function randomizer_deposit(uint256 amount) external;
    function randomizer_enabled() external view returns (bool);
    function randomizer_withdraw(uint256 amount) external;
    function recover_erc20(address token) external;
    function recover_erc721(address token, uint256 token_id) external;
    function recover_eth() external;
    function register(bytes32 secret) external;
    function renounceOwnership() external payable;
    function renounceRoles(uint256 roles) external payable;
    function requestOwnershipHandover() external payable;
    function revenue_wallet() external view returns (address);
    function revokeRoles(address user, uint256 roles) external payable;
    function rolesOf(address user) external view returns (uint256 roles);
    function sav_callback(uint256 req_id, bytes memory _alpha, bytes32 beta, uint256[4] memory _proof, uint256[2] memory _U, uint256[4] memory _V) external;
    function sav_enabled() external view returns (bool);
    function sav_last_key_update_timestamp() external view returns (uint256);
    function set_revenue(uint256 bps) external;
    function set_revenue_address(address addr) external;
    function set_sav_public_key(uint256[2] memory _publicKey) external;
    function set_sources(uint8 sources) external;
    function start_game(uint256 game_id) external payable;
    function transferOwnership(address newOwner) external payable;
    function verify_beta(uint256[4] memory _proof, bytes memory _beta) external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_nft_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_token_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_pyth_entropy",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_pyth_provider",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_randomizer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_sav_pk",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "_revenue_wallet",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BATTLE_ROUNDS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "HEALTH_PER_LIFE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_HEALTH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NFT_CONTRACT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IERC721"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PYTH_ENTROPY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IEntropy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PYTH_PROVIDER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RANDOMIZER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IRandomizer"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SAV_PUB_KEY",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOKEN_CONTRACT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IERC20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "WINS_REQUIRED",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "_entropyCallback",
    "inputs": [
      {
        "name": "sequence",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "provider",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "randomNumber",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "abort_game",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "abort_request",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "calc_book",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "p1_odds",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "p2_odds",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "p1_depth",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "p2_depth",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calc_fee",
    "inputs": [],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "fee_pyth",
        "type": "uint128",
        "internalType": "uint128"
      },
      {
        "name": "fee_randomizer",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cancelOwnershipHandover",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "completeOwnershipHandover",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "compute_alpha",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "compute_fast_verify_params",
    "inputs": [
      {
        "name": "_proof",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      },
      {
        "name": "_alpha",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "U",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "V",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decoded_proof_to_hash",
    "inputs": [
      {
        "name": "pi",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "end_game",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exec_game",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "get_active_game_ids",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_active_sources",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_alpha",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_current_game_id",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_game",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct GameData",
        "components": [
          {
            "name": "players",
            "type": "tuple[2]",
            "internalType": "struct Player[2]",
            "components": [
              {
                "name": "addr",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "nft_id",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "speculations",
            "type": "tuple[]",
            "internalType": "struct Speculation[]",
            "components": [
              {
                "name": "speculator",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "prediction",
                "type": "bool",
                "internalType": "bool"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum GameStatus"
          },
          {
            "name": "rounds",
            "type": "tuple[]",
            "internalType": "struct RoundResult[]",
            "components": [
              {
                "name": "roll_p1",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "roll_p2",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "p1_won",
                "type": "bool",
                "internalType": "bool"
              }
            ]
          },
          {
            "name": "p1_wins",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "p2_wins",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "bet_pool",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "alpha_prefix",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_onka_stats",
    "inputs": [
      {
        "name": "nft_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct OnkaStats",
        "components": [
          {
            "name": "plays",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "wins",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "losses",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_pyth_fee",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint128",
        "internalType": "uint128"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_pyth_request",
    "inputs": [
      {
        "name": "src_id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "req",
        "type": "tuple",
        "internalType": "struct EntropyStructs.Request",
        "components": [
          {
            "name": "provider",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "sequenceNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "numHashes",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "commitment",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "requester",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "useBlockhash",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "isRequestWithCallback",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_random_value",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "rand",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "completed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_randomizer_balance",
    "inputs": [
      {
        "name": "liquid",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_randomizer_fee",
    "inputs": [
      {
        "name": "atomic",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_request_status",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "active",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "remaining_sources",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_revenue_bps",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "get_speculations",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct Speculation[]",
        "components": [
          {
            "name": "speculator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "prediction",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRoles",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "hasAllRoles",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasAnyRole",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "new_game",
    "inputs": [
      {
        "name": "players",
        "type": "tuple[2]",
        "internalType": "struct Player[2]",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nft_id",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "alpha_prefix",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "result",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ownershipHandoverExpiresAt",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "place_bet",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "speculator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "prediction",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pyth_enabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomizerCallback",
    "inputs": [
      {
        "name": "_id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_beta",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "randomizer_deposit",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "randomizer_enabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomizer_withdraw",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "recover_erc20",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "recover_erc721",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "recover_eth",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "register",
    "inputs": [
      {
        "name": "secret",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "renounceRoles",
    "inputs": [
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestOwnershipHandover",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "revenue_wallet",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revokeRoles",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "rolesOf",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "roles",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "sav_callback",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_alpha",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "beta",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "_proof",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      },
      {
        "name": "_U",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "_V",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sav_enabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "sav_last_key_update_timestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "set_revenue",
    "inputs": [
      {
        "name": "bps",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "set_revenue_address",
    "inputs": [
      {
        "name": "addr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "set_sav_public_key",
    "inputs": [
      {
        "name": "_publicKey",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "set_sources",
    "inputs": [
      {
        "name": "sources",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "start_game",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "verify_beta",
    "inputs": [
      {
        "name": "_proof",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      },
      {
        "name": "_beta",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "BetPlaced",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "addr",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "prediction",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CallbackOnInactiveGame",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "status",
        "type": "uint8",
        "indexed": true,
        "internalType": "enum GameStatus"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CallbackOnInactiveRequest",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "flag",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      },
      {
        "name": "sequence_number",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameAborted",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameCompleted",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "winner",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      },
      {
        "name": "rounds",
        "type": "tuple[5]",
        "indexed": false,
        "internalType": "struct RoundResult[5]",
        "components": [
          {
            "name": "roll_p1",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "roll_p2",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "p1_won",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameCreated",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "players",
        "type": "tuple[2]",
        "indexed": false,
        "internalType": "struct Player[2]",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nft_id",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameExecuted",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GameStarted",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipHandoverCanceled",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipHandoverRequested",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RandomnessGenerated",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "flag",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RandomnessRequested",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "flag",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RandomnessSourcesUpdated",
    "inputs": [
      {
        "name": "old_sources",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "new_sources",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RequestAborted",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RequestCompleted",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RevenueSet",
    "inputs": [
      {
        "name": "bps",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RolesUpdated",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "roles",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SAVPublicKeyUpdated",
    "inputs": [
      {
        "name": "newPublicKey",
        "type": "uint256[2]",
        "indexed": false,
        "internalType": "uint256[2]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TokenNotSupported",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reason",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UserRegistered",
    "inputs": [
      {
        "name": "secret",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "addr",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "GameExecNotReady",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "addr",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientFee",
    "inputs": [
      {
        "name": "fee_supplied",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidGame",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidGameID",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidGameStatus",
    "inputs": [
      {
        "name": "game_id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "current",
        "type": "uint8",
        "internalType": "enum GameStatus"
      },
      {
        "name": "required",
        "type": "uint8",
        "internalType": "enum GameStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInput",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNFTOwnership",
    "inputs": [
      {
        "name": "player",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nft_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidPrediction",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidRequest",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidVRFProof",
    "inputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "NewOwnerIsZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoHandoverRequest",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "RegistrationFailed",
    "inputs": [
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "RequestCollision",
    "inputs": [
      {
        "name": "req_id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedCaller",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod OnkasOujiGame {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610140604052346104da576040516162173881900390601f8201601f19168301906001600160401b038211848310176104df5782916040528339810190610100818303126104da57610050816104f5565b9061005d602082016104f5565b9161006a604083016104f5565b91610077606082016104f5565b94610084608083016104f5565b908060bf840112156104da5760408051939084016001600160401b038111858210176104df57604052839060e081019283116104da5760a001905b8282106104ca5750506100d1906104f5565b6001600090815533638b78c6d819819055919791959086906000805160206161d78339815191528180a3638b78c6d8600c52336000526020600c206003815417809155600c5160601c6000805160206161f7833981519152600080a36001805462ffffff1916620101011790819055906001600160a01b03831615610485576001600160a01b03169081156104405760ff8160081c166103ed575b60101c60ff1661038d575b60c05260a0526001600160a01b031660e05260005b60028110610378575050600060805260c8600f556010805460ff191660011790556001600160a01b03169081158015610367575b8015610356575b6103455780638b78c6d8195560006000805160206161d78339815191528180a3638b78c6d8600c52336000526020600c206001815417809155600c5160601c6000805160206161f7833981519152600080a3610120526001600160a01b03166101005260108054610100600160a81b03191660089290921b610100600160a81b0316919091179055604051615ccd908161050a82396080518181816109180152614b40015260a051818181610b65015281816111c9015281816122760152613487015260c051818181610ba7015281816115af015281816122c00152818161277d01526134b9015260e051818181610a5e01528181610cfb01528181610ee0015281816123900152818161288f01528181612f3001528181612fcb015281816135360152818161388a015261411301526101005181818161120e0152818161174d015281816118d30152818161245401528181612e3201528181613cc70152818161421e0152614758015261012051818181610e9001526147f80152f35b63b4fa3fb360e01b60005260046000fd5b506001600160a01b038416156101c7565b506001600160a01b038316156101c0565b6001906020835193019281600201550161018c565b83511515806103e0575b6101775760405162461bcd60e51b815260206004820152601660248201527f496e76616c696420534156207075626c6963206b6579000000000000000000006044820152606490fd5b5060208401511515610397565b6001600160a01b03841661016c5760405162461bcd60e51b815260206004820152601a60248201527f496e76616c69642052616e646f6d697a657220616464726573730000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601460248201527f496e76616c6964205079746820656e74726f70790000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601560248201527f496e76616c696420507974682070726f766964657200000000000000000000006044820152606490fd5b81518152602091820191016100bf565b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b03821682036104da5756fe6080604052600436101561001257600080fd5b60003560e01c8063028995cd1461044d57806305a835bf146104485780630b12e4ba146104435780630ebbcfb51461043e578063162fc30114610439578063183a4f6e14610434578063193ccb61146103da5780631c10893f1461042f5780631cd64df41461042a5780631e464309146104255780631fda9a021461042057806321dd95761461041b57806323a8c4ba14610416578063254a39fe14610411578063256929621461040c5780632c2aab41146103ee5780632de948071461040757806331052c301461040257806333e7977a146103fd57806336339388146103f8578063397606c0146103f35780633b66f1c0146103ee5780633db132b1146103e9578063435c0298146103e4578063436cfb9b146103df5780634419df3a146103da5780634a4ee7b1146103d557806350f1c55a146103d0578063514e62fc146103cb57806352a5f1f8146103c657806354d1f13d146103c15780635bbe0694146103bc57806365835e5a146103b757806367f188b7146103b25780636a411b0c146103ad5780636f59232f146103a8578063715018a6146103a35780638228b1e21461039e5780638a95e6df146103995780638d3e445a146103945780638da5cb5b1461038f5780638eaa495d1461038a5780639171e5581461038557806394c593141461038057806394e7ecfb1461037b57806398e5030a146103765780639dcc21bd14610371578063a1bdc6081461036c578063aab586c214610367578063ace3a15314610362578063afb218f51461035d578063b516105c14610358578063b6f9005414610353578063bad018991461034e578063bc3f1f0a14610349578063c0a7795214610344578063d0be0b9c1461033f578063d9fb3aba1461033a578063de85843714610335578063e1fa8e8414610330578063e243adbf1461032b578063ebe93caf14610326578063ecc0448514610321578063f04e283e1461031c578063f2fde38b14610317578063f7d2467314610312578063f98118d51461030d5763fee81cf41461030857600080fd5b613180565b613154565b6130f2565b6130b2565b61305e565b612f87565b612f17565b612efb565b612df9565b612dcd565b612cfe565b612b11565b612ad6565b6128be565b612879565b61284a565b6127ac565b612767565b6126c1565b6125ee565b612592565b612425565b612354565b612338565b612207565b61215e565b612138565b61210b565b612088565b61202b565b611fcf565b611f83565b611ef1565b611ec4565b611de7565b6117ed565b6116d4565b611682565b611582565b61152c565b6113d6565b6113aa565b610d81565b611384565b61134b565b6112b0565b610feb565b61123d565b6111f8565b6111b3565b6110ab565b611011565b610f9f565b610f81565b610f4b565b610ebf565b610e7a565b610e5c565b610e16565b610dae565b610d67565b610cda565b610871565b610845565b610488565b610462565b600091031261045d57565b600080fd5b3461045d57600036600319011261045d57602061047d6131b7565b60ff60405191168152f35b3461045d57602036600319011261045d576004356104a461439b565b6104ad816143f0565b60068101805460ff1916600217905590600091826104ca83614361565b91909115610836576104da61326a565b91855b60ff8116916005831080610829575b8061081c575b156106b757604080516020810192835260f884901b6001600160f81b0319169181019190915261052f81604181015b03601f198101835282611bde565b51902091610549610544600685065b60ff1690565b613301565b9261052161058261055985613301565b604080516020810195865260f89290921b6001600160f81b031916908201529182906041820190565b519020926105956105446006860661053e565b985b60ff8a1660ff8316146106355760ff8a1660ff831611908160001461061457916105f861060f9594926105ef6105cf610609966132da565b9d5b6105e56105dc611bff565b60ff9096168652565b60ff166020850152565b15156040830152565b6106028289613327565b5286613327565b506132da565b6104dd565b9995916105f861060f9594926105ef61062f610609966132da565b996105d1565b98505091604051610661816105216020820194856026918152651c995c9bdb1b60d21b60208201520190565b519020916106746105446006850661053e565b9260405161069e816105216020820194856027918152663932b937b6361960c91b60208201520190565b519020926106b16105446006860661053e565b98610597565b505050939160ff6106c88685613313565b16936106d38561328f565b9360005b60ff8116878110156107105760ff91610708826106f66001948a613327565b51610701828c613327565b5289613327565b5001166106d7565b50506107d3600161078560029360ff808c61072e8c60078c0161336d565b60088a8101805460ff871661ffff19909116179183901b61ff0016919091179055169116119560009661076e84830154600052600e602052604060002090565b6107788154613449565b9055610798846002840160005b500154600052600e602052604060002090565b6107a28154613449565b9055801561080e57836107ba816107858b5b86613435565b016107c58154613449565b905515610807578290613435565b016107de8154613449565b90557f31543961bad6e1b886fe4b3c060d3d97c21fbc80e63ab22e9eea65d9d2dc7c778280a280f35b8690613435565b836107ba81610785816107b4565b50600360ff8516106104f2565b50600360ff8916106104ec565b6332926edd60e01b8552600485fd5b3461045d57600036600319011261045d576020610860613470565b6001600160801b0360405191168152f35b602036600319011261045d5760043561088861439b565b61089181614472565b61089961382b565b5050803410610cc2575060068101805460ff191660011790556108db90600a81015481546002909201546001600160a01b039283169083161890911683181890565b6108e361439b565b6108eb614621565b8115610cb15760ff61091161090a846000526007602052604060002090565b5460ff1690565b16610c9b577f0000000000000000000000000000000000000000000000000000000000000000610c80575b349061094661382b565b9291803410610c68575060015460ff16610b19575b505060015460081c60ff16610a0c575b505060015460101c60ff166109ac575b6109856001600055565b7f50ad08f58a27f2851d7e3a1b3a6a46b290f2ce677e99642d30ff639721e77790600080a2005b6109df6109c3826000526007602052604060002090565b60046109d0825460ff1690565b1760ff1660ff19825416179055565b6004817f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a361097b565b610a30610a23846000526007602052604060002090565b60026109d0825460ff1690565b610b0a575b5060405163d845a4b360e01b8152620186a0600482015260208160248160006001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165af1908115610b05578291610aa691600091610ad6575b506000526006602052604060002090565b556002817f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a3388061096b565b610af8915060203d602011610afe575b610af08183611bde565b810190614194565b38610a95565b503d610ae6565b613464565b610b139061352c565b38610a35565b610ba29293506001600160801b03602091610b4e610b41886000526007602052604060002090565b60016109d0825460ff1690565b6040516319cb825f60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016600482015260248101949094529293921691839081906044820190565b0381847f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af18015610b0557610c028591610c0994600091610c39575b506001600160401b03166000526005602052604060002090565b5534613b66565b906001837f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a3388061095b565b610c5b915060203d602011610c61575b610c538183611bde565b810190614549565b38610be8565b503d610c49565b63a458261b60e01b6000523460045260245260446000fd5b80610c95836000526009602052604060002090565b5561093c565b636ae0096760e01b600052600482905260246000fd5b6341abc80160e01b60005260046000fd5b63a458261b60e01b6000523460045260245260446000fd5b3461045d5760006020366003190112610d6457600435610cf861439b565b817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b15610d6257602460405180948193634ffd2e4360e01b83523060048401525af18015610b05578290610d545780f35b610d5d91611bde565b388180f35b505b80fd5b602036600319011261045d57610d7f60043533614d91565b005b3461045d57600036600319011261045d57602060405160038152f35b6001600160a01b0381160361045d57565b604036600319011261045d57600435610dc681610d9d565b60243590610dd26143b7565b638b78c6d8600c526000526020600c2090815417809155600c5160601c7f715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26600080a3005b3461045d57604036600319011261045d576020610e52600435610e3881610d9d565b602435918291638b78c6d8600c526000526020600c205490565b1614604051908152f35b3461045d57600036600319011261045d576020600454604051908152f35b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d5760006020366003190112610d645780600435610ede61439b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690813b15610f4757604051632465f8f560e01b8152336004820152602481019190915291908290604490829084905af18015610b05578290610d545780f35b5050fd5b3461045d57602036600319011261045d576080610f69600435613618565b91604051938452602084015260408301526060820152f35b3461045d57600036600319011261045d576020600f54604051908152f35b600036600319011261045d5763389a75e1600c52336000526202a30042016020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a2005b3461045d57602036600319011261045d576020611009600435613793565b604051908152f35b3461045d57602036600319011261045d57602061100960043561103381610d9d565b638b78c6d8600c526000526020600c205490565b602060408183019282815284518094520192019060005b81811061106b5750505090565b90919260206110a1600192865190604060609260018060a01b038151168352602081015115156020840152015160408201520190565b940192910161105e565b3461045d57602036600319011261045d57600435801580156111a8575b611197576110e2600491600052600b602052604060002090565b0180546110ee81613727565b9160005b82811061110b57604051806111078682611047565b0390f35b8061112961111b60019385613777565b50546001600160a01b031690565b6111416111368386613777565b505460a01c60ff1690565b6111768461114f8588613777565b5001549161116d61115e611bff565b6001600160a01b039095168552565b15156020840152565b60408201526111858287613327565b526111908186613327565b50016110f2565b635df626e160e11b60005260046000fd5b50600a5481116110c8565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d57602036600319011261045d57600435611259613227565b50600052600e602052604060002060026040519161127683611b6b565b8054835260018101546020840152015460408201526040518091604060608301918051845260208101516020850152015160408301520390f35b3461045d57600036600319011261045d576112c96143b7565b47801561130e576000808080610d7f94335af13d15611309573d6112ec81611ce0565b906112fa6040519283611bde565b8152600060203d92013e6137df565b6137df565b60405162461bcd60e51b815260206004820152601560248201527427379022aa2417a226aa103a37903932b1b7bb32b960591b6044820152606490fd5b3461045d57600036600319011261045d5760606001600160801b0361136e61382b565b9192906040519384521660208301526040820152f35b3461045d57600036600319011261045d57602060ff60015460081c166040519015158152f35b604036600319011261045d57610d7f6004356113c581610d9d565b602435906113d16143b7565b614d91565b3461045d57604036600319011261045d576004356113f381610d9d565b602435906113ff6143b7565b6040516331a9108f60e11b8152600481018390526001600160a01b03919091169190602081602481865afa90816114ff575b506114a757507fb398ca235b3eff2f67e7270724650d13e47cd5f9dac13b9187ed81b127ce24c7604051806114a28160809060208152602160208201527f4e6f7420616e20455243373231206f7220696e76616c696420746f6b656e20496040820152601160fa1b60608201520190565b0390a2005b90803b1561045d57604051632142170760e11b815230600482015233602482015260448101929092526000908290606490829084905af18015610b05576114ea57005b806114f96000610d7f93611bde565b80610452565b6115209060203d602011611525575b6115188183611bde565b810190613922565b611431565b503d61150e565b3461045d57604036600319011261045d57602060043561154b81610d9d565b61156660243591638b78c6d8600c526000526020600c205490565b161515604051908152f35b6001600160401b0381160361045d57565b3461045d57606036600319011261045d5760043561159f81611571565b6115aa602435610d9d565b6044357f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316801561163d5733036115ec57610d7f9161459d565b60405162461bcd60e51b815260206004820152602360248201527f4f6e6c7920456e74726f70792063616e2063616c6c20746869732066756e637460448201526234b7b760e91b6064820152608490fd5b60405162461bcd60e51b815260206004820152601760248201527f456e74726f70792061646472657373206e6f74207365740000000000000000006044820152606490fd5b600036600319011261045d5763389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2005b8015150361045d57565b3461045d57608036600319011261045d576024356004356116f482610d9d565b60443590611701826116ca565b6064359161170d61439b565b61171682614472565b83156117dc577f4af71b021e799c62c158bd54636ca8da2fa26115a21a2dc6efe486ec104fd15f916117d79160099061177a87308a7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166145bf565b6117ac60405161178981611b6b565b6001600160a01b038a168152841515602082015288604082015260048301613975565b016117b8868254613457565b90556040519485521515946001600160a01b0316939081906020820190565b0390a4005b63162908e360e11b60005260046000fd5b3461045d57602036600319011261045d57600435611809614621565b61181161439b565b61182261181d826144dc565b613a90565b9061183160a083015160ff1690565b60ff61184461053e60c086015160ff1690565b911611600090600014611b50575060015b6118626040840151613340565b926000809460e08301519561187686613618565b90918a15159384611b46575b5083611b3c575b508715611b345750905b60105460ff16611aea575b6118c560066118b78a600052600b602052604060002090565b01805460ff19166003179055565b6118ce88614e2f565b5085517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169461192e916119289061191a908b15611ae15760ff60005b1690613b73565b51516001600160a01b031690565b866146c1565b611a57575085965061195561195060809697600052600b602052604060002090565b614747565b60105460ff8116611a2e575b505050500180515160ff1690611975613b84565b9360ff60009316925b60ff8116848110156119b85760ff916119b08261199e6001948851613327565b516119a9828c613b9d565b5289613b9d565b50011661197e565b86838715611a04577f8ef01de748555cd1d5431d653dab86432a1d7d75096621deca7a6e4b414de63660ff60005b6119f7604051928392169582613bae565b0390a3610d7f6001600055565b7f8ef01de748555cd1d5431d653dab86432a1d7d75096621deca7a6e4b414de63660ff60016119e6565b611a4e93611a489160081c6001600160a01b031692613457565b916146c1565b38808080611961565b602085015180519160005b838110611a785750505050608094959650611955565b80611a926020611a8a60019487613327565b510151151590565b8a151590151503611aa4575b01611a62565b611adc611ac98d611ac3866040611abb878b613327565b51015161455e565b90614717565b611ad661191a8488613327565b896146c1565b611a9e565b60ff6001611913565b979291509250600f5492611afe8483614643565b938815611b2957611b12611b239185614643565b611b1d868295613b66565b94613b66565b9761189e565b50611b236000611b12565b905090611893565b1515925038611889565b1515935038611882565b611855565b634e487b7160e01b600052604160045260246000fd5b606081019081106001600160401b03821117611b8657604052565b611b55565b604081019081106001600160401b03821117611b8657604052565b61010081019081106001600160401b03821117611b8657604052565b61012081019081106001600160401b03821117611b8657604052565b90601f801991011681019081106001600160401b03821117611b8657604052565b60405190611c0e606083611bde565b565b60405190611c0e61012083611bde565b60405190611c0e604083611bde565b90611c0e6040519283611bde565b919060405192611c4e608085611bde565b83906080810192831161045d57905b828210611c6957505050565b8135815260209182019101611c5d565b91906040805193611c8a8286611bde565b8491810192831161045d57905b828210611ca357505050565b8135815260209182019101611c97565b806083121561045d57611cc7906064611c3d565b90565b80610143121561045d57611cc790610124611c3d565b6001600160401b038111611b8657601f01601f191660200190565b81601f8201121561045d57803590611d1282611ce0565b92611d206040519485611bde565b8284526020838301011161045d57816000926020809301838601378301015290565b9060a060031983011261045d57816023121561045d57611d63826004611c3d565b91608435906001600160401b03821161045d57611cc791600401611cfb565b906000905b60028210611d9457505050565b6020806001928551815201930191019091611d87565b60409093929193611dbf8160c0810196611d82565b016000905b60048210611dd157505050565b6020806001928551815201930191019091611dc4565b3461045d57611df536611d42565b906111076040808051611e088282611bde565b3690376080808251611e1a8282611bde565b369037611e41611e28613c28565b95611e31613c03565b50611e3a613c18565b5086614f23565b94611ea9611e90611e786060840198611e6f8a51611e5f8760400190565b80518e51919e6020015192614ffc565b96909a516150a5565b9390995190611e8981519160200190565b51916150a5565b949093611e9c87611c2f565b9889526020890152611c2f565b96875260208701528286015260608501525192839283611daa565b3461045d57600036600319011261045d5760105460405160089190911c6001600160a01b03168152602090f35b60c036600319011261045d57366023121561045d5760408051611f148282611bde565b803660841161045d576004905b60848210611f4b5761110784611f3c60a43560843587613c5e565b90519081529081906020820190565b838236031261045d57602084918251611f6381611b8b565b8435611f6e81610d9d565b81528285013583820152815201910190611f21565b600036600319011261045d57611f976143b7565b6000638b78c6d819547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a36000638b78c6d81955005b3461045d57602036600319011261045d57600435611feb61439b565b80600052600760205260ff604060002054161561200457005b7f6248d5a209702db872b83045d56e4baf48362ce7a7cda285a671e7c1e63f44b9600080a2005b3461045d57600036600319011261045d57602060ff600154166040519015158152f35b602060408183019282815284518094520192019060005b8181106120725750505090565b8251845260209384019390920191600101612065565b3461045d57600036600319011261045d57604051806020600c54918281520190600c6000527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c79060005b8181106120f557611107856120e981870382611bde565b6040519182918261204e565b82548452602090930192600192830192016120d2565b3461045d57600036600319011261045d57638b78c6d819546040516001600160a01b039091168152602090f35b3461045d57600036600319011261045d57602060ff60015460101c166040519015158152f35b3461045d57600036600319011261045d576020600a54604051908152f35b611c0e9092919260e08061010083019560018060a01b0381511684526001600160401b03602082015116602085015263ffffffff6040820151166040850152606081015160608501526121df608082015160808601906001600160401b03169052565b60a0818101516001600160a01b03169085015260c08181015115159085015201511515910152565b3461045d57602036600319011261045d576122bc61010060043561222a81611571565b600060e060405161223a81611ba6565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260405180938192636151ab1f60e01b83527f0000000000000000000000000000000000000000000000000000000000000000600484019092916001600160401b03602091604084019560018060a01b0316845216910152565b03817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015610b055761110791600091612309575b506040519182918261217c565b61232b91506101003d8111612331575b6123238183611bde565b810190614062565b386122fc565b503d612319565b3461045d57600036600319011261045d57602060405160098152f35b3461045d57602036600319011261045d57600435612371816116ca565b60408051631fc50ef560e31b81523060048201526000929091826024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610b0557839284926123e3575b5060209350156123dd5761100991613b66565b50611009565b925090506040823d60401161241d575b8161240060409383611bde565b81010312612419579160209283835193015191936123ca565b8280fd5b3d91506123f3565b3461045d57602036600319011261045d5760043561244281610d9d565b61244a6143b7565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811691908116908183036124dc5750506040516370a0823160e01b815230600482015290602082602481845afa908115610b0557610d7f926000926124bb575b5033906146c1565b6124d591925060203d602011610afe57610af08183611bde565b90386124b3565b6040516370a0823160e01b815230600482015291925090602081602481865afa60009181612571575b5061255c5750507fb398ca235b3eff2f67e7270724650d13e47cd5f9dac13b9187ed81b127ce24c7604051806114a28160609060208152600c60208201526b04e6f7420616e2045524332360a41b60408201520190565b8091925061256657005b610d7f9133906146c1565b61258b91925060203d602011610afe57610af08183611bde565b9038612505565b3461045d57602036600319011261045d576125be6004356125b1614621565b6125b961439b565b6141a3565b6001600055005b806023121561045d57611cc7906004611c79565b80610103121561045d57611cc79060e4611c79565b3461045d57604036600319011261045d57612608366125c5565b6126106143d4565b60045461384081018091116126bc57421061266d57612668816126537fc6a468b84385cd4dfc440db21d0df6f03612ba43b35efe190dee993b466a5198936142ad565b61265c42600455565b604051918291826142d1565b0390a1005b60405162461bcd60e51b815260206004820152602160248201527f4b6579206368616e676520636f6f6c646f776e3a2077616974203420686f75726044820152607360f81b6064820152608490fd5b6132c4565b3461045d57602036600319011261045d5760043560ff8116810361045d577fa18893a16b818f3e8c53189231250cb02bb55cb32802a6d5c2b5eb856cdb7f1e906127096143b7565b6127116131b7565b6001805461ffff1916908316151560ff161760028316151560081b61ff00161762ff0000191660048316151560101b62ff000016176001556040805160ff92831681529190921660208201529081908101612668565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d576111076127fd6001600160801b0361283261282c6127ce36611d42565b94906127e26127db613c28565b9687614f23565b92909660608301519060408401516020825192015192614ffc565b9060608301519760408401986128208a519186516020880193898686519461508e565b96909551915192615132565b60801c90565b91516040519190921690911481529081906020820190565b3461045d57608036600319011261045d57366023121561045d576020611009612874366004611c3d565b6142e1565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d576101a036600319011261045d576004356024356001600160401b03811161045d576128f2903690600401611cfb565b604435906128ff36611cb3565b612908366125d9565b61291136611cca565b9061291a6143d4565b600460ff61293561090a896000526007602052604060002090565b1603612a6b5761294486613793565b61294d8561433e565b6040516129668161052160208201948560209181520190565b519020906040516129838161052160208201948560209181520190565b51902003612a345784612995846142e1565b036129fd576129b3936129af936129aa613c28565b614920565b1590565b6129c15781610d7f92614a29565b604051631f7b49ed60e31b81526020600482015260136024820152721d995c9a599a58d85d1a5bdb8819985a5b1959606a1b6044820152606490fd5b604051631f7b49ed60e31b815260206004820152600e60248201526d0e0e4dedecc40dad2e6dac2e8c6d60931b6044820152606490fd5b604051631f7b49ed60e31b815260206004820152600e60248201526d0c2d8e0d0c240dad2e6dac2e8c6d60931b6044820152606490fd5b60405162461bcd60e51b815260206004820152603d60248201527f534156206d757374206265206c6173742063616c6c6261636b3a206f7468657260448201527f2070726f7669646572732068617665206e6f7420636f6d706c657465640000006064820152608490fd5b3461045d57602036600319011261045d57600435612af26143b7565b610bb88111612b0057600f55005b63b4fa3fb360e01b60005260046000fd5b3461045d57602036600319011261045d576004356000526007602052604060ff81600020541681519080151582526020820152f35b906000905b60028210612b5857505050565b825180516001600160a01b0316825260209081015182820152600191604001930191019091612b4b565b906020808351928381520192019060005b818110612ba05750505090565b9091926020612bd6600192865190604060609260018060a01b038151168352602081015115156020840152015160408201520190565b9401929101612b93565b60051115612bea57565b634e487b7160e01b600052602160045260246000fd5b906005821015612bea5752565b906020808351928381520192019060005b818110612c2b5750505090565b9091926020612c5f600192865190604060609260ff815116835260ff60208201511660208401520151151560408201520190565b9401929101612c1e565b60208152612c7b602082018351612b46565b610180610100612cce612c9d60208601518460a08701526101a0860190612b82565b604086015160c0860152612cb9606087015160e0870190612c00565b6080860151858203601f190184870152612c0d565b60a085015160ff166101208501529360c081015160ff1661014085015260e0810151610160850152015191015290565b3461045d57602036600319011261045d57600435604051612d1e81611bc2565b6040908151612d2d8382611bde565b60005b838110612dab5750816101009160009352606060208201528284820152826060820152606060808201528260a08201528260c08201528260e0820152015281158015612da0575b61119757612d9561181d61110793600052600b602052604060002090565b905191829182612c69565b50600a548211612d77565b6020908451612db981611b8b565b600081526000838201528184015201612d30565b3461045d57602036600319011261045d576040612deb600435614361565b825191825215156020820152f35b3461045d57602036600319011261045d57600435604051636eb1769f60e11b8152336004820152306024820152602081806044810103817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610b0557600091612edc575b5060001911612e9d5733907ff62ba47fe3ff610889160f02571396e86e21b7aadcbde2719192e206853b331f600080a3005b6040516310d05f1160e21b8152602060048201526016602482015275496e73756666696369656e7420616c6c6f77616e636560501b6044820152606490fd5b612ef5915060203d602011610afe57610af08183611bde565b38612e6b565b3461045d57600036600319011261045d57602060405160058152f35b3461045d57604036600319011261045d576004356024357f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303612f765781610d7f926000526006602052604060002054614baf565b635c427cd960e01b60005260046000fd5b3461045d57602036600319011261045d57600435612fa4816116ca565b60405163127e8e4d60e01b8152620186a06004820152906020826024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa918215610b055760009261303d575b50819015613010575b604051908152602090f35b506130196140f8565b9080821061302c57505060206000613005565b60209161303891613b66565b613005565b61305791925060203d602011610afe57610af08183611bde565b9038612ffc565b602036600319011261045d5760043561307681610d9d565b61307e6143b7565b63389a75e1600c52806000526020600c2090815442116130a4576000610d7f92556148b7565b636f5e88186000526004601cfd5b602036600319011261045d576004356130ca81610d9d565b6130d26143b7565b8060601b156130e457610d7f906148b7565b637448fbae6000526004601cfd5b3461045d57602036600319011261045d5760043561310f81610d9d565b6131176143b7565b60108054610100600160a81b03191660089290921b610100600160a81b0316919091179055005b634e487b7160e01b600052603260045260246000fd5b3461045d57602036600319011261045d57600435600281101561045d5760209060020154604051908152f35b3461045d57602036600319011261045d5760043561319d81610d9d565b63389a75e1600c52600052602080600c2054604051908152f35b600060015460ff81166131ef575b60ff8160081c166131e4575b60101c60ff166131de5790565b60041790565b6002909117906131d1565b600191506131c5565b906005811015612bea5760ff80198354169116179055565b6001600160401b038111611b865760051b60200190565b6040519061323482611b6b565b60006040838281528260208201520152565b60005b82811061325557505050565b602090613260613227565b8184015201613249565b6040519060c061327a8184611bde565b60058352611c0e90601f190160208401613246565b90611c0e61329c83613210565b6132a96040519182611bde565b838152602081946132bc601f1991613210565b019101613246565b634e487b7160e01b600052601160045260246000fd5b60ff1660ff81146126bc5760010190565b634e487b7160e01b600052601260045260246000fd5b60ff60019116019060ff82116126bc57565b9060ff8091169116019060ff82116126bc57565b805182101561333b5760209160051b010190565b61313e565b908160011b91808304600214901517156126bc57565b818102929181159184041417156126bc57565b9055565b815191600160401b8311611b8657815483835580841061340c575b50602061339c910191600052602060002090565b6000915b8383106133ad5750505050565b6001602082613400839451868151815460ff191660ff91909116178155906040906020810151835461ff00191660089190911b61ff00161791015162ff00001990911690151560101b62ff000016179055565b019201920191906133a0565b8260005283602060002091820191015b8181106134295750613388565b6000815560010161341c565b90600281101561333b5760011b0190600090565b90600182018092116126bc57565b919082018092116126bc57565b6040513d6000823e3d90fd5b604051631711922960e31b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602090829060249082907f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b05576000916134ed575090565b6020813d602011613524575b8161350660209383611bde565b81010312610d625751906001600160801b0382168203610d64575090565b3d91506134f9565b61353461439b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b1561045d57600090602460405180948193634ffd2e4360e01b83523060048401525af18015610b05576135905750565b6000611c0e91611bde565b9081546135a781613210565b926135b56040519485611bde565b818452602084019060005260206000206000915b8383106135d65750505050565b600260206001926040516135e981611b6b565b60ff8654868060a01b038116835260a01c161515838201528486015460408201528152019201920191906135c9565b801580156136e2575b61119757600461363e61364492600052600b602052604060002090565b0161359b565b805160009291839182915b8183106136905750505080151580613687575b1561367f57613671838261455e565b9261367c828261455e565b92565b600092600092565b50821515613662565b9091926136a56129af6020611a8a8786613327565b156136c75760019060406136b98685613327565b51015101935b01919061364f565b929460019060406136d88885613327565b51015101956136bf565b50600a548111613621565b604051906136fc602083611bde565b600080835282815b82811061371057505050565b60209061371b613227565b82828501015201613704565b9061373182613210565b61373e6040519182611bde565b828152809261374f601f1991613210565b019060005b82811061376057505050565b60209061376b613227565b82828501015201613754565b805482101561333b5760005260206000209060011b0190600090565b801580156137d4575b611197576000818152600b60205260409020600a81015481546002909201546001600160a01b03928316908316189091169091181890565b50600a54811161379c565b156137e657565b60405162461bcd60e51b815260206004820152601760248201527f4554482f444d54207472616e73666572206661696c65640000000000000000006044820152606490fd5b60009060009060015460ff8116613903575b60081c60ff16613861575b6001600160801b0383168281018091116126bc57929190565b60405163127e8e4d60e01b8152620186a060048201529091506020816024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b05576000916138e4575b506138c46140f8565b8181106138d657505060005b90613848565b6138df91613b66565b6138d0565b6138fd915060203d602011610afe57610af08183611bde565b386138bb565b925060ff61390f613470565b93905061383d565b5190611c0e82610d9d565b9081602091031261045d5751611cc781610d9d565b8151815460208401516001600160a01b039092166001600160a81b03199091161790151560a01b60ff60a01b16178155604090910151600190910155565b8054600160401b811015611b865761399291600182018155613777565b9190916139a257611c0e91613937565b634e487b7160e01b600052600060045260246000fd5b90604051916139c683611b8b565b6000835b600282106139d757505050565b600260206001926040516139ea81611b8b565b848060a01b03875416815284870154838201528152019301910190916139ca565b6005821015612bea5752565b908154613a2381613210565b92613a316040519485611bde565b818452602084019060005260206000206000915b838310613a525750505050565b600160208192604051613a6481611b6b565b60ff86548181168352818160081c168584015260101c1615156040820152815201920192019190613a45565b90600a613a9b611c10565b92613aa5816139b8565b8452613ab36004820161359b565b602085015260058101546040850152613adc613ad3600683015460ff1690565b60608601613a0b565b613ae860078201613a17565b6080850152613b22613b186008830154613b0f613b058260ff1690565b60ff1660a0890152565b60081c60ff1690565b60ff1660c0860152565b600981015460e08501520154610100830152565b70014551231950b75fc4402da1732fc9bebe19039070014551231950b75fc4402da1732fc9bebe1982116126bc57565b919082039182116126bc57565b90600281101561333b5760051b0190565b60405190611c0e60a0613b978185611bde565b83613246565b90600581101561333b5760051b0190565b91906101e08301926000905b60058210613bc757505050565b6020613bf8600192855190604060609260ff815116835260ff60208201511660208401520151151560408201520190565b930191019091613bba565b604090815191613c138184611bde565b368337565b604051906080613c138184611bde565b6040519060026000835b60028210613c4857505050611c0e604083611bde565b6001602081928554815201930191019091613c32565b91613c6761439b565b613c7183516147c8565b6020830191613c8083516147c8565b60208451015160208451015114612b0057613e0593613e197fd478fa2472011ca0798d35115fc3caa7268c49cb7dc88a2518344fc9631bbf2c93613d1a8460018060a01b037f000000000000000000000000000000000000000000000000000000000000000016613d0582613cfd885160018060a01b0390511690565b3090846145bf565b8851513091906001600160a01b0316906145bf565b613d2d613d28600a54613e1f565b600a55565b600a54968796604092613d3f84611c2f565b8651519092906001600160a01b0316602088510151613d6e613d5f611c20565b6001600160a01b039093168352565b6020828101919091529084528151516001600160a01b031691510151613d95613d5f611c20565b60208201526020830152613da76136ed565b613daf61326a565b90613db8611c10565b93845260208401528785840152600060608401526080830152600060a0830152600060c0830152600060e0830152610100820152613e0088600052600b602052604060002090565b613f49565b613e0e866150b3565b505192839283613ff5565b0390a290565b60001981146126bc5760010190565b916133699183549060031b91821b91600019901b19161790565b906000905b60028210613e5a57505050565b8051805184546001600160a01b0319166001600160a01b0391909116178455600191600291602091908201518487015501930191019091613e4d565b815191600160401b8311611b86578154838355808410613ef4575b506020613ec5910191600052602060002090565b6000915b838310613ed65750505050565b6002602082613ee86001945186613937565b01920192019190613ec9565b6001600160ff1b03811681036126bc576001600160ff1b03841684036126bc578260005260206000209060011b8101908460011b015b818110613f375750613eb1565b60008082556001820155600201613f2a565b90610100600a91613f5b815185613e48565b613f6c602082015160048601613e96565b60408101516005850155613f906060820151613f8781612be0565b600686016131f8565b613fa160808201516007860161336d565b613fe460088501613fc9613fb960a085015160ff1690565b825460ff191660ff909116178255565b60c0830151815461ff00191660089190911b61ff0016179055565b60e081015160098501550151910155565b60a081019392916000825b600282106140115750505060800152565b825180516001600160a01b0316825260209081015182820152600191604001930191019091614000565b5190611c0e82611571565b519063ffffffff8216820361045d57565b5190611c0e826116ca565b908161010091031261045d576140f060e06040519261408084611ba6565b61408981613917565b84526140976020820161403b565b60208501526140a860408201614046565b6040850152606081015160608501526140c36080820161403b565b60808501526140d460a08201613917565b60a08501526140e560c08201614057565b60c085015201614057565b60e082015290565b60408051631fc50ef560e31b815230600482015290816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015610b0557600091829161415a575b5081039081116126bc5790565b90506040813d60401161418c575b8161417560409383611bde565b81010312610d62576020908051925001513861414d565b3d9150614168565b9081602091031261045d575190565b801580156142a2575b611197576141c481600052600b602052604060002090565b60068101906141d4825460ff1690565b916005820154926141e481612be0565b6003811490811561428e575b5061428857805460ff19166004179055614261916119509061421185614e2f565b5082546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169161424d91849116836146c1565b61425b60028501600061111b565b906146c1565b7fec5ea23f72a00a2e477d714dc012986271cd3c96ad95c7fe5f629ff79847fd21600080a2565b50505050565b6004915061429b81612be0565b14386141f0565b50600a5481116141ac565b60005b600281106142bc575050565b600190602083519301928160020155016142b0565b604081019291611c0e9190611d82565b600061432d6105216143216142fe602095868151910151906151ae565b604051607f60f91b87820152600360f81b602182015292839160228301906148f5565b604051918280926148f5565b039060025afa15610b055760005190565b602081519101519060208110614352575090565b6000199060200360031b1b1690565b9081600052600760205260ff60406000205416159160005260086020526040600020548280614393575b610cb1579190565b50801561438b565b638b78c6d8600c523360005260016020600c205416156143b757565b638b78c6d8195433036143c657565b6382b429006000526004601cfd5b638b78c6d8600c523360005260026020600c205416156143b757565b600081158015614467575b61445857818152600b602052604081209160ff600684015416915061441f82612be0565b6001820361442c57505090565b637765da3560e01b60005260045261444690602490612c00565b61445260446001612c00565b60646000fd5b635df626e160e11b8152600490fd5b50600a5482116143fb565b6000811580156144d1575b61445857818152600b602052604081209160ff60068401541691506144a182612be0565b816144ab57505090565b637765da3560e01b6000526004526144c590602490612c00565b61445260446000612c00565b50600a54821161447d565b60008115801561453e575b61445857818152600b602052604081209160ff600684015416915061450b82612be0565b6002820361451857505090565b637765da3560e01b60005260045261453290602490612c00565b61445260446002612c00565b50600a5482116144e7565b9081602091031261045d5751611cc781611571565b7812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f22811082021561458f57670de0b6b3a7640000020490565b637c5f487d6000526004601cfd5b906001600160401b03611c0e9216806000526005602052604060002054614ca0565b916040519360605260405260601b602c526323b872dd60601b600c52602060006064601c82855af190816001600051141615614602575b50506000606052604052565b3b153d1710156146135738806145f6565b637939f4246000526004601cfd5b600260005414614632576002600055565b633ee5aeb560e01b60005260046000fd5b8181029161271081838504148315170215614662575050612710900490565b61271090600019818409848110850190039209908061271011156146b357828211900360fc1b910360041c177fbc01a36e2eb1c432ca57a786c226809d495182a9930be0ded288ce703afb7e910290565b63ae47f7026000526004601cfd5b919060145260345263a9059cbb60601b600052602060006044601082855af1908160016000511416156146f8575b50506000603452565b3b153d1710156147095738806146ef565b6390b8ec186000526004601cfd5b9080600019048211614733575b670de0b6b3a764000091020490565b80156147245763bac65e5b6000526004601cfd5b6004614753910161359b565b8051907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169060005b8381106147915750505050565b6001906147c26001600160a01b036147a98386613327565b51511660406147b88487613327565b51015190866146c1565b01614784565b9060208201906147f460208351604051809381926331a9108f60e11b8352600483019190602083019252565b03817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa60009181614896575b506148565783518351630967a7eb60e11b6000526001600160a01b0390911660045260245260446000fd5b925190926001600160a01b03918216929116829003614873575050565b51630967a7eb60e11b6000526001600160a01b0390911660045260245260446000fd5b6148b091925060203d602011611525576115188183611bde565b903861482b565b60018060a01b031680638b78c6d819547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3638b78c6d81955565b9081519160005b83811061490d575050016000815290565b80602080928401015181850152016148fc565b929161492f9094919484614f23565b61493b86929660600190565b8051969061496a6129af60408601998a519961495981519160200190565b518a519160208c019c8d51946151e5565b908115614a0b575b5080156149de575b6149d2576001600160801b03956149ca956149b061282c9680519061499f8160200190565b516040820151916060015192615322565b9590946149bf82519260200190565b519251935194615132565b915191161490565b50505050505050600090565b50614a066129af885185516149f38760200190565b5160408901519160608a015b51936152b9565b61497a565b614a2391506129af9051865185856149ff8a60200190565b38614972565b91906004614a4461090a856000526007602052604060002090565b1615614b775750614a7e614a62836000526007602052604060002090565b6004614a6f825460ff1690565b1860ff1660ff19825416179055565b610521614ab6614a98846000526008602052604060002090565b54926040519283916020830195869091604092825260208201520190565b519020614acd826000526008602052604060002090565b556004817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b15614b185750565b807fb26fe08e4e51c01e5cffff5f4887249599779aa0d4f8636ff4e7cd4831b495ed600080a27f0000000000000000000000000000000000000000000000000000000000000000614b665750565b600090815260096020526040812055565b60405190815260049291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c009080602081015b0390a3565b91906002614bca61090a856000526007602052604060002090565b1615614c695750614bf5614be8836000526007602052604060002090565b6002614a6f825460ff1690565b610521614c0f614a98846000526008602052604060002090565b519020614c26826000526008602052604060002090565b556002817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b60405190815260029291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c00908060208101614baa565b91906001614cbb61090a856000526007602052604060002090565b1615614d5a5750614ce6614cd9836000526007602052604060002090565b6001614a6f825460ff1690565b610521614d00614a98846000526008602052604060002090565b519020614d17826000526008602052604060002090565b556001817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b60405190815260019291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c00908060208101614baa565b638b78c6d8600c526000526020600c2090815490811618809155600c5160601c7f715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26600080a3565b805482101561333b5760005260206000200190600090565b80548015614e19576000190190614e078282614dd8565b8154906000199060031b1b1916905555565b634e487b7160e01b600052603160045260246000fd5b6000818152600d6020526040902054908115614ed0576000198201908282116126bc57600c546000198101939084116126bc578383600095614e8f9503614e95575b505050614e7e600c614df0565b600d90600052602052604060002090565b55600190565b614e7e614ec191614eb7614ead614ec795600c614dd8565b90549060031b1c90565b928391600c614dd8565b90613e2e565b55388080614e71565b5050600090565b607f60f91b8152600160f81b6001820152611cc79291614efa91600201906148f5565b906148f5565b614f0d90600193926148f5565b60f89190911b6001600160f81b03191681520190565b614f3d614f4f91614f3681519160200190565b51906151ae565b61052160405193849260208401614ed7565b60005b61010060ff821610614fa35760405162461bcd60e51b815260206004820152601860248201527f4e6f2076616c696420706f696e742077617320666f756e6400000000000000006044820152606490fd5b60206000614fbe604051614321816105218789888401614f00565b039060025afa15610b0557600051614fd581615353565b90614fe082826153b6565b614ff4575050614fef906132da565b614f52565b939092509050565b6150619192936150596150537f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b87f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179861505395615512565b91615599565b959094615512565b6401000003d01903926401000003d01984116126bc5761508a936401000003d01990069261544f565b9091565b615053615053936150619596979361505993615512565b916150539161508a93615512565b80600052600d6020526040600020541560001461512c57600c54600160401b811015611b865760018101600c556000600c5482101561333b57600c90527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c701819055600c5490600052600d602052604060002055600190565b50600090565b93614efa600097614efa61517260209b61516c6151989b6151666143219b6151606105219b614efa9f6151ae565b9b6151ae565b976151ae565b936151ae565b604051607f60f91b8d820152600160f91b602182015298899791959160228901906148f5565b039060025afa15610b0557600051806040515290565b9060011660020190816002116126bc576040519160ff60f81b9060f81b166020830152602182015260218152611cc7604182611bde565b9160ff91602094600161521a6151ff6000979a999a613b36565b70014551231950b75fc4402da1732fc9bebe19900693613b36565b70014551231950b75fc4402da1732fc9bebe1990069116151585146152b157601c925b60405194859460808601948370014551231950b75fc4402da1732fc9bebe1991098652168785015280604085015270014551231950b75fc4402da1732fc9bebe1991096060830152838052039060015afa15610b05576152a09060005192615420565b6001600160a01b0390811691161490565b601b9261523d565b92939260209260009260809290916001161561531a57601c915b60ff60405193868552168684015280604084015270014551231950b75fc4402da1732fc9bebe199109606082015282805260015afa15610b05576152a09060005192615420565b601b916152d3565b91926401000003d01903916401000003d01983116126bc5761508a936401000003d0199360009390859006926154b5565b6153899063400000f4600160fe1b03906401000003d01990816007816000840908906401000003d0199081818009900908615bef565b600281018082116126bc5760011661539e5790565b6401000003d019036401000003d01981116126bc5790565b80158015615410575b8015615408575b80156153f8575b614ed0576401000003d01990818180090960076401000003d0199108906401000003d0199080091490565b506401000003d0198210156153cd565b5081156153c6565b506401000003d0198110156153bf565b604051916020830191825260408301526040825261543f606083611bde565b905190206001600160a01b031690565b92909180840361549857506401000003d019908208615472575050600090600090565b61508a916000615489926401000003d01992615aa8565b905b6401000003d0199261569c565b61508a936154af936401000003d01993929161577e565b9061548b565b939493909290918083036154f8575083156154f357839083086154de5750505050600090600090565b61508a936154ed928492615aa8565b9161569c565b6132eb565b61508a95506154ed93859361577e565b81156154f3570490565b92909192600190801561558f57600094600194869392805b6155375750505050929190565b60018116615563575b90600061555a9260011c9485946401000003d01993615b1e565b9290929361552a565b936155809084848460009a61555a969c6401000003d01995615914565b90989097509094909150615540565b5050909190600190565b919291906000841515858161568b575b5080615683575b1561564d5760009490856401000003d0196001845b6155f45750505050506401000003d01984800991826401000003d0199109936401000003d01992839109900990565b61560285839a95969a615508565b9181936154f35761563e615629615644936401000003d0199086096401000003d019613b66565b87966401000003d019919008949a8094613356565b90613b66565b939291846155c5565b60405162461bcd60e51b815260206004820152600e60248201526d24b73b30b634b210373ab6b132b960911b6044820152606490fd5b5060016155b0565b6401000003d01914159050386155a9565b91939291841515838682615727575b50508061571e575b1561564d5760009483159081856001835b6156e157505050506154f357829081808780098092099509900990565b6156ee84839b959b615508565b9181936154f35761563e896157098161571695870982613b66565b60009708949b8094613356565b9291836156c4565b508215156156b3565b1415905083386156ab565b1561573957565b60405162461bcd60e51b815260206004820152601e60248201527f557365206a6163446f75626c652066756e6374696f6e20696e737465616400006044820152606490fd5b939190949284158061590c575b615900578115806158f8575b6158ed576157a3613c18565b9583156154f3578380938160018009808a529882808b6001099460208301958652604083018c81529a82808e60010991606086019283526157e46080611c2f565b9d5190098c5251900960208a01525190096040870152519009606084015282519360408401948551148015906158db575b61581e90615732565b81615827613c18565b9551615834865183613b66565b900885528160608501516158d08288818060208b0195615855875183613b66565b900899602083019a8b5281808c8180808089518a5190099360408a019485526158858286518c5190099a60600190565b998a52518009615896895183613b66565b90086158ac828088518651900960020983613b66565b90089d519351905190096158c08d83613b66565b9008900993519051900983613b66565b900894510991929190565b50602084015160608501511415615815565b505050909190600190565b508015615797565b90945092506001919050565b50851561578b565b9694969593909195801580615aa0575b615a9457831580615a8c575b615a815761593c613c18565b9285156154f35788948694858093818c800983528183518d0995602084019687528280604086019b81818009808e529009916060860192835261597f6080611c2f565b9b5190098a52519009602088015251900960408501525190096060820152818151956159ab8360400190565b96875114801590615a6f575b6159c090615732565b816159c9613c18565b97516159d6855183613b66565b90088752816060840151615a62828a818060208a01956159f7875183613b66565b90089860208301998a5281808b8180808089518a5190099360408a01948552615a278286518c5190099a60600190565b998a52518009615a38895183613b66565b9008615a4e828088518651900960020983613b66565b90089c519351905190096158c08c83613b66565b9008965192969509900990565b506020830151606084015114156159b7565b935050945050929190565b508115615930565b50959450509050929190565b508215615924565b93919392909281156154f3578180858009918180808060018009998180808988096004099b80099009928009600309088286800883038381116126bc5783908183800908808403928484116126bc57848091800960080984038481116126bc578460019381809681959b08900908940960020990565b9093919492948015615b9b5782156154f357828086800992818080808680099a8180808a88096004099c8009900992800960030908918387800884038481116126bc578490818580090890818503908582116126bc5785809180096008098503908582116126bc5785948580949281939b08900908940960020990565b909450919050565b15615baa57565b60405162461bcd60e51b815260206004820152601e60248201527f456c6c697074696343757276653a206d6f64756c7573206973207a65726f00006044820152606490fd5b615bf96001615ba3565b8015614ed0578115615c9057600191600160ff1b9190825b615c1b5750505090565b9091926401000003d019908483161515840a906401000003d019908009096401000003d01990600185901c83161515840a9082908009096401000003d01990600285901c83161515840a9082908009096401000003d01990600385901c83161515840a9082908009099260041c919082615c11565b505060019056fea26469706673582212208b4e68c1c777d955336be78b0e249721a20666142fded4ca286024a63f85fc4f64736f6c634300081c00338be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01@`@R4a\x04\xDAW`@Qab\x178\x81\x90\x03\x90`\x1F\x82\x01`\x1F\x19\x16\x83\x01\x90`\x01`\x01`@\x1B\x03\x82\x11\x84\x83\x10\x17a\x04\xDFW\x82\x91`@R\x839\x81\x01\x90a\x01\0\x81\x83\x03\x12a\x04\xDAWa\0P\x81a\x04\xF5V[\x90a\0]` \x82\x01a\x04\xF5V[\x91a\0j`@\x83\x01a\x04\xF5V[\x91a\0w``\x82\x01a\x04\xF5V[\x94a\0\x84`\x80\x83\x01a\x04\xF5V[\x90\x80`\xBF\x84\x01\x12\x15a\x04\xDAW`@\x80Q\x93\x90\x84\x01`\x01`\x01`@\x1B\x03\x81\x11\x85\x82\x10\x17a\x04\xDFW`@R\x83\x90`\xE0\x81\x01\x92\x83\x11a\x04\xDAW`\xA0\x01\x90[\x82\x82\x10a\x04\xCAWPPa\0\xD1\x90a\x04\xF5V[`\x01`\0\x90\x81U3c\x8Bx\xC6\xD8\x19\x81\x90U\x91\x97\x91\x95\x90\x86\x90`\0\x80Q` aa\xD7\x839\x81Q\x91R\x81\x80\xA3c\x8Bx\xC6\xD8`\x0CR3`\0R` `\x0C `\x03\x81T\x17\x80\x91U`\x0CQ``\x1C`\0\x80Q` aa\xF7\x839\x81Q\x91R`\0\x80\xA3`\x01\x80Tb\xFF\xFF\xFF\x19\x16b\x01\x01\x01\x17\x90\x81\x90U\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x04\x85W`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x04@W`\xFF\x81`\x08\x1C\x16a\x03\xEDW[`\x10\x1C`\xFF\x16a\x03\x8DW[`\xC0R`\xA0R`\x01`\x01`\xA0\x1B\x03\x16`\xE0R`\0[`\x02\x81\x10a\x03xWPP`\0`\x80R`\xC8`\x0FU`\x10\x80T`\xFF\x19\x16`\x01\x17\x90U`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15\x80\x15a\x03gW[\x80\x15a\x03VW[a\x03EW\x80c\x8Bx\xC6\xD8\x19U`\0`\0\x80Q` aa\xD7\x839\x81Q\x91R\x81\x80\xA3c\x8Bx\xC6\xD8`\x0CR3`\0R` `\x0C `\x01\x81T\x17\x80\x91U`\x0CQ``\x1C`\0\x80Q` aa\xF7\x839\x81Q\x91R`\0\x80\xA3a\x01 R`\x01`\x01`\xA0\x1B\x03\x16a\x01\0R`\x10\x80Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x92\x90\x92\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x91\x90\x91\x17\x90U`@Qa\\\xCD\x90\x81a\x05\n\x829`\x80Q\x81\x81\x81a\t\x18\x01RaK@\x01R`\xA0Q\x81\x81\x81a\x0Be\x01R\x81\x81a\x11\xC9\x01R\x81\x81a\"v\x01Ra4\x87\x01R`\xC0Q\x81\x81\x81a\x0B\xA7\x01R\x81\x81a\x15\xAF\x01R\x81\x81a\"\xC0\x01R\x81\x81a'}\x01Ra4\xB9\x01R`\xE0Q\x81\x81\x81a\n^\x01R\x81\x81a\x0C\xFB\x01R\x81\x81a\x0E\xE0\x01R\x81\x81a#\x90\x01R\x81\x81a(\x8F\x01R\x81\x81a/0\x01R\x81\x81a/\xCB\x01R\x81\x81a56\x01R\x81\x81a8\x8A\x01RaA\x13\x01Ra\x01\0Q\x81\x81\x81a\x12\x0E\x01R\x81\x81a\x17M\x01R\x81\x81a\x18\xD3\x01R\x81\x81a$T\x01R\x81\x81a.2\x01R\x81\x81a<\xC7\x01R\x81\x81aB\x1E\x01RaGX\x01Ra\x01 Q\x81\x81\x81a\x0E\x90\x01RaG\xF8\x01R\xF3[c\xB4\xFA?\xB3`\xE0\x1B`\0R`\x04`\0\xFD[P`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x01\xC7V[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x01\xC0V[`\x01\x90` \x83Q\x93\x01\x92\x81`\x02\x01U\x01a\x01\x8CV[\x83Q\x15\x15\x80a\x03\xE0W[a\x01wW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FInvalid SAV public key\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[P` \x84\x01Q\x15\x15a\x03\x97V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x01lW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FInvalid Randomizer address\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FInvalid Pyth entropy\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FInvalid Pyth provider\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[\x81Q\x81R` \x91\x82\x01\x91\x01a\0\xBFV[`\0\x80\xFD[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[Q\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x04\xDAWV\xFE`\x80`@R`\x046\x10\x15a\0\x12W`\0\x80\xFD[`\x005`\xE0\x1C\x80c\x02\x89\x95\xCD\x14a\x04MW\x80c\x05\xA85\xBF\x14a\x04HW\x80c\x0B\x12\xE4\xBA\x14a\x04CW\x80c\x0E\xBB\xCF\xB5\x14a\x04>W\x80c\x16/\xC3\x01\x14a\x049W\x80c\x18:On\x14a\x044W\x80c\x19<\xCBa\x14a\x03\xDAW\x80c\x1C\x10\x89?\x14a\x04/W\x80c\x1C\xD6M\xF4\x14a\x04*W\x80c\x1EFC\t\x14a\x04%W\x80c\x1F\xDA\x9A\x02\x14a\x04 W\x80c!\xDD\x95v\x14a\x04\x1BW\x80c#\xA8\xC4\xBA\x14a\x04\x16W\x80c%J9\xFE\x14a\x04\x11W\x80c%i)b\x14a\x04\x0CW\x80c,*\xABA\x14a\x03\xEEW\x80c-\xE9H\x07\x14a\x04\x07W\x80c1\x05,0\x14a\x04\x02W\x80c3\xE7\x97z\x14a\x03\xFDW\x80c63\x93\x88\x14a\x03\xF8W\x80c9v\x06\xC0\x14a\x03\xF3W\x80c;f\xF1\xC0\x14a\x03\xEEW\x80c=\xB12\xB1\x14a\x03\xE9W\x80cC\\\x02\x98\x14a\x03\xE4W\x80cCl\xFB\x9B\x14a\x03\xDFW\x80cD\x19\xDF:\x14a\x03\xDAW\x80cJN\xE7\xB1\x14a\x03\xD5W\x80cP\xF1\xC5Z\x14a\x03\xD0W\x80cQNb\xFC\x14a\x03\xCBW\x80cR\xA5\xF1\xF8\x14a\x03\xC6W\x80cT\xD1\xF1=\x14a\x03\xC1W\x80c[\xBE\x06\x94\x14a\x03\xBCW\x80ce\x83^Z\x14a\x03\xB7W\x80cg\xF1\x88\xB7\x14a\x03\xB2W\x80cjA\x1B\x0C\x14a\x03\xADW\x80coY#/\x14a\x03\xA8W\x80cqP\x18\xA6\x14a\x03\xA3W\x80c\x82(\xB1\xE2\x14a\x03\x9EW\x80c\x8A\x95\xE6\xDF\x14a\x03\x99W\x80c\x8D>DZ\x14a\x03\x94W\x80c\x8D\xA5\xCB[\x14a\x03\x8FW\x80c\x8E\xAAI]\x14a\x03\x8AW\x80c\x91q\xE5X\x14a\x03\x85W\x80c\x94\xC5\x93\x14\x14a\x03\x80W\x80c\x94\xE7\xEC\xFB\x14a\x03{W\x80c\x98\xE5\x03\n\x14a\x03vW\x80c\x9D\xCC!\xBD\x14a\x03qW\x80c\xA1\xBD\xC6\x08\x14a\x03lW\x80c\xAA\xB5\x86\xC2\x14a\x03gW\x80c\xAC\xE3\xA1S\x14a\x03bW\x80c\xAF\xB2\x18\xF5\x14a\x03]W\x80c\xB5\x16\x10\\\x14a\x03XW\x80c\xB6\xF9\0T\x14a\x03SW\x80c\xBA\xD0\x18\x99\x14a\x03NW\x80c\xBC?\x1F\n\x14a\x03IW\x80c\xC0\xA7yR\x14a\x03DW\x80c\xD0\xBE\x0B\x9C\x14a\x03?W\x80c\xD9\xFB:\xBA\x14a\x03:W\x80c\xDE\x85\x847\x14a\x035W\x80c\xE1\xFA\x8E\x84\x14a\x030W\x80c\xE2C\xAD\xBF\x14a\x03+W\x80c\xEB\xE9<\xAF\x14a\x03&W\x80c\xEC\xC0D\x85\x14a\x03!W\x80c\xF0N(>\x14a\x03\x1CW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x17W\x80c\xF7\xD2Fs\x14a\x03\x12W\x80c\xF9\x81\x18\xD5\x14a\x03\rWc\xFE\xE8\x1C\xF4\x14a\x03\x08W`\0\x80\xFD[a1\x80V[a1TV[a0\xF2V[a0\xB2V[a0^V[a/\x87V[a/\x17V[a.\xFBV[a-\xF9V[a-\xCDV[a,\xFEV[a+\x11V[a*\xD6V[a(\xBEV[a(yV[a(JV[a'\xACV[a'gV[a&\xC1V[a%\xEEV[a%\x92V[a$%V[a#TV[a#8V[a\"\x07V[a!^V[a!8V[a!\x0BV[a \x88V[a +V[a\x1F\xCFV[a\x1F\x83V[a\x1E\xF1V[a\x1E\xC4V[a\x1D\xE7V[a\x17\xEDV[a\x16\xD4V[a\x16\x82V[a\x15\x82V[a\x15,V[a\x13\xD6V[a\x13\xAAV[a\r\x81V[a\x13\x84V[a\x13KV[a\x12\xB0V[a\x0F\xEBV[a\x12=V[a\x11\xF8V[a\x11\xB3V[a\x10\xABV[a\x10\x11V[a\x0F\x9FV[a\x0F\x81V[a\x0FKV[a\x0E\xBFV[a\x0EzV[a\x0E\\V[a\x0E\x16V[a\r\xAEV[a\rgV[a\x0C\xDAV[a\x08qV[a\x08EV[a\x04\x88V[a\x04bV[`\0\x91\x03\x12a\x04]WV[`\0\x80\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` a\x04}a1\xB7V[`\xFF`@Q\x91\x16\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x04\xA4aC\x9BV[a\x04\xAD\x81aC\xF0V[`\x06\x81\x01\x80T`\xFF\x19\x16`\x02\x17\x90U\x90`\0\x91\x82a\x04\xCA\x83aCaV[\x91\x90\x91\x15a\x086Wa\x04\xDAa2jV[\x91\x85[`\xFF\x81\x16\x91`\x05\x83\x10\x80a\x08)W[\x80a\x08\x1CW[\x15a\x06\xB7W`@\x80Q` \x81\x01\x92\x83R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x91\x81\x01\x91\x90\x91Ra\x05/\x81`A\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a\x1B\xDEV[Q\x90 \x91a\x05Ia\x05D`\x06\x85\x06[`\xFF\x16\x90V[a3\x01V[\x92a\x05!a\x05\x82a\x05Y\x85a3\x01V[`@\x80Q` \x81\x01\x95\x86R`\xF8\x92\x90\x92\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x82\x01R\x91\x82\x90`A\x82\x01\x90V[Q\x90 \x92a\x05\x95a\x05D`\x06\x86\x06a\x05>V[\x98[`\xFF\x8A\x16`\xFF\x83\x16\x14a\x065W`\xFF\x8A\x16`\xFF\x83\x16\x11\x90\x81`\0\x14a\x06\x14W\x91a\x05\xF8a\x06\x0F\x95\x94\x92a\x05\xEFa\x05\xCFa\x06\t\x96a2\xDAV[\x9D[a\x05\xE5a\x05\xDCa\x1B\xFFV[`\xFF\x90\x96\x16\x86RV[`\xFF\x16` \x85\x01RV[\x15\x15`@\x83\x01RV[a\x06\x02\x82\x89a3'V[R\x86a3'V[Pa2\xDAV[a\x04\xDDV[\x99\x95\x91a\x05\xF8a\x06\x0F\x95\x94\x92a\x05\xEFa\x06/a\x06\t\x96a2\xDAV[\x99a\x05\xD1V[\x98PP\x91`@Qa\x06a\x81a\x05!` \x82\x01\x94\x85`&\x91\x81Re\x1C\x99\\\x9B\xDB\x1B`\xD2\x1B` \x82\x01R\x01\x90V[Q\x90 \x91a\x06ta\x05D`\x06\x85\x06a\x05>V[\x92`@Qa\x06\x9E\x81a\x05!` \x82\x01\x94\x85`'\x91\x81Rf92\xB97\xB66\x19`\xC9\x1B` \x82\x01R\x01\x90V[Q\x90 \x92a\x06\xB1a\x05D`\x06\x86\x06a\x05>V[\x98a\x05\x97V[PPP\x93\x91`\xFFa\x06\xC8\x86\x85a3\x13V[\x16\x93a\x06\xD3\x85a2\x8FV[\x93`\0[`\xFF\x81\x16\x87\x81\x10\x15a\x07\x10W`\xFF\x91a\x07\x08\x82a\x06\xF6`\x01\x94\x8Aa3'V[Qa\x07\x01\x82\x8Ca3'V[R\x89a3'V[P\x01\x16a\x06\xD7V[PPa\x07\xD3`\x01a\x07\x85`\x02\x93`\xFF\x80\x8Ca\x07.\x8C`\x07\x8C\x01a3mV[`\x08\x8A\x81\x01\x80T`\xFF\x87\x16a\xFF\xFF\x19\x90\x91\x16\x17\x91\x83\x90\x1Ba\xFF\0\x16\x91\x90\x91\x17\x90U\x16\x91\x16\x11\x95`\0\x96a\x07n\x84\x83\x01T`\0R`\x0E` R`@`\0 \x90V[a\x07x\x81Ta4IV[\x90Ua\x07\x98\x84`\x02\x84\x01`\0[P\x01T`\0R`\x0E` R`@`\0 \x90V[a\x07\xA2\x81Ta4IV[\x90U\x80\x15a\x08\x0EW\x83a\x07\xBA\x81a\x07\x85\x8B[\x86a45V[\x01a\x07\xC5\x81Ta4IV[\x90U\x15a\x08\x07W\x82\x90a45V[\x01a\x07\xDE\x81Ta4IV[\x90U\x7F1T9a\xBA\xD6\xE1\xB8\x86\xFEK<\x06\r=\x97\xC2\x1F\xBC\x80\xE6:\xB2.\x9E\xEAe\xD9\xD2\xDC|w\x82\x80\xA2\x80\xF3[\x86\x90a45V[\x83a\x07\xBA\x81a\x07\x85\x81a\x07\xB4V[P`\x03`\xFF\x85\x16\x10a\x04\xF2V[P`\x03`\xFF\x89\x16\x10a\x04\xECV[c2\x92n\xDD`\xE0\x1B\x85R`\x04\x85\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` a\x08`a4pV[`\x01`\x01`\x80\x1B\x03`@Q\x91\x16\x81R\xF3[` 6`\x03\x19\x01\x12a\x04]W`\x045a\x08\x88aC\x9BV[a\x08\x91\x81aDrV[a\x08\x99a8+V[PP\x804\x10a\x0C\xC2WP`\x06\x81\x01\x80T`\xFF\x19\x16`\x01\x17\x90Ua\x08\xDB\x90`\n\x81\x01T\x81T`\x02\x90\x92\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x90\x83\x16\x18\x90\x91\x16\x83\x18\x18\x90V[a\x08\xE3aC\x9BV[a\x08\xEBaF!V[\x81\x15a\x0C\xB1W`\xFFa\t\x11a\t\n\x84`\0R`\x07` R`@`\0 \x90V[T`\xFF\x16\x90V[\x16a\x0C\x9BW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x0C\x80W[4\x90a\tFa8+V[\x92\x91\x804\x10a\x0ChWP`\x01T`\xFF\x16a\x0B\x19W[PP`\x01T`\x08\x1C`\xFF\x16a\n\x0CW[PP`\x01T`\x10\x1C`\xFF\x16a\t\xACW[a\t\x85`\x01`\0UV[\x7FP\xAD\x08\xF5\x8A'\xF2\x85\x1D~:\x1B:jF\xB2\x90\xF2\xCEg~\x99d-0\xFFc\x97!\xE7w\x90`\0\x80\xA2\0[a\t\xDFa\t\xC3\x82`\0R`\x07` R`@`\0 \x90V[`\x04a\t\xD0\x82T`\xFF\x16\x90V[\x17`\xFF\x16`\xFF\x19\x82T\x16\x17\x90UV[`\x04\x81\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA3a\t{V[a\n0a\n#\x84`\0R`\x07` R`@`\0 \x90V[`\x02a\t\xD0\x82T`\xFF\x16\x90V[a\x0B\nW[P`@Qc\xD8E\xA4\xB3`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R` \x81`$\x81`\0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xF1\x90\x81\x15a\x0B\x05W\x82\x91a\n\xA6\x91`\0\x91a\n\xD6W[P`\0R`\x06` R`@`\0 \x90V[U`\x02\x81\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA38\x80a\tkV[a\n\xF8\x91P` =` \x11a\n\xFEW[a\n\xF0\x81\x83a\x1B\xDEV[\x81\x01\x90aA\x94V[8a\n\x95V[P=a\n\xE6V[a4dV[a\x0B\x13\x90a5,V[8a\n5V[a\x0B\xA2\x92\x93P`\x01`\x01`\x80\x1B\x03` \x91a\x0BNa\x0BA\x88`\0R`\x07` R`@`\0 \x90V[`\x01a\t\xD0\x82T`\xFF\x16\x90V[`@Qc\x19\xCB\x82_`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x04\x82\x01R`$\x81\x01\x94\x90\x94R\x92\x93\x92\x16\x91\x83\x90\x81\x90`D\x82\x01\x90V[\x03\x81\x84\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x80\x15a\x0B\x05Wa\x0C\x02\x85\x91a\x0C\t\x94`\0\x91a\x0C9W[P`\x01`\x01`@\x1B\x03\x16`\0R`\x05` R`@`\0 \x90V[U4a;fV[\x90`\x01\x83\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA38\x80a\t[V[a\x0C[\x91P` =` \x11a\x0CaW[a\x0CS\x81\x83a\x1B\xDEV[\x81\x01\x90aEIV[8a\x0B\xE8V[P=a\x0CIV[c\xA4X&\x1B`\xE0\x1B`\0R4`\x04R`$R`D`\0\xFD[\x80a\x0C\x95\x83`\0R`\t` R`@`\0 \x90V[Ua\t<V[cj\xE0\tg`\xE0\x1B`\0R`\x04\x82\x90R`$`\0\xFD[cA\xAB\xC8\x01`\xE0\x1B`\0R`\x04`\0\xFD[c\xA4X&\x1B`\xE0\x1B`\0R4`\x04R`$R`D`\0\xFD[4a\x04]W`\0` 6`\x03\x19\x01\x12a\rdW`\x045a\x0C\xF8aC\x9BV[\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\rbW`$`@Q\x80\x94\x81\x93cO\xFD.C`\xE0\x1B\x83R0`\x04\x84\x01RZ\xF1\x80\x15a\x0B\x05W\x82\x90a\rTW\x80\xF3[a\r]\x91a\x1B\xDEV[8\x81\x80\xF3[P[\x80\xFD[` 6`\x03\x19\x01\x12a\x04]Wa\r\x7F`\x0453aM\x91V[\0[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\x03\x81R\xF3[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x04]WV[`@6`\x03\x19\x01\x12a\x04]W`\x045a\r\xC6\x81a\r\x9DV[`$5\x90a\r\xD2aC\xB7V[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C \x90\x81T\x17\x80\x91U`\x0CQ``\x1C\x7FqZ\xD5\xCEa\xFC\x95\x95\xC7\xB4\x15(\x9DY\xCF ?#\xA9O\xA0o\x04\xAF~H\x9A\nv\xE1\xFE&`\0\x80\xA3\0[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W` a\x0ER`\x045a\x0E8\x81a\r\x9DV[`$5\x91\x82\x91c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[\x16\x14`@Q\x90\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\x04T`@Q\x90\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W`\0` 6`\x03\x19\x01\x12a\rdW\x80`\x045a\x0E\xDEaC\x9BV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90\x81;\x15a\x0FGW`@Qc$e\xF8\xF5`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x91\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x0B\x05W\x82\x90a\rTW\x80\xF3[PP\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x80a\x0Fi`\x045a6\x18V[\x91`@Q\x93\x84R` \x84\x01R`@\x83\x01R``\x82\x01R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\x0FT`@Q\x90\x81R\xF3[`\x006`\x03\x19\x01\x12a\x04]Wc8\x9Au\xE1`\x0CR3`\0Rb\x02\xA3\0B\x01` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D`\0\x80\xA2\0[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W` a\x10\t`\x045a7\x93V[`@Q\x90\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W` a\x10\t`\x045a\x103\x81a\r\x9DV[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90`\0[\x81\x81\x10a\x10kWPPP\x90V[\x90\x91\x92` a\x10\xA1`\x01\x92\x86Q\x90`@``\x92`\x01\x80`\xA0\x1B\x03\x81Q\x16\x83R` \x81\x01Q\x15\x15` \x84\x01R\x01Q`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a\x10^V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045\x80\x15\x80\x15a\x11\xA8W[a\x11\x97Wa\x10\xE2`\x04\x91`\0R`\x0B` R`@`\0 \x90V[\x01\x80Ta\x10\xEE\x81a7'V[\x91`\0[\x82\x81\x10a\x11\x0BW`@Q\x80a\x11\x07\x86\x82a\x10GV[\x03\x90\xF3[\x80a\x11)a\x11\x1B`\x01\x93\x85a7wV[PT`\x01`\x01`\xA0\x1B\x03\x16\x90V[a\x11Aa\x116\x83\x86a7wV[PT`\xA0\x1C`\xFF\x16\x90V[a\x11v\x84a\x11O\x85\x88a7wV[P\x01T\x91a\x11ma\x11^a\x1B\xFFV[`\x01`\x01`\xA0\x1B\x03\x90\x95\x16\x85RV[\x15\x15` \x84\x01RV[`@\x82\x01Ra\x11\x85\x82\x87a3'V[Ra\x11\x90\x81\x86a3'V[P\x01a\x10\xF2V[c]\xF6&\xE1`\xE1\x1B`\0R`\x04`\0\xFD[P`\nT\x81\x11a\x10\xC8V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x12Ya2'V[P`\0R`\x0E` R`@`\0 `\x02`@Q\x91a\x12v\x83a\x1BkV[\x80T\x83R`\x01\x81\x01T` \x84\x01R\x01T`@\x82\x01R`@Q\x80\x91`@``\x83\x01\x91\x80Q\x84R` \x81\x01Q` \x85\x01R\x01Q`@\x83\x01R\x03\x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]Wa\x12\xC9aC\xB7V[G\x80\x15a\x13\x0EW`\0\x80\x80\x80a\r\x7F\x943Z\xF1=\x15a\x13\tW=a\x12\xEC\x81a\x1C\xE0V[\x90a\x12\xFA`@Q\x92\x83a\x1B\xDEV[\x81R`\0` =\x92\x01>a7\xDFV[a7\xDFV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01Rt'7\x90\"\xAA$\x17\xA2&\xAA\x10:7\x9092\xB1\xB7\xBB2\xB9`Y\x1B`D\x82\x01R`d\x90\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W```\x01`\x01`\x80\x1B\x03a\x13na8+V[\x91\x92\x90`@Q\x93\x84R\x16` \x83\x01R`@\x82\x01R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T`\x08\x1C\x16`@Q\x90\x15\x15\x81R\xF3[`@6`\x03\x19\x01\x12a\x04]Wa\r\x7F`\x045a\x13\xC5\x81a\r\x9DV[`$5\x90a\x13\xD1aC\xB7V[aM\x91V[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W`\x045a\x13\xF3\x81a\r\x9DV[`$5\x90a\x13\xFFaC\xB7V[`@Qc1\xA9\x10\x8F`\xE1\x1B\x81R`\x04\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x91\x90` \x81`$\x81\x86Z\xFA\x90\x81a\x14\xFFW[Pa\x14\xA7WP\x7F\xB3\x98\xCA#[>\xFF/g\xE7'\x07$e\r\x13\xE4|\xD5\xF9\xDA\xC1;\x91\x87\xED\x81\xB1'\xCE$\xC7`@Q\x80a\x14\xA2\x81`\x80\x90` \x81R`!` \x82\x01R\x7FNot an ERC721 or invalid token I`@\x82\x01R`\x11`\xFA\x1B``\x82\x01R\x01\x90V[\x03\x90\xA2\0[\x90\x80;\x15a\x04]W`@Qc!B\x17\x07`\xE1\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x92\x90\x92R`\0\x90\x82\x90`d\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x0B\x05Wa\x14\xEAW\0[\x80a\x14\xF9`\0a\r\x7F\x93a\x1B\xDEV[\x80a\x04RV[a\x15 \x90` =` \x11a\x15%W[a\x15\x18\x81\x83a\x1B\xDEV[\x81\x01\x90a9\"V[a\x141V[P=a\x15\x0EV[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W` `\x045a\x15K\x81a\r\x9DV[a\x15f`$5\x91c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[\x16\x15\x15`@Q\x90\x81R\xF3[`\x01`\x01`@\x1B\x03\x81\x16\x03a\x04]WV[4a\x04]W``6`\x03\x19\x01\x12a\x04]W`\x045a\x15\x9F\x81a\x15qV[a\x15\xAA`$5a\r\x9DV[`D5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\x16=W3\x03a\x15\xECWa\r\x7F\x91aE\x9DV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`#`$\x82\x01R\x7FOnly Entropy can call this funct`D\x82\x01Rb4\xB7\xB7`\xE9\x1B`d\x82\x01R`\x84\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FEntropy address not set\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`\x006`\x03\x19\x01\x12a\x04]Wc8\x9Au\xE1`\x0CR3`\0R`\0` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92`\0\x80\xA2\0[\x80\x15\x15\x03a\x04]WV[4a\x04]W`\x806`\x03\x19\x01\x12a\x04]W`$5`\x045a\x16\xF4\x82a\r\x9DV[`D5\x90a\x17\x01\x82a\x16\xCAV[`d5\x91a\x17\raC\x9BV[a\x17\x16\x82aDrV[\x83\x15a\x17\xDCW\x7FJ\xF7\x1B\x02\x1Ey\x9Cb\xC1X\xBDTcl\xA8\xDA/\xA2a\x15\xA2\x1A-\xC6\xEF\xE4\x86\xEC\x10O\xD1_\x91a\x17\xD7\x91`\t\x90a\x17z\x870\x8A\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16aE\xBFV[a\x17\xAC`@Qa\x17\x89\x81a\x1BkV[`\x01`\x01`\xA0\x1B\x03\x8A\x16\x81R\x84\x15\x15` \x82\x01R\x88`@\x82\x01R`\x04\x83\x01a9uV[\x01a\x17\xB8\x86\x82Ta4WV[\x90U`@Q\x94\x85R\x15\x15\x94`\x01`\x01`\xA0\x1B\x03\x16\x93\x90\x81\x90` \x82\x01\x90V[\x03\x90\xA4\0[c\x16)\x08\xE3`\xE1\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x18\taF!V[a\x18\x11aC\x9BV[a\x18\"a\x18\x1D\x82aD\xDCV[a:\x90V[\x90a\x181`\xA0\x83\x01Q`\xFF\x16\x90V[`\xFFa\x18Da\x05>`\xC0\x86\x01Q`\xFF\x16\x90V[\x91\x16\x11`\0\x90`\0\x14a\x1BPWP`\x01[a\x18b`@\x84\x01Qa3@V[\x92`\0\x80\x94`\xE0\x83\x01Q\x95a\x18v\x86a6\x18V[\x90\x91\x8A\x15\x15\x93\x84a\x1BFW[P\x83a\x1B<W[P\x87\x15a\x1B4WP\x90[`\x10T`\xFF\x16a\x1A\xEAW[a\x18\xC5`\x06a\x18\xB7\x8A`\0R`\x0B` R`@`\0 \x90V[\x01\x80T`\xFF\x19\x16`\x03\x17\x90UV[a\x18\xCE\x88aN/V[P\x85Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x94a\x19.\x91a\x19(\x90a\x19\x1A\x90\x8B\x15a\x1A\xE1W`\xFF`\0[\x16\x90a;sV[QQ`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x86aF\xC1V[a\x1AWWP\x85\x96Pa\x19Ua\x19P`\x80\x96\x97`\0R`\x0B` R`@`\0 \x90V[aGGV[`\x10T`\xFF\x81\x16a\x1A.W[PPPP\x01\x80QQ`\xFF\x16\x90a\x19ua;\x84V[\x93`\xFF`\0\x93\x16\x92[`\xFF\x81\x16\x84\x81\x10\x15a\x19\xB8W`\xFF\x91a\x19\xB0\x82a\x19\x9E`\x01\x94\x88Qa3'V[Qa\x19\xA9\x82\x8Ca;\x9DV[R\x89a;\x9DV[P\x01\x16a\x19~V[\x86\x83\x87\x15a\x1A\x04W\x7F\x8E\xF0\x1D\xE7HU\\\xD1\xD5C\x1De=\xAB\x86C*\x1D}u\tf!\xDE\xCAznKAM\xE66`\xFF`\0[a\x19\xF7`@Q\x92\x83\x92\x16\x95\x82a;\xAEV[\x03\x90\xA3a\r\x7F`\x01`\0UV[\x7F\x8E\xF0\x1D\xE7HU\\\xD1\xD5C\x1De=\xAB\x86C*\x1D}u\tf!\xDE\xCAznKAM\xE66`\xFF`\x01a\x19\xE6V[a\x1AN\x93a\x1AH\x91`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16\x92a4WV[\x91aF\xC1V[8\x80\x80\x80a\x19aV[` \x85\x01Q\x80Q\x91`\0[\x83\x81\x10a\x1AxWPPPP`\x80\x94\x95\x96Pa\x19UV[\x80a\x1A\x92` a\x1A\x8A`\x01\x94\x87a3'V[Q\x01Q\x15\x15\x90V[\x8A\x15\x15\x90\x15\x15\x03a\x1A\xA4W[\x01a\x1AbV[a\x1A\xDCa\x1A\xC9\x8Da\x1A\xC3\x86`@a\x1A\xBB\x87\x8Ba3'V[Q\x01QaE^V[\x90aG\x17V[a\x1A\xD6a\x19\x1A\x84\x88a3'V[\x89aF\xC1V[a\x1A\x9EV[`\xFF`\x01a\x19\x13V[\x97\x92\x91P\x92P`\x0FT\x92a\x1A\xFE\x84\x83aFCV[\x93\x88\x15a\x1B)Wa\x1B\x12a\x1B#\x91\x85aFCV[a\x1B\x1D\x86\x82\x95a;fV[\x94a;fV[\x97a\x18\x9EV[Pa\x1B#`\0a\x1B\x12V[\x90P\x90a\x18\x93V[\x15\x15\x92P8a\x18\x89V[\x15\x15\x93P8a\x18\x82V[a\x18UV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x1BUV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x01\0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x01 \x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[`@Q\x90a\x1C\x0E``\x83a\x1B\xDEV[V[`@Q\x90a\x1C\x0Ea\x01 \x83a\x1B\xDEV[`@Q\x90a\x1C\x0E`@\x83a\x1B\xDEV[\x90a\x1C\x0E`@Q\x92\x83a\x1B\xDEV[\x91\x90`@Q\x92a\x1CN`\x80\x85a\x1B\xDEV[\x83\x90`\x80\x81\x01\x92\x83\x11a\x04]W\x90[\x82\x82\x10a\x1CiWPPPV[\x815\x81R` \x91\x82\x01\x91\x01a\x1C]V[\x91\x90`@\x80Q\x93a\x1C\x8A\x82\x86a\x1B\xDEV[\x84\x91\x81\x01\x92\x83\x11a\x04]W\x90[\x82\x82\x10a\x1C\xA3WPPPV[\x815\x81R` \x91\x82\x01\x91\x01a\x1C\x97V[\x80`\x83\x12\x15a\x04]Wa\x1C\xC7\x90`da\x1C=V[\x90V[\x80a\x01C\x12\x15a\x04]Wa\x1C\xC7\x90a\x01$a\x1C=V[`\x01`\x01`@\x1B\x03\x81\x11a\x1B\x86W`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x81`\x1F\x82\x01\x12\x15a\x04]W\x805\x90a\x1D\x12\x82a\x1C\xE0V[\x92a\x1D `@Q\x94\x85a\x1B\xDEV[\x82\x84R` \x83\x83\x01\x01\x11a\x04]W\x81`\0\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90`\xA0`\x03\x19\x83\x01\x12a\x04]W\x81`#\x12\x15a\x04]Wa\x1Dc\x82`\x04a\x1C=V[\x91`\x845\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04]Wa\x1C\xC7\x91`\x04\x01a\x1C\xFBV[\x90`\0\x90[`\x02\x82\x10a\x1D\x94WPPPV[` \x80`\x01\x92\x85Q\x81R\x01\x93\x01\x91\x01\x90\x91a\x1D\x87V[`@\x90\x93\x92\x91\x93a\x1D\xBF\x81`\xC0\x81\x01\x96a\x1D\x82V[\x01`\0\x90[`\x04\x82\x10a\x1D\xD1WPPPV[` \x80`\x01\x92\x85Q\x81R\x01\x93\x01\x91\x01\x90\x91a\x1D\xC4V[4a\x04]Wa\x1D\xF56a\x1DBV[\x90a\x11\x07`@\x80\x80Qa\x1E\x08\x82\x82a\x1B\xDEV[6\x907`\x80\x80\x82Qa\x1E\x1A\x82\x82a\x1B\xDEV[6\x907a\x1EAa\x1E(a<(V[\x95a\x1E1a<\x03V[Pa\x1E:a<\x18V[P\x86aO#V[\x94a\x1E\xA9a\x1E\x90a\x1Ex``\x84\x01\x98a\x1Eo\x8AQa\x1E_\x87`@\x01\x90V[\x80Q\x8EQ\x91\x9E` \x01Q\x92aO\xFCV[\x96\x90\x9AQaP\xA5V[\x93\x90\x99Q\x90a\x1E\x89\x81Q\x91` \x01\x90V[Q\x91aP\xA5V[\x94\x90\x93a\x1E\x9C\x87a\x1C/V[\x98\x89R` \x89\x01Ra\x1C/V[\x96\x87R` \x87\x01R\x82\x86\x01R``\x85\x01RQ\x92\x83\x92\x83a\x1D\xAAV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`\x10T`@Q`\x08\x91\x90\x91\x1C`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[`\xC06`\x03\x19\x01\x12a\x04]W6`#\x12\x15a\x04]W`@\x80Qa\x1F\x14\x82\x82a\x1B\xDEV[\x806`\x84\x11a\x04]W`\x04\x90[`\x84\x82\x10a\x1FKWa\x11\x07\x84a\x1F<`\xA45`\x845\x87a<^V[\x90Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[\x83\x826\x03\x12a\x04]W` \x84\x91\x82Qa\x1Fc\x81a\x1B\x8BV[\x845a\x1Fn\x81a\r\x9DV[\x81R\x82\x85\x015\x83\x82\x01R\x81R\x01\x91\x01\x90a\x1F!V[`\x006`\x03\x19\x01\x12a\x04]Wa\x1F\x97aC\xB7V[`\0c\x8Bx\xC6\xD8\x19T\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3`\0c\x8Bx\xC6\xD8\x19U\0[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x1F\xEBaC\x9BV[\x80`\0R`\x07` R`\xFF`@`\0 T\x16\x15a \x04W\0[\x7FbH\xD5\xA2\tp-\xB8r\xB80E\xD5nK\xAFH6,\xE7\xA7\xCD\xA2\x85\xA6q\xE7\xC1\xE6?D\xB9`\0\x80\xA2\0[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90`\0[\x81\x81\x10a rWPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a eV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x80` `\x0CT\x91\x82\x81R\x01\x90`\x0C`\0R\x7F\xDFif\xC9q\x05\x1C=T\xECY\x16&\x06S\x14\x93\xA5\x14\x04\xA0\x02\x84/V\0\x9D~\\\xF4\xA8\xC7\x90`\0[\x81\x81\x10a \xF5Wa\x11\x07\x85a \xE9\x81\x87\x03\x82a\x1B\xDEV[`@Q\x91\x82\x91\x82a NV[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a \xD2V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]Wc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T`\x10\x1C\x16`@Q\x90\x15\x15\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\nT`@Q\x90\x81R\xF3[a\x1C\x0E\x90\x92\x91\x92`\xE0\x80a\x01\0\x83\x01\x95`\x01\x80`\xA0\x1B\x03\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01R``\x81\x01Q``\x85\x01Ra!\xDF`\x80\x82\x01Q`\x80\x86\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\xA0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`\xC0\x81\x81\x01Q\x15\x15\x90\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x04]W` 6`\x03\x19\x01\x12a\x04]Wa\"\xBCa\x01\0`\x045a\"*\x81a\x15qV[`\0`\xE0`@Qa\":\x81a\x1B\xA6V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x01R`@Q\x80\x93\x81\x92caQ\xAB\x1F`\xE0\x1B\x83R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x84\x01\x90\x92\x91`\x01`\x01`@\x1B\x03` \x91`@\x84\x01\x95`\x01\x80`\xA0\x1B\x03\x16\x84R\x16\x91\x01RV[\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x0B\x05Wa\x11\x07\x91`\0\x91a#\tW[P`@Q\x91\x82\x91\x82a!|V[a#+\x91Pa\x01\0=\x81\x11a#1W[a##\x81\x83a\x1B\xDEV[\x81\x01\x90a@bV[8a\"\xFCV[P=a#\x19V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\t\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a#q\x81a\x16\xCAV[`@\x80Qc\x1F\xC5\x0E\xF5`\xE3\x1B\x81R0`\x04\x82\x01R`\0\x92\x90\x91\x82`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x90\x81\x15a\x0B\x05W\x83\x92\x84\x92a#\xE3W[P` \x93P\x15a#\xDDWa\x10\t\x91a;fV[Pa\x10\tV[\x92P\x90P`@\x82=`@\x11a$\x1DW[\x81a$\0`@\x93\x83a\x1B\xDEV[\x81\x01\x03\x12a$\x19W\x91` \x92\x83\x83Q\x93\x01Q\x91\x93a#\xCAV[\x82\x80\xFD[=\x91Pa#\xF3V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a$B\x81a\r\x9DV[a$JaC\xB7V[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x91\x90\x81\x16\x90\x81\x83\x03a$\xDCWPP`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R\x90` \x82`$\x81\x84Z\xFA\x90\x81\x15a\x0B\x05Wa\r\x7F\x92`\0\x92a$\xBBW[P3\x90aF\xC1V[a$\xD5\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a$\xB3V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R\x91\x92P\x90` \x81`$\x81\x86Z\xFA`\0\x91\x81a%qW[Pa%\\WPP\x7F\xB3\x98\xCA#[>\xFF/g\xE7'\x07$e\r\x13\xE4|\xD5\xF9\xDA\xC1;\x91\x87\xED\x81\xB1'\xCE$\xC7`@Q\x80a\x14\xA2\x81``\x90` \x81R`\x0C` \x82\x01Rk\x04\xE6\xF7B\x06\x16\xE2\x04U$3#`\xA4\x1B`@\x82\x01R\x01\x90V[\x80\x91\x92Pa%fW\0[a\r\x7F\x913\x90aF\xC1V[a%\x8B\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a%\x05V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]Wa%\xBE`\x045a%\xB1aF!V[a%\xB9aC\x9BV[aA\xA3V[`\x01`\0U\0[\x80`#\x12\x15a\x04]Wa\x1C\xC7\x90`\x04a\x1CyV[\x80a\x01\x03\x12\x15a\x04]Wa\x1C\xC7\x90`\xE4a\x1CyV[4a\x04]W`@6`\x03\x19\x01\x12a\x04]Wa&\x086a%\xC5V[a&\x10aC\xD4V[`\x04Ta8@\x81\x01\x80\x91\x11a&\xBCWB\x10a&mWa&h\x81a&S\x7F\xC6\xA4h\xB8C\x85\xCDM\xFCD\r\xB2\x1D\r\xF6\xF06\x12\xBAC\xB3^\xFE\x19\r\xEE\x99;FjQ\x98\x93aB\xADV[a&\\B`\x04UV[`@Q\x91\x82\x91\x82aB\xD1V[\x03\x90\xA1\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FKey change cooldown: wait 4 hour`D\x82\x01R`s`\xF8\x1B`d\x82\x01R`\x84\x90\xFD[a2\xC4V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\xFF\x81\x16\x81\x03a\x04]W\x7F\xA1\x88\x93\xA1k\x81\x8F>\x8CS\x18\x921%\x0C\xB0+\xB5\\\xB3(\x02\xA6\xD5\xC2\xB5\xEB\x85l\xDB\x7F\x1E\x90a'\taC\xB7V[a'\x11a1\xB7V[`\x01\x80Ta\xFF\xFF\x19\x16\x90\x83\x16\x15\x15`\xFF\x16\x17`\x02\x83\x16\x15\x15`\x08\x1Ba\xFF\0\x16\x17b\xFF\0\0\x19\x16`\x04\x83\x16\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17`\x01U`@\x80Q`\xFF\x92\x83\x16\x81R\x91\x90\x92\x16` \x82\x01R\x90\x81\x90\x81\x01a&hV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]Wa\x11\x07a'\xFD`\x01`\x01`\x80\x1B\x03a(2a(,a'\xCE6a\x1DBV[\x94\x90a'\xE2a'\xDBa<(V[\x96\x87aO#V[\x92\x90\x96``\x83\x01Q\x90`@\x84\x01Q` \x82Q\x92\x01Q\x92aO\xFCV[\x90``\x83\x01Q\x97`@\x84\x01\x98a( \x8AQ\x91\x86Q` \x88\x01\x93\x89\x86\x86Q\x94aP\x8EV[\x96\x90\x95Q\x91Q\x92aQ2V[`\x80\x1C\x90V[\x91Q`@Q\x91\x90\x92\x16\x90\x91\x14\x81R\x90\x81\x90` \x82\x01\x90V[4a\x04]W`\x806`\x03\x19\x01\x12a\x04]W6`#\x12\x15a\x04]W` a\x10\ta(t6`\x04a\x1C=V[aB\xE1V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]Wa\x01\xA06`\x03\x19\x01\x12a\x04]W`\x045`$5`\x01`\x01`@\x1B\x03\x81\x11a\x04]Wa(\xF2\x906\x90`\x04\x01a\x1C\xFBV[`D5\x90a(\xFF6a\x1C\xB3V[a)\x086a%\xD9V[a)\x116a\x1C\xCAV[\x90a)\x1AaC\xD4V[`\x04`\xFFa)5a\t\n\x89`\0R`\x07` R`@`\0 \x90V[\x16\x03a*kWa)D\x86a7\x93V[a)M\x85aC>V[`@Qa)f\x81a\x05!` \x82\x01\x94\x85` \x91\x81R\x01\x90V[Q\x90 \x90`@Qa)\x83\x81a\x05!` \x82\x01\x94\x85` \x91\x81R\x01\x90V[Q\x90 \x03a*4W\x84a)\x95\x84aB\xE1V[\x03a)\xFDWa)\xB3\x93a)\xAF\x93a)\xAAa<(V[aI V[\x15\x90V[a)\xC1W\x81a\r\x7F\x92aJ)V[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x1D\x99\\\x9AY\x9AX\xD8]\x1A[\xDB\x88\x19\x98Z[\x19Y`j\x1B`D\x82\x01R`d\x90\xFD[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x0E\x0EM\xED\xEC\xC4\r\xAD.m\xAC.\x8Cm`\x93\x1B`D\x82\x01R`d\x90\xFD[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x0C-\x8E\r\x0C$\r\xAD.m\xAC.\x8Cm`\x93\x1B`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7FSAV must be last callback: other`D\x82\x01R\x7F providers have not completed\0\0\0`d\x82\x01R`\x84\x90\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a*\xF2aC\xB7V[a\x0B\xB8\x81\x11a+\0W`\x0FU\0[c\xB4\xFA?\xB3`\xE0\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\0R`\x07` R`@`\xFF\x81`\0 T\x16\x81Q\x90\x80\x15\x15\x82R` \x82\x01R\xF3[\x90`\0\x90[`\x02\x82\x10a+XWPPPV[\x82Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x90\x81\x01Q\x82\x82\x01R`\x01\x91`@\x01\x93\x01\x91\x01\x90\x91a+KV[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90`\0[\x81\x81\x10a+\xA0WPPP\x90V[\x90\x91\x92` a+\xD6`\x01\x92\x86Q\x90`@``\x92`\x01\x80`\xA0\x1B\x03\x81Q\x16\x83R` \x81\x01Q\x15\x15` \x84\x01R\x01Q`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a+\x93V[`\x05\x11\x15a+\xEAWV[cNH{q`\xE0\x1B`\0R`!`\x04R`$`\0\xFD[\x90`\x05\x82\x10\x15a+\xEAWRV[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90`\0[\x81\x81\x10a,+WPPP\x90V[\x90\x91\x92` a,_`\x01\x92\x86Q\x90`@``\x92`\xFF\x81Q\x16\x83R`\xFF` \x82\x01Q\x16` \x84\x01R\x01Q\x15\x15`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a,\x1EV[` \x81Ra,{` \x82\x01\x83Qa+FV[a\x01\x80a\x01\0a,\xCEa,\x9D` \x86\x01Q\x84`\xA0\x87\x01Ra\x01\xA0\x86\x01\x90a+\x82V[`@\x86\x01Q`\xC0\x86\x01Ra,\xB9``\x87\x01Q`\xE0\x87\x01\x90a,\0V[`\x80\x86\x01Q\x85\x82\x03`\x1F\x19\x01\x84\x87\x01Ra,\rV[`\xA0\x85\x01Q`\xFF\x16a\x01 \x85\x01R\x93`\xC0\x81\x01Q`\xFF\x16a\x01@\x85\x01R`\xE0\x81\x01Qa\x01`\x85\x01R\x01Q\x91\x01R\x90V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`@Qa-\x1E\x81a\x1B\xC2V[`@\x90\x81Qa--\x83\x82a\x1B\xDEV[`\0[\x83\x81\x10a-\xABWP\x81a\x01\0\x91`\0\x93R``` \x82\x01R\x82\x84\x82\x01R\x82``\x82\x01R```\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x82`\xE0\x82\x01R\x01R\x81\x15\x80\x15a-\xA0W[a\x11\x97Wa-\x95a\x18\x1Da\x11\x07\x93`\0R`\x0B` R`@`\0 \x90V[\x90Q\x91\x82\x91\x82a,iV[P`\nT\x82\x11a-wV[` \x90\x84Qa-\xB9\x81a\x1B\x8BV[`\0\x81R`\0\x83\x82\x01R\x81\x84\x01R\x01a-0V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`@a-\xEB`\x045aCaV[\x82Q\x91\x82R\x15\x15` \x82\x01R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`@Qcn\xB1v\x9F`\xE1\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R` \x81\x80`D\x81\x01\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a.\xDCW[P`\0\x19\x11a.\x9DW3\x90\x7F\xF6+\xA4\x7F\xE3\xFFa\x08\x89\x16\x0F\x02W\x13\x96\xE8n!\xB7\xAA\xDC\xBD\xE2q\x91\x92\xE2\x06\x85;3\x1F`\0\x80\xA3\0[`@Qc\x10\xD0_\x11`\xE2\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01RuInsufficient allowance`P\x1B`D\x82\x01R`d\x90\xFD[a.\xF5\x91P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[8a.kV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\x05\x81R\xF3[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W`\x045`$5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x163\x03a/vW\x81a\r\x7F\x92`\0R`\x06` R`@`\0 TaK\xAFV[c\\B|\xD9`\xE0\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a/\xA4\x81a\x16\xCAV[`@Qc\x12~\x8EM`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R\x90` \x82`$\x81`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x91\x82\x15a\x0B\x05W`\0\x92a0=W[P\x81\x90\x15a0\x10W[`@Q\x90\x81R` \x90\xF3[Pa0\x19a@\xF8V[\x90\x80\x82\x10a0,WPP` `\0a0\x05V[` \x91a08\x91a;fV[a0\x05V[a0W\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a/\xFCV[` 6`\x03\x19\x01\x12a\x04]W`\x045a0v\x81a\r\x9DV[a0~aC\xB7V[c8\x9Au\xE1`\x0CR\x80`\0R` `\x0C \x90\x81TB\x11a0\xA4W`\0a\r\x7F\x92UaH\xB7V[co^\x88\x18`\0R`\x04`\x1C\xFD[` 6`\x03\x19\x01\x12a\x04]W`\x045a0\xCA\x81a\r\x9DV[a0\xD2aC\xB7V[\x80``\x1B\x15a0\xE4Wa\r\x7F\x90aH\xB7V[ctH\xFB\xAE`\0R`\x04`\x1C\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a1\x0F\x81a\r\x9DV[a1\x17aC\xB7V[`\x10\x80Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x92\x90\x92\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x91\x90\x91\x17\x90U\0[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\x02\x81\x10\x15a\x04]W` \x90`\x02\x01T`@Q\x90\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a1\x9D\x81a\r\x9DV[c8\x9Au\xE1`\x0CR`\0R` \x80`\x0C T`@Q\x90\x81R\xF3[`\0`\x01T`\xFF\x81\x16a1\xEFW[`\xFF\x81`\x08\x1C\x16a1\xE4W[`\x10\x1C`\xFF\x16a1\xDEW\x90V[`\x04\x17\x90V[`\x02\x90\x91\x17\x90a1\xD1V[`\x01\x91Pa1\xC5V[\x90`\x05\x81\x10\x15a+\xEAW`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[`\x01`\x01`@\x1B\x03\x81\x11a\x1B\x86W`\x05\x1B` \x01\x90V[`@Q\x90a24\x82a\x1BkV[`\0`@\x83\x82\x81R\x82` \x82\x01R\x01RV[`\0[\x82\x81\x10a2UWPPPV[` \x90a2`a2'V[\x81\x84\x01R\x01a2IV[`@Q\x90`\xC0a2z\x81\x84a\x1B\xDEV[`\x05\x83Ra\x1C\x0E\x90`\x1F\x19\x01` \x84\x01a2FV[\x90a\x1C\x0Ea2\x9C\x83a2\x10V[a2\xA9`@Q\x91\x82a\x1B\xDEV[\x83\x81R` \x81\x94a2\xBC`\x1F\x19\x91a2\x10V[\x01\x91\x01a2FV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\xFF\x16`\xFF\x81\x14a&\xBCW`\x01\x01\x90V[cNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[`\xFF`\x01\x91\x16\x01\x90`\xFF\x82\x11a&\xBCWV[\x90`\xFF\x80\x91\x16\x91\x16\x01\x90`\xFF\x82\x11a&\xBCWV[\x80Q\x82\x10\x15a3;W` \x91`\x05\x1B\x01\x01\x90V[a1>V[\x90\x81`\x01\x1B\x91\x80\x83\x04`\x02\x14\x90\x15\x17\x15a&\xBCWV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a&\xBCWV[\x90UV[\x81Q\x91`\x01`@\x1B\x83\x11a\x1B\x86W\x81T\x83\x83U\x80\x84\x10a4\x0CW[P` a3\x9C\x91\x01\x91`\0R` `\0 \x90V[`\0\x91[\x83\x83\x10a3\xADWPPPPV[`\x01` \x82a4\0\x83\x94Q\x86\x81Q\x81T`\xFF\x19\x16`\xFF\x91\x90\x91\x16\x17\x81U\x90`@\x90` \x81\x01Q\x83Ta\xFF\0\x19\x16`\x08\x91\x90\x91\x1Ba\xFF\0\x16\x17\x91\x01Qb\xFF\0\0\x19\x90\x91\x16\x90\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17\x90UV[\x01\x92\x01\x92\x01\x91\x90a3\xA0V[\x82`\0R\x83` `\0 \x91\x82\x01\x91\x01[\x81\x81\x10a4)WPa3\x88V[`\0\x81U`\x01\x01a4\x1CV[\x90`\x02\x81\x10\x15a3;W`\x01\x1B\x01\x90`\0\x90V[\x90`\x01\x82\x01\x80\x92\x11a&\xBCWV[\x91\x90\x82\x01\x80\x92\x11a&\xBCWV[`@Q=`\0\x82>=\x90\xFD[`@Qc\x17\x11\x92)`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R` \x90\x82\x90`$\x90\x82\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a4\xEDWP\x90V[` \x81=` \x11a5$W[\x81a5\x06` \x93\x83a\x1B\xDEV[\x81\x01\x03\x12a\rbWQ\x90`\x01`\x01`\x80\x1B\x03\x82\x16\x82\x03a\rdWP\x90V[=\x91Pa4\xF9V[a54aC\x9BV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\x04]W`\0\x90`$`@Q\x80\x94\x81\x93cO\xFD.C`\xE0\x1B\x83R0`\x04\x84\x01RZ\xF1\x80\x15a\x0B\x05Wa5\x90WPV[`\0a\x1C\x0E\x91a\x1B\xDEV[\x90\x81Ta5\xA7\x81a2\x10V[\x92a5\xB5`@Q\x94\x85a\x1B\xDEV[\x81\x84R` \x84\x01\x90`\0R` `\0 `\0\x91[\x83\x83\x10a5\xD6WPPPPV[`\x02` `\x01\x92`@Qa5\xE9\x81a\x1BkV[`\xFF\x86T\x86\x80`\xA0\x1B\x03\x81\x16\x83R`\xA0\x1C\x16\x15\x15\x83\x82\x01R\x84\x86\x01T`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a5\xC9V[\x80\x15\x80\x15a6\xE2W[a\x11\x97W`\x04a6>a6D\x92`\0R`\x0B` R`@`\0 \x90V[\x01a5\x9BV[\x80Q`\0\x92\x91\x83\x91\x82\x91[\x81\x83\x10a6\x90WPPP\x80\x15\x15\x80a6\x87W[\x15a6\x7FWa6q\x83\x82aE^V[\x92a6|\x82\x82aE^V[\x92V[`\0\x92`\0\x92V[P\x82\x15\x15a6bV[\x90\x91\x92a6\xA5a)\xAF` a\x1A\x8A\x87\x86a3'V[\x15a6\xC7W`\x01\x90`@a6\xB9\x86\x85a3'V[Q\x01Q\x01\x93[\x01\x91\x90a6OV[\x92\x94`\x01\x90`@a6\xD8\x88\x85a3'V[Q\x01Q\x01\x95a6\xBFV[P`\nT\x81\x11a6!V[`@Q\x90a6\xFC` \x83a\x1B\xDEV[`\0\x80\x83R\x82\x81[\x82\x81\x10a7\x10WPPPV[` \x90a7\x1Ba2'V[\x82\x82\x85\x01\x01R\x01a7\x04V[\x90a71\x82a2\x10V[a7>`@Q\x91\x82a\x1B\xDEV[\x82\x81R\x80\x92a7O`\x1F\x19\x91a2\x10V[\x01\x90`\0[\x82\x81\x10a7`WPPPV[` \x90a7ka2'V[\x82\x82\x85\x01\x01R\x01a7TV[\x80T\x82\x10\x15a3;W`\0R` `\0 \x90`\x01\x1B\x01\x90`\0\x90V[\x80\x15\x80\x15a7\xD4W[a\x11\x97W`\0\x81\x81R`\x0B` R`@\x90 `\n\x81\x01T\x81T`\x02\x90\x92\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x90\x83\x16\x18\x90\x91\x16\x90\x91\x18\x18\x90V[P`\nT\x81\x11a7\x9CV[\x15a7\xE6WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FETH/DMT transfer failed\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`\0\x90`\0\x90`\x01T`\xFF\x81\x16a9\x03W[`\x08\x1C`\xFF\x16a8aW[`\x01`\x01`\x80\x1B\x03\x83\x16\x82\x81\x01\x80\x91\x11a&\xBCW\x92\x91\x90V[`@Qc\x12~\x8EM`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R\x90\x91P` \x81`$\x81`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a8\xE4W[Pa8\xC4a@\xF8V[\x81\x81\x10a8\xD6WPP`\0[\x90a8HV[a8\xDF\x91a;fV[a8\xD0V[a8\xFD\x91P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[8a8\xBBV[\x92P`\xFFa9\x0Fa4pV[\x93\x90Pa8=V[Q\x90a\x1C\x0E\x82a\r\x9DV[\x90\x81` \x91\x03\x12a\x04]WQa\x1C\xC7\x81a\r\x9DV[\x81Q\x81T` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U`@\x90\x91\x01Q`\x01\x90\x91\x01UV[\x80T`\x01`@\x1B\x81\x10\x15a\x1B\x86Wa9\x92\x91`\x01\x82\x01\x81Ua7wV[\x91\x90\x91a9\xA2Wa\x1C\x0E\x91a97V[cNH{q`\xE0\x1B`\0R`\0`\x04R`$`\0\xFD[\x90`@Q\x91a9\xC6\x83a\x1B\x8BV[`\0\x83[`\x02\x82\x10a9\xD7WPPPV[`\x02` `\x01\x92`@Qa9\xEA\x81a\x1B\x8BV[\x84\x80`\xA0\x1B\x03\x87T\x16\x81R\x84\x87\x01T\x83\x82\x01R\x81R\x01\x93\x01\x91\x01\x90\x91a9\xCAV[`\x05\x82\x10\x15a+\xEAWRV[\x90\x81Ta:#\x81a2\x10V[\x92a:1`@Q\x94\x85a\x1B\xDEV[\x81\x84R` \x84\x01\x90`\0R` `\0 `\0\x91[\x83\x83\x10a:RWPPPPV[`\x01` \x81\x92`@Qa:d\x81a\x1BkV[`\xFF\x86T\x81\x81\x16\x83R\x81\x81`\x08\x1C\x16\x85\x84\x01R`\x10\x1C\x16\x15\x15`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a:EV[\x90`\na:\x9Ba\x1C\x10V[\x92a:\xA5\x81a9\xB8V[\x84Ra:\xB3`\x04\x82\x01a5\x9BV[` \x85\x01R`\x05\x81\x01T`@\x85\x01Ra:\xDCa:\xD3`\x06\x83\x01T`\xFF\x16\x90V[``\x86\x01a:\x0BV[a:\xE8`\x07\x82\x01a:\x17V[`\x80\x85\x01Ra;\"a;\x18`\x08\x83\x01Ta;\x0Fa;\x05\x82`\xFF\x16\x90V[`\xFF\x16`\xA0\x89\x01RV[`\x08\x1C`\xFF\x16\x90V[`\xFF\x16`\xC0\x86\x01RV[`\t\x81\x01T`\xE0\x85\x01R\x01Ta\x01\0\x83\x01RV[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x03\x90p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x82\x11a&\xBCWV[\x91\x90\x82\x03\x91\x82\x11a&\xBCWV[\x90`\x02\x81\x10\x15a3;W`\x05\x1B\x01\x90V[`@Q\x90a\x1C\x0E`\xA0a;\x97\x81\x85a\x1B\xDEV[\x83a2FV[\x90`\x05\x81\x10\x15a3;W`\x05\x1B\x01\x90V[\x91\x90a\x01\xE0\x83\x01\x92`\0\x90[`\x05\x82\x10a;\xC7WPPPV[` a;\xF8`\x01\x92\x85Q\x90`@``\x92`\xFF\x81Q\x16\x83R`\xFF` \x82\x01Q\x16` \x84\x01R\x01Q\x15\x15`@\x82\x01R\x01\x90V[\x93\x01\x91\x01\x90\x91a;\xBAV[`@\x90\x81Q\x91a<\x13\x81\x84a\x1B\xDEV[6\x837V[`@Q\x90`\x80a<\x13\x81\x84a\x1B\xDEV[`@Q\x90`\x02`\0\x83[`\x02\x82\x10a<HWPPPa\x1C\x0E`@\x83a\x1B\xDEV[`\x01` \x81\x92\x85T\x81R\x01\x93\x01\x91\x01\x90\x91a<2V[\x91a<gaC\x9BV[a<q\x83QaG\xC8V[` \x83\x01\x91a<\x80\x83QaG\xC8V[` \x84Q\x01Q` \x84Q\x01Q\x14a+\0Wa>\x05\x93a>\x19\x7F\xD4x\xFA$r\x01\x1C\xA0y\x8D5\x11_\xC3\xCA\xA7&\x8CI\xCB}\xC8\x8A%\x184O\xC9c\x1B\xBF,\x93a=\x1A\x84`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a=\x05\x82a<\xFD\x88Q`\x01\x80`\xA0\x1B\x03\x90Q\x16\x90V[0\x90\x84aE\xBFV[\x88QQ0\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x90aE\xBFV[a=-a=(`\nTa>\x1FV[`\nUV[`\nT\x96\x87\x96`@\x92a=?\x84a\x1C/V[\x86QQ\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16` \x88Q\x01Qa=na=_a\x1C V[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83RV[` \x82\x81\x01\x91\x90\x91R\x90\x84R\x81QQ`\x01`\x01`\xA0\x1B\x03\x16\x91Q\x01Qa=\x95a=_a\x1C V[` \x82\x01R` \x83\x01Ra=\xA7a6\xEDV[a=\xAFa2jV[\x90a=\xB8a\x1C\x10V[\x93\x84R` \x84\x01R\x87\x85\x84\x01R`\0``\x84\x01R`\x80\x83\x01R`\0`\xA0\x83\x01R`\0`\xC0\x83\x01R`\0`\xE0\x83\x01Ra\x01\0\x82\x01Ra>\0\x88`\0R`\x0B` R`@`\0 \x90V[a?IV[a>\x0E\x86aP\xB3V[PQ\x92\x83\x92\x83a?\xF5V[\x03\x90\xA2\x90V[`\0\x19\x81\x14a&\xBCW`\x01\x01\x90V[\x91a3i\x91\x83T\x90`\x03\x1B\x91\x82\x1B\x91`\0\x19\x90\x1B\x19\x16\x17\x90V[\x90`\0\x90[`\x02\x82\x10a>ZWPPPV[\x80Q\x80Q\x84T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x84U`\x01\x91`\x02\x91` \x91\x90\x82\x01Q\x84\x87\x01U\x01\x93\x01\x91\x01\x90\x91a>MV[\x81Q\x91`\x01`@\x1B\x83\x11a\x1B\x86W\x81T\x83\x83U\x80\x84\x10a>\xF4W[P` a>\xC5\x91\x01\x91`\0R` `\0 \x90V[`\0\x91[\x83\x83\x10a>\xD6WPPPPV[`\x02` \x82a>\xE8`\x01\x94Q\x86a97V[\x01\x92\x01\x92\x01\x91\x90a>\xC9V[`\x01`\x01`\xFF\x1B\x03\x81\x16\x81\x03a&\xBCW`\x01`\x01`\xFF\x1B\x03\x84\x16\x84\x03a&\xBCW\x82`\0R` `\0 \x90`\x01\x1B\x81\x01\x90\x84`\x01\x1B\x01[\x81\x81\x10a?7WPa>\xB1V[`\0\x80\x82U`\x01\x82\x01U`\x02\x01a?*V[\x90a\x01\0`\n\x91a?[\x81Q\x85a>HV[a?l` \x82\x01Q`\x04\x86\x01a>\x96V[`@\x81\x01Q`\x05\x85\x01Ua?\x90``\x82\x01Qa?\x87\x81a+\xE0V[`\x06\x86\x01a1\xF8V[a?\xA1`\x80\x82\x01Q`\x07\x86\x01a3mV[a?\xE4`\x08\x85\x01a?\xC9a?\xB9`\xA0\x85\x01Q`\xFF\x16\x90V[\x82T`\xFF\x19\x16`\xFF\x90\x91\x16\x17\x82UV[`\xC0\x83\x01Q\x81Ta\xFF\0\x19\x16`\x08\x91\x90\x91\x1Ba\xFF\0\x16\x17\x90UV[`\xE0\x81\x01Q`\t\x85\x01U\x01Q\x91\x01UV[`\xA0\x81\x01\x93\x92\x91`\0\x82[`\x02\x82\x10a@\x11WPPP`\x80\x01RV[\x82Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x90\x81\x01Q\x82\x82\x01R`\x01\x91`@\x01\x93\x01\x91\x01\x90\x91a@\0V[Q\x90a\x1C\x0E\x82a\x15qV[Q\x90c\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04]WV[Q\x90a\x1C\x0E\x82a\x16\xCAV[\x90\x81a\x01\0\x91\x03\x12a\x04]Wa@\xF0`\xE0`@Q\x92a@\x80\x84a\x1B\xA6V[a@\x89\x81a9\x17V[\x84Ra@\x97` \x82\x01a@;V[` \x85\x01Ra@\xA8`@\x82\x01a@FV[`@\x85\x01R``\x81\x01Q``\x85\x01Ra@\xC3`\x80\x82\x01a@;V[`\x80\x85\x01Ra@\xD4`\xA0\x82\x01a9\x17V[`\xA0\x85\x01Ra@\xE5`\xC0\x82\x01a@WV[`\xC0\x85\x01R\x01a@WV[`\xE0\x82\x01R\x90V[`@\x80Qc\x1F\xC5\x0E\xF5`\xE3\x1B\x81R0`\x04\x82\x01R\x90\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x0B\x05W`\0\x91\x82\x91aAZW[P\x81\x03\x90\x81\x11a&\xBCW\x90V[\x90P`@\x81=`@\x11aA\x8CW[\x81aAu`@\x93\x83a\x1B\xDEV[\x81\x01\x03\x12a\rbW` \x90\x80Q\x92P\x01Q8aAMV[=\x91PaAhV[\x90\x81` \x91\x03\x12a\x04]WQ\x90V[\x80\x15\x80\x15aB\xA2W[a\x11\x97WaA\xC4\x81`\0R`\x0B` R`@`\0 \x90V[`\x06\x81\x01\x90aA\xD4\x82T`\xFF\x16\x90V[\x91`\x05\x82\x01T\x92aA\xE4\x81a+\xE0V[`\x03\x81\x14\x90\x81\x15aB\x8EW[PaB\x88W\x80T`\xFF\x19\x16`\x04\x17\x90UaBa\x91a\x19P\x90aB\x11\x85aN/V[P\x82T`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x91aBM\x91\x84\x91\x16\x83aF\xC1V[aB[`\x02\x85\x01`\0a\x11\x1BV[\x90aF\xC1V[\x7F\xEC^\xA2?r\xA0\n.G}qM\xC0\x12\x98bq\xCD<\x96\xAD\x95\xC7\xFE_b\x9F\xF7\x98G\xFD!`\0\x80\xA2V[PPPPV[`\x04\x91PaB\x9B\x81a+\xE0V[\x148aA\xF0V[P`\nT\x81\x11aA\xACV[`\0[`\x02\x81\x10aB\xBCWPPV[`\x01\x90` \x83Q\x93\x01\x92\x81`\x02\x01U\x01aB\xB0V[`@\x81\x01\x92\x91a\x1C\x0E\x91\x90a\x1D\x82V[`\0aC-a\x05!aC!aB\xFE` \x95\x86\x81Q\x91\x01Q\x90aQ\xAEV[`@Q`\x7F`\xF9\x1B\x87\x82\x01R`\x03`\xF8\x1B`!\x82\x01R\x92\x83\x91`\"\x83\x01\x90aH\xF5V[`@Q\x91\x82\x80\x92aH\xF5V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0Q\x90V[` \x81Q\x91\x01Q\x90` \x81\x10aCRWP\x90V[`\0\x19\x90` \x03`\x03\x1B\x1B\x16\x90V[\x90\x81`\0R`\x07` R`\xFF`@`\0 T\x16\x15\x91`\0R`\x08` R`@`\0 T\x82\x80aC\x93W[a\x0C\xB1W\x91\x90V[P\x80\x15aC\x8BV[c\x8Bx\xC6\xD8`\x0CR3`\0R`\x01` `\x0C T\x16\x15aC\xB7WV[c\x8Bx\xC6\xD8\x19T3\x03aC\xC6WV[c\x82\xB4)\0`\0R`\x04`\x1C\xFD[c\x8Bx\xC6\xD8`\x0CR3`\0R`\x02` `\x0C T\x16\x15aC\xB7WV[`\0\x81\x15\x80\x15aDgW[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaD\x1F\x82a+\xE0V[`\x01\x82\x03aD,WPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaDF\x90`$\x90a,\0V[aDR`D`\x01a,\0V[`d`\0\xFD[c]\xF6&\xE1`\xE1\x1B\x81R`\x04\x90\xFD[P`\nT\x82\x11aC\xFBV[`\0\x81\x15\x80\x15aD\xD1W[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaD\xA1\x82a+\xE0V[\x81aD\xABWPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaD\xC5\x90`$\x90a,\0V[aDR`D`\0a,\0V[P`\nT\x82\x11aD}V[`\0\x81\x15\x80\x15aE>W[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaE\x0B\x82a+\xE0V[`\x02\x82\x03aE\x18WPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaE2\x90`$\x90a,\0V[aDR`D`\x02a,\0V[P`\nT\x82\x11aD\xE7V[\x90\x81` \x91\x03\x12a\x04]WQa\x1C\xC7\x81a\x15qV[x\x12r]\xD1\xD2C\xAB\xA0\xE7_\xE6E\xCCHs\xF9\xE6Z\xFEh\x8C\x92\x8E\x1F\"\x81\x10\x82\x02\x15aE\x8FWg\r\xE0\xB6\xB3\xA7d\0\0\x02\x04\x90V[c|_H}`\0R`\x04`\x1C\xFD[\x90`\x01`\x01`@\x1B\x03a\x1C\x0E\x92\x16\x80`\0R`\x05` R`@`\0 TaL\xA0V[\x91`@Q\x93``R`@R``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` `\0`d`\x1C\x82\x85Z\xF1\x90\x81`\x01`\0Q\x14\x16\x15aF\x02W[PP`\0``R`@RV[;\x15=\x17\x10\x15aF\x13W8\x80aE\xF6V[cy9\xF4$`\0R`\x04`\x1C\xFD[`\x02`\0T\x14aF2W`\x02`\0UV[c>\xE5\xAE\xB5`\xE0\x1B`\0R`\x04`\0\xFD[\x81\x81\x02\x91a'\x10\x81\x83\x85\x04\x14\x83\x15\x17\x02\x15aFbWPPa'\x10\x90\x04\x90V[a'\x10\x90`\0\x19\x81\x84\t\x84\x81\x10\x85\x01\x90\x03\x92\t\x90\x80a'\x10\x11\x15aF\xB3W\x82\x82\x11\x90\x03`\xFC\x1B\x91\x03`\x04\x1C\x17\x7F\xBC\x01\xA3n.\xB1\xC42\xCAW\xA7\x86\xC2&\x80\x9DIQ\x82\xA9\x93\x0B\xE0\xDE\xD2\x88\xCEp:\xFB~\x91\x02\x90V[c\xAEG\xF7\x02`\0R`\x04`\x1C\xFD[\x91\x90`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B`\0R` `\0`D`\x10\x82\x85Z\xF1\x90\x81`\x01`\0Q\x14\x16\x15aF\xF8W[PP`\0`4RV[;\x15=\x17\x10\x15aG\tW8\x80aF\xEFV[c\x90\xB8\xEC\x18`\0R`\x04`\x1C\xFD[\x90\x80`\0\x19\x04\x82\x11aG3W[g\r\xE0\xB6\xB3\xA7d\0\0\x91\x02\x04\x90V[\x80\x15aG$Wc\xBA\xC6^[`\0R`\x04`\x1C\xFD[`\x04aGS\x91\x01a5\x9BV[\x80Q\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90`\0[\x83\x81\x10aG\x91WPPPPV[`\x01\x90aG\xC2`\x01`\x01`\xA0\x1B\x03aG\xA9\x83\x86a3'V[QQ\x16`@aG\xB8\x84\x87a3'V[Q\x01Q\x90\x86aF\xC1V[\x01aG\x84V[\x90` \x82\x01\x90aG\xF4` \x83Q`@Q\x80\x93\x81\x92c1\xA9\x10\x8F`\xE1\x1B\x83R`\x04\x83\x01\x91\x90` \x83\x01\x92RV[\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA`\0\x91\x81aH\x96W[PaHVW\x83Q\x83Qc\tg\xA7\xEB`\xE1\x1B`\0R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$R`D`\0\xFD[\x92Q\x90\x92`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x92\x91\x16\x82\x90\x03aHsWPPV[Qc\tg\xA7\xEB`\xE1\x1B`\0R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$R`D`\0\xFD[aH\xB0\x91\x92P` =` \x11a\x15%Wa\x15\x18\x81\x83a\x1B\xDEV[\x908aH+V[`\x01\x80`\xA0\x1B\x03\x16\x80c\x8Bx\xC6\xD8\x19T\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`\0\x80\xA3c\x8Bx\xC6\xD8\x19UV[\x90\x81Q\x91`\0[\x83\x81\x10aI\rWPP\x01`\0\x81R\x90V[\x80` \x80\x92\x84\x01\x01Q\x81\x85\x01R\x01aH\xFCV[\x92\x91aI/\x90\x94\x91\x94\x84aO#V[aI;\x86\x92\x96``\x01\x90V[\x80Q\x96\x90aIja)\xAF`@\x86\x01\x99\x8AQ\x99aIY\x81Q\x91` \x01\x90V[Q\x8AQ\x91` \x8C\x01\x9C\x8DQ\x94aQ\xE5V[\x90\x81\x15aJ\x0BW[P\x80\x15aI\xDEW[aI\xD2W`\x01`\x01`\x80\x1B\x03\x95aI\xCA\x95aI\xB0a(,\x96\x80Q\x90aI\x9F\x81` \x01\x90V[Q`@\x82\x01Q\x91``\x01Q\x92aS\"V[\x95\x90\x94aI\xBF\x82Q\x92` \x01\x90V[Q\x92Q\x93Q\x94aQ2V[\x91Q\x91\x16\x14\x90V[PPPPPPP`\0\x90V[PaJ\x06a)\xAF\x88Q\x85QaI\xF3\x87` \x01\x90V[Q`@\x89\x01Q\x91``\x8A\x01[Q\x93aR\xB9V[aIzV[aJ#\x91Pa)\xAF\x90Q\x86Q\x85\x85aI\xFF\x8A` \x01\x90V[8aIrV[\x91\x90`\x04aJDa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aKwWPaJ~aJb\x83`\0R`\x07` R`@`\0 \x90V[`\x04aJo\x82T`\xFF\x16\x90V[\x18`\xFF\x16`\xFF\x19\x82T\x16\x17\x90UV[a\x05!aJ\xB6aJ\x98\x84`\0R`\x08` R`@`\0 \x90V[T\x92`@Q\x92\x83\x91` \x83\x01\x95\x86\x90\x91`@\x92\x82R` \x82\x01R\x01\x90V[Q\x90 aJ\xCD\x82`\0R`\x08` R`@`\0 \x90V[U`\x04\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[\x15aK\x18WPV[\x80\x7F\xB2o\xE0\x8ENQ\xC0\x1E\\\xFF\xFF_H\x87$\x95\x99w\x9A\xA0\xD4\xF8co\xF4\xE7\xCDH1\xB4\x95\xED`\0\x80\xA2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aKfWPV[`\0\x90\x81R`\t` R`@\x81 UV[`@Q\x90\x81R`\x04\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01[\x03\x90\xA3V[\x91\x90`\x02aK\xCAa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aLiWPaK\xF5aK\xE8\x83`\0R`\x07` R`@`\0 \x90V[`\x02aJo\x82T`\xFF\x16\x90V[a\x05!aL\x0FaJ\x98\x84`\0R`\x08` R`@`\0 \x90V[Q\x90 aL&\x82`\0R`\x08` R`@`\0 \x90V[U`\x02\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[`@Q\x90\x81R`\x02\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01aK\xAAV[\x91\x90`\x01aL\xBBa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aMZWPaL\xE6aL\xD9\x83`\0R`\x07` R`@`\0 \x90V[`\x01aJo\x82T`\xFF\x16\x90V[a\x05!aM\0aJ\x98\x84`\0R`\x08` R`@`\0 \x90V[Q\x90 aM\x17\x82`\0R`\x08` R`@`\0 \x90V[U`\x01\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[`@Q\x90\x81R`\x01\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01aK\xAAV[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C \x90\x81T\x90\x81\x16\x18\x80\x91U`\x0CQ``\x1C\x7FqZ\xD5\xCEa\xFC\x95\x95\xC7\xB4\x15(\x9DY\xCF ?#\xA9O\xA0o\x04\xAF~H\x9A\nv\xE1\xFE&`\0\x80\xA3V[\x80T\x82\x10\x15a3;W`\0R` `\0 \x01\x90`\0\x90V[\x80T\x80\x15aN\x19W`\0\x19\x01\x90aN\x07\x82\x82aM\xD8V[\x81T\x90`\0\x19\x90`\x03\x1B\x1B\x19\x16\x90UUV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD[`\0\x81\x81R`\r` R`@\x90 T\x90\x81\x15aN\xD0W`\0\x19\x82\x01\x90\x82\x82\x11a&\xBCW`\x0CT`\0\x19\x81\x01\x93\x90\x84\x11a&\xBCW\x83\x83`\0\x95aN\x8F\x95\x03aN\x95W[PPPaN~`\x0CaM\xF0V[`\r\x90`\0R` R`@`\0 \x90V[U`\x01\x90V[aN~aN\xC1\x91aN\xB7aN\xADaN\xC7\x95`\x0CaM\xD8V[\x90T\x90`\x03\x1B\x1C\x90V[\x92\x83\x91`\x0CaM\xD8V[\x90a>.V[U8\x80\x80aNqV[PP`\0\x90V[`\x7F`\xF9\x1B\x81R`\x01`\xF8\x1B`\x01\x82\x01Ra\x1C\xC7\x92\x91aN\xFA\x91`\x02\x01\x90aH\xF5V[\x90aH\xF5V[aO\r\x90`\x01\x93\x92aH\xF5V[`\xF8\x91\x90\x91\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x81R\x01\x90V[aO=aOO\x91aO6\x81Q\x91` \x01\x90V[Q\x90aQ\xAEV[a\x05!`@Q\x93\x84\x92` \x84\x01aN\xD7V[`\0[a\x01\0`\xFF\x82\x16\x10aO\xA3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FNo valid point was found\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[` `\0aO\xBE`@QaC!\x81a\x05!\x87\x89\x88\x84\x01aO\0V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0QaO\xD5\x81aSSV[\x90aO\xE0\x82\x82aS\xB6V[aO\xF4WPPaO\xEF\x90a2\xDAV[aORV[\x93\x90\x92P\x90PV[aPa\x91\x92\x93aPYaPS\x7FH:\xDAw&\xA3\xC4e]\xA4\xFB\xFC\x0E\x11\x08\xA8\xFD\x17\xB4H\xA6\x85T\x19\x9CG\xD0\x8F\xFB\x10\xD4\xB8\x7Fy\xBEf~\xF9\xDC\xBB\xACU\xA0b\x95\xCE\x87\x0B\x07\x02\x9B\xFC\xDB-\xCE(\xD9Y\xF2\x81[\x16\xF8\x17\x98aPS\x95aU\x12V[\x91aU\x99V[\x95\x90\x94aU\x12V[d\x01\0\0\x03\xD0\x19\x03\x92d\x01\0\0\x03\xD0\x19\x84\x11a&\xBCWaP\x8A\x93d\x01\0\0\x03\xD0\x19\x90\x06\x92aTOV[\x90\x91V[aPSaPS\x93aPa\x95\x96\x97\x93aPY\x93aU\x12V[\x91aPS\x91aP\x8A\x93aU\x12V[\x80`\0R`\r` R`@`\0 T\x15`\0\x14aQ,W`\x0CT`\x01`@\x1B\x81\x10\x15a\x1B\x86W`\x01\x81\x01`\x0CU`\0`\x0CT\x82\x10\x15a3;W`\x0C\x90R\x7F\xDFif\xC9q\x05\x1C=T\xECY\x16&\x06S\x14\x93\xA5\x14\x04\xA0\x02\x84/V\0\x9D~\\\xF4\xA8\xC7\x01\x81\x90U`\x0CT\x90`\0R`\r` R`@`\0 U`\x01\x90V[P`\0\x90V[\x93aN\xFA`\0\x97aN\xFAaQr` \x9BaQlaQ\x98\x9BaQfaC!\x9BaQ`a\x05!\x9BaN\xFA\x9FaQ\xAEV[\x9BaQ\xAEV[\x97aQ\xAEV[\x93aQ\xAEV[`@Q`\x7F`\xF9\x1B\x8D\x82\x01R`\x01`\xF9\x1B`!\x82\x01R\x98\x89\x97\x91\x95\x91`\"\x89\x01\x90aH\xF5V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0Q\x80`@QR\x90V[\x90`\x01\x16`\x02\x01\x90\x81`\x02\x11a&\xBCW`@Q\x91`\xFF`\xF8\x1B\x90`\xF8\x1B\x16` \x83\x01R`!\x82\x01R`!\x81Ra\x1C\xC7`A\x82a\x1B\xDEV[\x91`\xFF\x91` \x94`\x01aR\x1AaQ\xFF`\0\x97\x9A\x99\x9Aa;6V[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x90\x06\x93a;6V[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x90\x06\x91\x16\x15\x15\x85\x14aR\xB1W`\x1C\x92[`@Q\x94\x85\x94`\x80\x86\x01\x94\x83p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t\x86R\x16\x87\x85\x01R\x80`@\x85\x01Rp\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t``\x83\x01R\x83\x80R\x03\x90`\x01Z\xFA\x15a\x0B\x05WaR\xA0\x90`\0Q\x92aT V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x90V[`\x1B\x92aR=V[\x92\x93\x92` \x92`\0\x92`\x80\x92\x90\x91`\x01\x16\x15aS\x1AW`\x1C\x91[`\xFF`@Q\x93\x86\x85R\x16\x86\x84\x01R\x80`@\x84\x01Rp\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t``\x82\x01R\x82\x80R`\x01Z\xFA\x15a\x0B\x05WaR\xA0\x90`\0Q\x92aT V[`\x1B\x91aR\xD3V[\x91\x92d\x01\0\0\x03\xD0\x19\x03\x91d\x01\0\0\x03\xD0\x19\x83\x11a&\xBCWaP\x8A\x93d\x01\0\0\x03\xD0\x19\x93`\0\x93\x90\x85\x90\x06\x92aT\xB5V[aS\x89\x90c@\0\0\xF4`\x01`\xFE\x1B\x03\x90d\x01\0\0\x03\xD0\x19\x90\x81`\x07\x81`\0\x84\t\x08\x90d\x01\0\0\x03\xD0\x19\x90\x81\x81\x80\t\x90\t\x08a[\xEFV[`\x02\x81\x01\x80\x82\x11a&\xBCW`\x01\x16aS\x9EW\x90V[d\x01\0\0\x03\xD0\x19\x03d\x01\0\0\x03\xD0\x19\x81\x11a&\xBCW\x90V[\x80\x15\x80\x15aT\x10W[\x80\x15aT\x08W[\x80\x15aS\xF8W[aN\xD0Wd\x01\0\0\x03\xD0\x19\x90\x81\x81\x80\t\t`\x07d\x01\0\0\x03\xD0\x19\x91\x08\x90d\x01\0\0\x03\xD0\x19\x90\x80\t\x14\x90V[Pd\x01\0\0\x03\xD0\x19\x82\x10\x15aS\xCDV[P\x81\x15aS\xC6V[Pd\x01\0\0\x03\xD0\x19\x81\x10\x15aS\xBFV[`@Q\x91` \x83\x01\x91\x82R`@\x83\x01R`@\x82RaT?``\x83a\x1B\xDEV[\x90Q\x90 `\x01`\x01`\xA0\x1B\x03\x16\x90V[\x92\x90\x91\x80\x84\x03aT\x98WPd\x01\0\0\x03\xD0\x19\x90\x82\x08aTrWPP`\0\x90`\0\x90V[aP\x8A\x91`\0aT\x89\x92d\x01\0\0\x03\xD0\x19\x92aZ\xA8V[\x90[d\x01\0\0\x03\xD0\x19\x92aV\x9CV[aP\x8A\x93aT\xAF\x93d\x01\0\0\x03\xD0\x19\x93\x92\x91aW~V[\x90aT\x8BV[\x93\x94\x93\x90\x92\x90\x91\x80\x83\x03aT\xF8WP\x83\x15aT\xF3W\x83\x90\x83\x08aT\xDEWPPPP`\0\x90`\0\x90V[aP\x8A\x93aT\xED\x92\x84\x92aZ\xA8V[\x91aV\x9CV[a2\xEBV[aP\x8A\x95PaT\xED\x93\x85\x93aW~V[\x81\x15aT\xF3W\x04\x90V[\x92\x90\x91\x92`\x01\x90\x80\x15aU\x8FW`\0\x94`\x01\x94\x86\x93\x92\x80[aU7WPPPP\x92\x91\x90V[`\x01\x81\x16aUcW[\x90`\0aUZ\x92`\x01\x1C\x94\x85\x94d\x01\0\0\x03\xD0\x19\x93a[\x1EV[\x92\x90\x92\x93aU*V[\x93aU\x80\x90\x84\x84\x84`\0\x9AaUZ\x96\x9Cd\x01\0\0\x03\xD0\x19\x95aY\x14V[\x90\x98\x90\x97P\x90\x94\x90\x91PaU@V[PP\x90\x91\x90`\x01\x90V[\x91\x92\x91\x90`\0\x84\x15\x15\x85\x81aV\x8BW[P\x80aV\x83W[\x15aVMW`\0\x94\x90\x85d\x01\0\0\x03\xD0\x19`\x01\x84[aU\xF4WPPPPPd\x01\0\0\x03\xD0\x19\x84\x80\t\x91\x82d\x01\0\0\x03\xD0\x19\x91\t\x93d\x01\0\0\x03\xD0\x19\x92\x83\x91\t\x90\t\x90V[aV\x02\x85\x83\x9A\x95\x96\x9AaU\x08V[\x91\x81\x93aT\xF3WaV>aV)aVD\x93d\x01\0\0\x03\xD0\x19\x90\x86\td\x01\0\0\x03\xD0\x19a;fV[\x87\x96d\x01\0\0\x03\xD0\x19\x91\x90\x08\x94\x9A\x80\x94a3VV[\x90a;fV[\x93\x92\x91\x84aU\xC5V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm$\xB7;0\xB64\xB2\x107:\xB6\xB12\xB9`\x91\x1B`D\x82\x01R`d\x90\xFD[P`\x01aU\xB0V[d\x01\0\0\x03\xD0\x19\x14\x15\x90P8aU\xA9V[\x91\x93\x92\x91\x84\x15\x15\x83\x86\x82aW'W[PP\x80aW\x1EW[\x15aVMW`\0\x94\x83\x15\x90\x81\x85`\x01\x83[aV\xE1WPPPPaT\xF3W\x82\x90\x81\x80\x87\x80\t\x80\x92\t\x95\t\x90\t\x90V[aV\xEE\x84\x83\x9B\x95\x9BaU\x08V[\x91\x81\x93aT\xF3WaV>\x89aW\t\x81aW\x16\x95\x87\t\x82a;fV[`\0\x97\x08\x94\x9B\x80\x94a3VV[\x92\x91\x83aV\xC4V[P\x82\x15\x15aV\xB3V[\x14\x15\x90P\x838aV\xABV[\x15aW9WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FUse jacDouble function instead\0\0`D\x82\x01R`d\x90\xFD[\x93\x91\x90\x94\x92\x84\x15\x80aY\x0CW[aY\0W\x81\x15\x80aX\xF8W[aX\xEDWaW\xA3a<\x18V[\x95\x83\x15aT\xF3W\x83\x80\x93\x81`\x01\x80\t\x80\x8AR\x98\x82\x80\x8B`\x01\t\x94` \x83\x01\x95\x86R`@\x83\x01\x8C\x81R\x9A\x82\x80\x8E`\x01\t\x91``\x86\x01\x92\x83RaW\xE4`\x80a\x1C/V[\x9DQ\x90\t\x8CRQ\x90\t` \x8A\x01RQ\x90\t`@\x87\x01RQ\x90\t``\x84\x01R\x82Q\x93`@\x84\x01\x94\x85Q\x14\x80\x15\x90aX\xDBW[aX\x1E\x90aW2V[\x81aX'a<\x18V[\x95QaX4\x86Q\x83a;fV[\x90\x08\x85R\x81``\x85\x01QaX\xD0\x82\x88\x81\x80` \x8B\x01\x95aXU\x87Q\x83a;fV[\x90\x08\x99` \x83\x01\x9A\x8BR\x81\x80\x8C\x81\x80\x80\x80\x89Q\x8AQ\x90\t\x93`@\x8A\x01\x94\x85RaX\x85\x82\x86Q\x8CQ\x90\t\x9A``\x01\x90V[\x99\x8ARQ\x80\taX\x96\x89Q\x83a;fV[\x90\x08aX\xAC\x82\x80\x88Q\x86Q\x90\t`\x02\t\x83a;fV[\x90\x08\x9DQ\x93Q\x90Q\x90\taX\xC0\x8D\x83a;fV[\x90\x08\x90\t\x93Q\x90Q\x90\t\x83a;fV[\x90\x08\x94Q\t\x91\x92\x91\x90V[P` \x84\x01Q``\x85\x01Q\x14\x15aX\x15V[PPP\x90\x91\x90`\x01\x90V[P\x80\x15aW\x97V[\x90\x94P\x92P`\x01\x91\x90PV[P\x85\x15aW\x8BV[\x96\x94\x96\x95\x93\x90\x91\x95\x80\x15\x80aZ\xA0W[aZ\x94W\x83\x15\x80aZ\x8CW[aZ\x81WaY<a<\x18V[\x92\x85\x15aT\xF3W\x88\x94\x86\x94\x85\x80\x93\x81\x8C\x80\t\x83R\x81\x83Q\x8D\t\x95` \x84\x01\x96\x87R\x82\x80`@\x86\x01\x9B\x81\x81\x80\t\x80\x8ER\x90\t\x91``\x86\x01\x92\x83RaY\x7F`\x80a\x1C/V[\x9BQ\x90\t\x8ARQ\x90\t` \x88\x01RQ\x90\t`@\x85\x01RQ\x90\t``\x82\x01R\x81\x81Q\x95aY\xAB\x83`@\x01\x90V[\x96\x87Q\x14\x80\x15\x90aZoW[aY\xC0\x90aW2V[\x81aY\xC9a<\x18V[\x97QaY\xD6\x85Q\x83a;fV[\x90\x08\x87R\x81``\x84\x01QaZb\x82\x8A\x81\x80` \x8A\x01\x95aY\xF7\x87Q\x83a;fV[\x90\x08\x98` \x83\x01\x99\x8AR\x81\x80\x8B\x81\x80\x80\x80\x89Q\x8AQ\x90\t\x93`@\x8A\x01\x94\x85RaZ'\x82\x86Q\x8CQ\x90\t\x9A``\x01\x90V[\x99\x8ARQ\x80\taZ8\x89Q\x83a;fV[\x90\x08aZN\x82\x80\x88Q\x86Q\x90\t`\x02\t\x83a;fV[\x90\x08\x9CQ\x93Q\x90Q\x90\taX\xC0\x8C\x83a;fV[\x90\x08\x96Q\x92\x96\x95\t\x90\t\x90V[P` \x83\x01Q``\x84\x01Q\x14\x15aY\xB7V[\x93PP\x94PP\x92\x91\x90V[P\x81\x15aY0V[P\x95\x94PP\x90P\x92\x91\x90V[P\x82\x15aY$V[\x93\x91\x93\x92\x90\x92\x81\x15aT\xF3W\x81\x80\x85\x80\t\x91\x81\x80\x80\x80`\x01\x80\t\x99\x81\x80\x80\x89\x88\t`\x04\t\x9B\x80\t\x90\t\x92\x80\t`\x03\t\x08\x82\x86\x80\x08\x83\x03\x83\x81\x11a&\xBCW\x83\x90\x81\x83\x80\t\x08\x80\x84\x03\x92\x84\x84\x11a&\xBCW\x84\x80\x91\x80\t`\x08\t\x84\x03\x84\x81\x11a&\xBCW\x84`\x01\x93\x81\x80\x96\x81\x95\x9B\x08\x90\t\x08\x94\t`\x02\t\x90V[\x90\x93\x91\x94\x92\x94\x80\x15a[\x9BW\x82\x15aT\xF3W\x82\x80\x86\x80\t\x92\x81\x80\x80\x80\x86\x80\t\x9A\x81\x80\x80\x8A\x88\t`\x04\t\x9C\x80\t\x90\t\x92\x80\t`\x03\t\x08\x91\x83\x87\x80\x08\x84\x03\x84\x81\x11a&\xBCW\x84\x90\x81\x85\x80\t\x08\x90\x81\x85\x03\x90\x85\x82\x11a&\xBCW\x85\x80\x91\x80\t`\x08\t\x85\x03\x90\x85\x82\x11a&\xBCW\x85\x94\x85\x80\x94\x92\x81\x93\x9B\x08\x90\t\x08\x94\t`\x02\t\x90V[\x90\x94P\x91\x90PV[\x15a[\xAAWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FEllipticCurve: modulus is zero\0\0`D\x82\x01R`d\x90\xFD[a[\xF9`\x01a[\xA3V[\x80\x15aN\xD0W\x81\x15a\\\x90W`\x01\x91`\x01`\xFF\x1B\x91\x90\x82[a\\\x1BWPPP\x90V[\x90\x91\x92d\x01\0\0\x03\xD0\x19\x90\x84\x83\x16\x15\x15\x84\n\x90d\x01\0\0\x03\xD0\x19\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x01\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x02\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x03\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\t\x92`\x04\x1C\x91\x90\x82a\\\x11V[PP`\x01\x90V\xFE\xA2dipfsX\"\x12 \x8BNh\xC1\xC7w\xD9U3k\xE7\x8B\x0E$\x97!\xA2\x06f\x14/\xDE\xD4\xCA(`$\xA6?\x85\xFCOdsolcC\0\x08\x1C\x003\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0qZ\xD5\xCEa\xFC\x95\x95\xC7\xB4\x15(\x9DY\xCF ?#\xA9O\xA0o\x04\xAF~H\x9A\nv\xE1\xFE&",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436101561001257600080fd5b60003560e01c8063028995cd1461044d57806305a835bf146104485780630b12e4ba146104435780630ebbcfb51461043e578063162fc30114610439578063183a4f6e14610434578063193ccb61146103da5780631c10893f1461042f5780631cd64df41461042a5780631e464309146104255780631fda9a021461042057806321dd95761461041b57806323a8c4ba14610416578063254a39fe14610411578063256929621461040c5780632c2aab41146103ee5780632de948071461040757806331052c301461040257806333e7977a146103fd57806336339388146103f8578063397606c0146103f35780633b66f1c0146103ee5780633db132b1146103e9578063435c0298146103e4578063436cfb9b146103df5780634419df3a146103da5780634a4ee7b1146103d557806350f1c55a146103d0578063514e62fc146103cb57806352a5f1f8146103c657806354d1f13d146103c15780635bbe0694146103bc57806365835e5a146103b757806367f188b7146103b25780636a411b0c146103ad5780636f59232f146103a8578063715018a6146103a35780638228b1e21461039e5780638a95e6df146103995780638d3e445a146103945780638da5cb5b1461038f5780638eaa495d1461038a5780639171e5581461038557806394c593141461038057806394e7ecfb1461037b57806398e5030a146103765780639dcc21bd14610371578063a1bdc6081461036c578063aab586c214610367578063ace3a15314610362578063afb218f51461035d578063b516105c14610358578063b6f9005414610353578063bad018991461034e578063bc3f1f0a14610349578063c0a7795214610344578063d0be0b9c1461033f578063d9fb3aba1461033a578063de85843714610335578063e1fa8e8414610330578063e243adbf1461032b578063ebe93caf14610326578063ecc0448514610321578063f04e283e1461031c578063f2fde38b14610317578063f7d2467314610312578063f98118d51461030d5763fee81cf41461030857600080fd5b613180565b613154565b6130f2565b6130b2565b61305e565b612f87565b612f17565b612efb565b612df9565b612dcd565b612cfe565b612b11565b612ad6565b6128be565b612879565b61284a565b6127ac565b612767565b6126c1565b6125ee565b612592565b612425565b612354565b612338565b612207565b61215e565b612138565b61210b565b612088565b61202b565b611fcf565b611f83565b611ef1565b611ec4565b611de7565b6117ed565b6116d4565b611682565b611582565b61152c565b6113d6565b6113aa565b610d81565b611384565b61134b565b6112b0565b610feb565b61123d565b6111f8565b6111b3565b6110ab565b611011565b610f9f565b610f81565b610f4b565b610ebf565b610e7a565b610e5c565b610e16565b610dae565b610d67565b610cda565b610871565b610845565b610488565b610462565b600091031261045d57565b600080fd5b3461045d57600036600319011261045d57602061047d6131b7565b60ff60405191168152f35b3461045d57602036600319011261045d576004356104a461439b565b6104ad816143f0565b60068101805460ff1916600217905590600091826104ca83614361565b91909115610836576104da61326a565b91855b60ff8116916005831080610829575b8061081c575b156106b757604080516020810192835260f884901b6001600160f81b0319169181019190915261052f81604181015b03601f198101835282611bde565b51902091610549610544600685065b60ff1690565b613301565b9261052161058261055985613301565b604080516020810195865260f89290921b6001600160f81b031916908201529182906041820190565b519020926105956105446006860661053e565b985b60ff8a1660ff8316146106355760ff8a1660ff831611908160001461061457916105f861060f9594926105ef6105cf610609966132da565b9d5b6105e56105dc611bff565b60ff9096168652565b60ff166020850152565b15156040830152565b6106028289613327565b5286613327565b506132da565b6104dd565b9995916105f861060f9594926105ef61062f610609966132da565b996105d1565b98505091604051610661816105216020820194856026918152651c995c9bdb1b60d21b60208201520190565b519020916106746105446006850661053e565b9260405161069e816105216020820194856027918152663932b937b6361960c91b60208201520190565b519020926106b16105446006860661053e565b98610597565b505050939160ff6106c88685613313565b16936106d38561328f565b9360005b60ff8116878110156107105760ff91610708826106f66001948a613327565b51610701828c613327565b5289613327565b5001166106d7565b50506107d3600161078560029360ff808c61072e8c60078c0161336d565b60088a8101805460ff871661ffff19909116179183901b61ff0016919091179055169116119560009661076e84830154600052600e602052604060002090565b6107788154613449565b9055610798846002840160005b500154600052600e602052604060002090565b6107a28154613449565b9055801561080e57836107ba816107858b5b86613435565b016107c58154613449565b905515610807578290613435565b016107de8154613449565b90557f31543961bad6e1b886fe4b3c060d3d97c21fbc80e63ab22e9eea65d9d2dc7c778280a280f35b8690613435565b836107ba81610785816107b4565b50600360ff8516106104f2565b50600360ff8916106104ec565b6332926edd60e01b8552600485fd5b3461045d57600036600319011261045d576020610860613470565b6001600160801b0360405191168152f35b602036600319011261045d5760043561088861439b565b61089181614472565b61089961382b565b5050803410610cc2575060068101805460ff191660011790556108db90600a81015481546002909201546001600160a01b039283169083161890911683181890565b6108e361439b565b6108eb614621565b8115610cb15760ff61091161090a846000526007602052604060002090565b5460ff1690565b16610c9b577f0000000000000000000000000000000000000000000000000000000000000000610c80575b349061094661382b565b9291803410610c68575060015460ff16610b19575b505060015460081c60ff16610a0c575b505060015460101c60ff166109ac575b6109856001600055565b7f50ad08f58a27f2851d7e3a1b3a6a46b290f2ce677e99642d30ff639721e77790600080a2005b6109df6109c3826000526007602052604060002090565b60046109d0825460ff1690565b1760ff1660ff19825416179055565b6004817f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a361097b565b610a30610a23846000526007602052604060002090565b60026109d0825460ff1690565b610b0a575b5060405163d845a4b360e01b8152620186a0600482015260208160248160006001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165af1908115610b05578291610aa691600091610ad6575b506000526006602052604060002090565b556002817f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a3388061096b565b610af8915060203d602011610afe575b610af08183611bde565b810190614194565b38610a95565b503d610ae6565b613464565b610b139061352c565b38610a35565b610ba29293506001600160801b03602091610b4e610b41886000526007602052604060002090565b60016109d0825460ff1690565b6040516319cb825f60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016600482015260248101949094529293921691839081906044820190565b0381847f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af18015610b0557610c028591610c0994600091610c39575b506001600160401b03166000526005602052604060002090565b5534613b66565b906001837f3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910600080a3388061095b565b610c5b915060203d602011610c61575b610c538183611bde565b810190614549565b38610be8565b503d610c49565b63a458261b60e01b6000523460045260245260446000fd5b80610c95836000526009602052604060002090565b5561093c565b636ae0096760e01b600052600482905260246000fd5b6341abc80160e01b60005260046000fd5b63a458261b60e01b6000523460045260245260446000fd5b3461045d5760006020366003190112610d6457600435610cf861439b565b817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b15610d6257602460405180948193634ffd2e4360e01b83523060048401525af18015610b05578290610d545780f35b610d5d91611bde565b388180f35b505b80fd5b602036600319011261045d57610d7f60043533614d91565b005b3461045d57600036600319011261045d57602060405160038152f35b6001600160a01b0381160361045d57565b604036600319011261045d57600435610dc681610d9d565b60243590610dd26143b7565b638b78c6d8600c526000526020600c2090815417809155600c5160601c7f715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26600080a3005b3461045d57604036600319011261045d576020610e52600435610e3881610d9d565b602435918291638b78c6d8600c526000526020600c205490565b1614604051908152f35b3461045d57600036600319011261045d576020600454604051908152f35b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d5760006020366003190112610d645780600435610ede61439b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690813b15610f4757604051632465f8f560e01b8152336004820152602481019190915291908290604490829084905af18015610b05578290610d545780f35b5050fd5b3461045d57602036600319011261045d576080610f69600435613618565b91604051938452602084015260408301526060820152f35b3461045d57600036600319011261045d576020600f54604051908152f35b600036600319011261045d5763389a75e1600c52336000526202a30042016020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a2005b3461045d57602036600319011261045d576020611009600435613793565b604051908152f35b3461045d57602036600319011261045d57602061100960043561103381610d9d565b638b78c6d8600c526000526020600c205490565b602060408183019282815284518094520192019060005b81811061106b5750505090565b90919260206110a1600192865190604060609260018060a01b038151168352602081015115156020840152015160408201520190565b940192910161105e565b3461045d57602036600319011261045d57600435801580156111a8575b611197576110e2600491600052600b602052604060002090565b0180546110ee81613727565b9160005b82811061110b57604051806111078682611047565b0390f35b8061112961111b60019385613777565b50546001600160a01b031690565b6111416111368386613777565b505460a01c60ff1690565b6111768461114f8588613777565b5001549161116d61115e611bff565b6001600160a01b039095168552565b15156020840152565b60408201526111858287613327565b526111908186613327565b50016110f2565b635df626e160e11b60005260046000fd5b50600a5481116110c8565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d57602036600319011261045d57600435611259613227565b50600052600e602052604060002060026040519161127683611b6b565b8054835260018101546020840152015460408201526040518091604060608301918051845260208101516020850152015160408301520390f35b3461045d57600036600319011261045d576112c96143b7565b47801561130e576000808080610d7f94335af13d15611309573d6112ec81611ce0565b906112fa6040519283611bde565b8152600060203d92013e6137df565b6137df565b60405162461bcd60e51b815260206004820152601560248201527427379022aa2417a226aa103a37903932b1b7bb32b960591b6044820152606490fd5b3461045d57600036600319011261045d5760606001600160801b0361136e61382b565b9192906040519384521660208301526040820152f35b3461045d57600036600319011261045d57602060ff60015460081c166040519015158152f35b604036600319011261045d57610d7f6004356113c581610d9d565b602435906113d16143b7565b614d91565b3461045d57604036600319011261045d576004356113f381610d9d565b602435906113ff6143b7565b6040516331a9108f60e11b8152600481018390526001600160a01b03919091169190602081602481865afa90816114ff575b506114a757507fb398ca235b3eff2f67e7270724650d13e47cd5f9dac13b9187ed81b127ce24c7604051806114a28160809060208152602160208201527f4e6f7420616e20455243373231206f7220696e76616c696420746f6b656e20496040820152601160fa1b60608201520190565b0390a2005b90803b1561045d57604051632142170760e11b815230600482015233602482015260448101929092526000908290606490829084905af18015610b05576114ea57005b806114f96000610d7f93611bde565b80610452565b6115209060203d602011611525575b6115188183611bde565b810190613922565b611431565b503d61150e565b3461045d57604036600319011261045d57602060043561154b81610d9d565b61156660243591638b78c6d8600c526000526020600c205490565b161515604051908152f35b6001600160401b0381160361045d57565b3461045d57606036600319011261045d5760043561159f81611571565b6115aa602435610d9d565b6044357f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316801561163d5733036115ec57610d7f9161459d565b60405162461bcd60e51b815260206004820152602360248201527f4f6e6c7920456e74726f70792063616e2063616c6c20746869732066756e637460448201526234b7b760e91b6064820152608490fd5b60405162461bcd60e51b815260206004820152601760248201527f456e74726f70792061646472657373206e6f74207365740000000000000000006044820152606490fd5b600036600319011261045d5763389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2005b8015150361045d57565b3461045d57608036600319011261045d576024356004356116f482610d9d565b60443590611701826116ca565b6064359161170d61439b565b61171682614472565b83156117dc577f4af71b021e799c62c158bd54636ca8da2fa26115a21a2dc6efe486ec104fd15f916117d79160099061177a87308a7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166145bf565b6117ac60405161178981611b6b565b6001600160a01b038a168152841515602082015288604082015260048301613975565b016117b8868254613457565b90556040519485521515946001600160a01b0316939081906020820190565b0390a4005b63162908e360e11b60005260046000fd5b3461045d57602036600319011261045d57600435611809614621565b61181161439b565b61182261181d826144dc565b613a90565b9061183160a083015160ff1690565b60ff61184461053e60c086015160ff1690565b911611600090600014611b50575060015b6118626040840151613340565b926000809460e08301519561187686613618565b90918a15159384611b46575b5083611b3c575b508715611b345750905b60105460ff16611aea575b6118c560066118b78a600052600b602052604060002090565b01805460ff19166003179055565b6118ce88614e2f565b5085517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169461192e916119289061191a908b15611ae15760ff60005b1690613b73565b51516001600160a01b031690565b866146c1565b611a57575085965061195561195060809697600052600b602052604060002090565b614747565b60105460ff8116611a2e575b505050500180515160ff1690611975613b84565b9360ff60009316925b60ff8116848110156119b85760ff916119b08261199e6001948851613327565b516119a9828c613b9d565b5289613b9d565b50011661197e565b86838715611a04577f8ef01de748555cd1d5431d653dab86432a1d7d75096621deca7a6e4b414de63660ff60005b6119f7604051928392169582613bae565b0390a3610d7f6001600055565b7f8ef01de748555cd1d5431d653dab86432a1d7d75096621deca7a6e4b414de63660ff60016119e6565b611a4e93611a489160081c6001600160a01b031692613457565b916146c1565b38808080611961565b602085015180519160005b838110611a785750505050608094959650611955565b80611a926020611a8a60019487613327565b510151151590565b8a151590151503611aa4575b01611a62565b611adc611ac98d611ac3866040611abb878b613327565b51015161455e565b90614717565b611ad661191a8488613327565b896146c1565b611a9e565b60ff6001611913565b979291509250600f5492611afe8483614643565b938815611b2957611b12611b239185614643565b611b1d868295613b66565b94613b66565b9761189e565b50611b236000611b12565b905090611893565b1515925038611889565b1515935038611882565b611855565b634e487b7160e01b600052604160045260246000fd5b606081019081106001600160401b03821117611b8657604052565b611b55565b604081019081106001600160401b03821117611b8657604052565b61010081019081106001600160401b03821117611b8657604052565b61012081019081106001600160401b03821117611b8657604052565b90601f801991011681019081106001600160401b03821117611b8657604052565b60405190611c0e606083611bde565b565b60405190611c0e61012083611bde565b60405190611c0e604083611bde565b90611c0e6040519283611bde565b919060405192611c4e608085611bde565b83906080810192831161045d57905b828210611c6957505050565b8135815260209182019101611c5d565b91906040805193611c8a8286611bde565b8491810192831161045d57905b828210611ca357505050565b8135815260209182019101611c97565b806083121561045d57611cc7906064611c3d565b90565b80610143121561045d57611cc790610124611c3d565b6001600160401b038111611b8657601f01601f191660200190565b81601f8201121561045d57803590611d1282611ce0565b92611d206040519485611bde565b8284526020838301011161045d57816000926020809301838601378301015290565b9060a060031983011261045d57816023121561045d57611d63826004611c3d565b91608435906001600160401b03821161045d57611cc791600401611cfb565b906000905b60028210611d9457505050565b6020806001928551815201930191019091611d87565b60409093929193611dbf8160c0810196611d82565b016000905b60048210611dd157505050565b6020806001928551815201930191019091611dc4565b3461045d57611df536611d42565b906111076040808051611e088282611bde565b3690376080808251611e1a8282611bde565b369037611e41611e28613c28565b95611e31613c03565b50611e3a613c18565b5086614f23565b94611ea9611e90611e786060840198611e6f8a51611e5f8760400190565b80518e51919e6020015192614ffc565b96909a516150a5565b9390995190611e8981519160200190565b51916150a5565b949093611e9c87611c2f565b9889526020890152611c2f565b96875260208701528286015260608501525192839283611daa565b3461045d57600036600319011261045d5760105460405160089190911c6001600160a01b03168152602090f35b60c036600319011261045d57366023121561045d5760408051611f148282611bde565b803660841161045d576004905b60848210611f4b5761110784611f3c60a43560843587613c5e565b90519081529081906020820190565b838236031261045d57602084918251611f6381611b8b565b8435611f6e81610d9d565b81528285013583820152815201910190611f21565b600036600319011261045d57611f976143b7565b6000638b78c6d819547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a36000638b78c6d81955005b3461045d57602036600319011261045d57600435611feb61439b565b80600052600760205260ff604060002054161561200457005b7f6248d5a209702db872b83045d56e4baf48362ce7a7cda285a671e7c1e63f44b9600080a2005b3461045d57600036600319011261045d57602060ff600154166040519015158152f35b602060408183019282815284518094520192019060005b8181106120725750505090565b8251845260209384019390920191600101612065565b3461045d57600036600319011261045d57604051806020600c54918281520190600c6000527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c79060005b8181106120f557611107856120e981870382611bde565b6040519182918261204e565b82548452602090930192600192830192016120d2565b3461045d57600036600319011261045d57638b78c6d819546040516001600160a01b039091168152602090f35b3461045d57600036600319011261045d57602060ff60015460101c166040519015158152f35b3461045d57600036600319011261045d576020600a54604051908152f35b611c0e9092919260e08061010083019560018060a01b0381511684526001600160401b03602082015116602085015263ffffffff6040820151166040850152606081015160608501526121df608082015160808601906001600160401b03169052565b60a0818101516001600160a01b03169085015260c08181015115159085015201511515910152565b3461045d57602036600319011261045d576122bc61010060043561222a81611571565b600060e060405161223a81611ba6565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260405180938192636151ab1f60e01b83527f0000000000000000000000000000000000000000000000000000000000000000600484019092916001600160401b03602091604084019560018060a01b0316845216910152565b03817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015610b055761110791600091612309575b506040519182918261217c565b61232b91506101003d8111612331575b6123238183611bde565b810190614062565b386122fc565b503d612319565b3461045d57600036600319011261045d57602060405160098152f35b3461045d57602036600319011261045d57600435612371816116ca565b60408051631fc50ef560e31b81523060048201526000929091826024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610b0557839284926123e3575b5060209350156123dd5761100991613b66565b50611009565b925090506040823d60401161241d575b8161240060409383611bde565b81010312612419579160209283835193015191936123ca565b8280fd5b3d91506123f3565b3461045d57602036600319011261045d5760043561244281610d9d565b61244a6143b7565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811691908116908183036124dc5750506040516370a0823160e01b815230600482015290602082602481845afa908115610b0557610d7f926000926124bb575b5033906146c1565b6124d591925060203d602011610afe57610af08183611bde565b90386124b3565b6040516370a0823160e01b815230600482015291925090602081602481865afa60009181612571575b5061255c5750507fb398ca235b3eff2f67e7270724650d13e47cd5f9dac13b9187ed81b127ce24c7604051806114a28160609060208152600c60208201526b04e6f7420616e2045524332360a41b60408201520190565b8091925061256657005b610d7f9133906146c1565b61258b91925060203d602011610afe57610af08183611bde565b9038612505565b3461045d57602036600319011261045d576125be6004356125b1614621565b6125b961439b565b6141a3565b6001600055005b806023121561045d57611cc7906004611c79565b80610103121561045d57611cc79060e4611c79565b3461045d57604036600319011261045d57612608366125c5565b6126106143d4565b60045461384081018091116126bc57421061266d57612668816126537fc6a468b84385cd4dfc440db21d0df6f03612ba43b35efe190dee993b466a5198936142ad565b61265c42600455565b604051918291826142d1565b0390a1005b60405162461bcd60e51b815260206004820152602160248201527f4b6579206368616e676520636f6f6c646f776e3a2077616974203420686f75726044820152607360f81b6064820152608490fd5b6132c4565b3461045d57602036600319011261045d5760043560ff8116810361045d577fa18893a16b818f3e8c53189231250cb02bb55cb32802a6d5c2b5eb856cdb7f1e906127096143b7565b6127116131b7565b6001805461ffff1916908316151560ff161760028316151560081b61ff00161762ff0000191660048316151560101b62ff000016176001556040805160ff92831681529190921660208201529081908101612668565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d576111076127fd6001600160801b0361283261282c6127ce36611d42565b94906127e26127db613c28565b9687614f23565b92909660608301519060408401516020825192015192614ffc565b9060608301519760408401986128208a519186516020880193898686519461508e565b96909551915192615132565b60801c90565b91516040519190921690911481529081906020820190565b3461045d57608036600319011261045d57366023121561045d576020611009612874366004611c3d565b6142e1565b3461045d57600036600319011261045d576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461045d576101a036600319011261045d576004356024356001600160401b03811161045d576128f2903690600401611cfb565b604435906128ff36611cb3565b612908366125d9565b61291136611cca565b9061291a6143d4565b600460ff61293561090a896000526007602052604060002090565b1603612a6b5761294486613793565b61294d8561433e565b6040516129668161052160208201948560209181520190565b519020906040516129838161052160208201948560209181520190565b51902003612a345784612995846142e1565b036129fd576129b3936129af936129aa613c28565b614920565b1590565b6129c15781610d7f92614a29565b604051631f7b49ed60e31b81526020600482015260136024820152721d995c9a599a58d85d1a5bdb8819985a5b1959606a1b6044820152606490fd5b604051631f7b49ed60e31b815260206004820152600e60248201526d0e0e4dedecc40dad2e6dac2e8c6d60931b6044820152606490fd5b604051631f7b49ed60e31b815260206004820152600e60248201526d0c2d8e0d0c240dad2e6dac2e8c6d60931b6044820152606490fd5b60405162461bcd60e51b815260206004820152603d60248201527f534156206d757374206265206c6173742063616c6c6261636b3a206f7468657260448201527f2070726f7669646572732068617665206e6f7420636f6d706c657465640000006064820152608490fd5b3461045d57602036600319011261045d57600435612af26143b7565b610bb88111612b0057600f55005b63b4fa3fb360e01b60005260046000fd5b3461045d57602036600319011261045d576004356000526007602052604060ff81600020541681519080151582526020820152f35b906000905b60028210612b5857505050565b825180516001600160a01b0316825260209081015182820152600191604001930191019091612b4b565b906020808351928381520192019060005b818110612ba05750505090565b9091926020612bd6600192865190604060609260018060a01b038151168352602081015115156020840152015160408201520190565b9401929101612b93565b60051115612bea57565b634e487b7160e01b600052602160045260246000fd5b906005821015612bea5752565b906020808351928381520192019060005b818110612c2b5750505090565b9091926020612c5f600192865190604060609260ff815116835260ff60208201511660208401520151151560408201520190565b9401929101612c1e565b60208152612c7b602082018351612b46565b610180610100612cce612c9d60208601518460a08701526101a0860190612b82565b604086015160c0860152612cb9606087015160e0870190612c00565b6080860151858203601f190184870152612c0d565b60a085015160ff166101208501529360c081015160ff1661014085015260e0810151610160850152015191015290565b3461045d57602036600319011261045d57600435604051612d1e81611bc2565b6040908151612d2d8382611bde565b60005b838110612dab5750816101009160009352606060208201528284820152826060820152606060808201528260a08201528260c08201528260e0820152015281158015612da0575b61119757612d9561181d61110793600052600b602052604060002090565b905191829182612c69565b50600a548211612d77565b6020908451612db981611b8b565b600081526000838201528184015201612d30565b3461045d57602036600319011261045d576040612deb600435614361565b825191825215156020820152f35b3461045d57602036600319011261045d57600435604051636eb1769f60e11b8152336004820152306024820152602081806044810103817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610b0557600091612edc575b5060001911612e9d5733907ff62ba47fe3ff610889160f02571396e86e21b7aadcbde2719192e206853b331f600080a3005b6040516310d05f1160e21b8152602060048201526016602482015275496e73756666696369656e7420616c6c6f77616e636560501b6044820152606490fd5b612ef5915060203d602011610afe57610af08183611bde565b38612e6b565b3461045d57600036600319011261045d57602060405160058152f35b3461045d57604036600319011261045d576004356024357f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303612f765781610d7f926000526006602052604060002054614baf565b635c427cd960e01b60005260046000fd5b3461045d57602036600319011261045d57600435612fa4816116ca565b60405163127e8e4d60e01b8152620186a06004820152906020826024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa918215610b055760009261303d575b50819015613010575b604051908152602090f35b506130196140f8565b9080821061302c57505060206000613005565b60209161303891613b66565b613005565b61305791925060203d602011610afe57610af08183611bde565b9038612ffc565b602036600319011261045d5760043561307681610d9d565b61307e6143b7565b63389a75e1600c52806000526020600c2090815442116130a4576000610d7f92556148b7565b636f5e88186000526004601cfd5b602036600319011261045d576004356130ca81610d9d565b6130d26143b7565b8060601b156130e457610d7f906148b7565b637448fbae6000526004601cfd5b3461045d57602036600319011261045d5760043561310f81610d9d565b6131176143b7565b60108054610100600160a81b03191660089290921b610100600160a81b0316919091179055005b634e487b7160e01b600052603260045260246000fd5b3461045d57602036600319011261045d57600435600281101561045d5760209060020154604051908152f35b3461045d57602036600319011261045d5760043561319d81610d9d565b63389a75e1600c52600052602080600c2054604051908152f35b600060015460ff81166131ef575b60ff8160081c166131e4575b60101c60ff166131de5790565b60041790565b6002909117906131d1565b600191506131c5565b906005811015612bea5760ff80198354169116179055565b6001600160401b038111611b865760051b60200190565b6040519061323482611b6b565b60006040838281528260208201520152565b60005b82811061325557505050565b602090613260613227565b8184015201613249565b6040519060c061327a8184611bde565b60058352611c0e90601f190160208401613246565b90611c0e61329c83613210565b6132a96040519182611bde565b838152602081946132bc601f1991613210565b019101613246565b634e487b7160e01b600052601160045260246000fd5b60ff1660ff81146126bc5760010190565b634e487b7160e01b600052601260045260246000fd5b60ff60019116019060ff82116126bc57565b9060ff8091169116019060ff82116126bc57565b805182101561333b5760209160051b010190565b61313e565b908160011b91808304600214901517156126bc57565b818102929181159184041417156126bc57565b9055565b815191600160401b8311611b8657815483835580841061340c575b50602061339c910191600052602060002090565b6000915b8383106133ad5750505050565b6001602082613400839451868151815460ff191660ff91909116178155906040906020810151835461ff00191660089190911b61ff00161791015162ff00001990911690151560101b62ff000016179055565b019201920191906133a0565b8260005283602060002091820191015b8181106134295750613388565b6000815560010161341c565b90600281101561333b5760011b0190600090565b90600182018092116126bc57565b919082018092116126bc57565b6040513d6000823e3d90fd5b604051631711922960e31b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602090829060249082907f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b05576000916134ed575090565b6020813d602011613524575b8161350660209383611bde565b81010312610d625751906001600160801b0382168203610d64575090565b3d91506134f9565b61353461439b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b1561045d57600090602460405180948193634ffd2e4360e01b83523060048401525af18015610b05576135905750565b6000611c0e91611bde565b9081546135a781613210565b926135b56040519485611bde565b818452602084019060005260206000206000915b8383106135d65750505050565b600260206001926040516135e981611b6b565b60ff8654868060a01b038116835260a01c161515838201528486015460408201528152019201920191906135c9565b801580156136e2575b61119757600461363e61364492600052600b602052604060002090565b0161359b565b805160009291839182915b8183106136905750505080151580613687575b1561367f57613671838261455e565b9261367c828261455e565b92565b600092600092565b50821515613662565b9091926136a56129af6020611a8a8786613327565b156136c75760019060406136b98685613327565b51015101935b01919061364f565b929460019060406136d88885613327565b51015101956136bf565b50600a548111613621565b604051906136fc602083611bde565b600080835282815b82811061371057505050565b60209061371b613227565b82828501015201613704565b9061373182613210565b61373e6040519182611bde565b828152809261374f601f1991613210565b019060005b82811061376057505050565b60209061376b613227565b82828501015201613754565b805482101561333b5760005260206000209060011b0190600090565b801580156137d4575b611197576000818152600b60205260409020600a81015481546002909201546001600160a01b03928316908316189091169091181890565b50600a54811161379c565b156137e657565b60405162461bcd60e51b815260206004820152601760248201527f4554482f444d54207472616e73666572206661696c65640000000000000000006044820152606490fd5b60009060009060015460ff8116613903575b60081c60ff16613861575b6001600160801b0383168281018091116126bc57929190565b60405163127e8e4d60e01b8152620186a060048201529091506020816024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa908115610b05576000916138e4575b506138c46140f8565b8181106138d657505060005b90613848565b6138df91613b66565b6138d0565b6138fd915060203d602011610afe57610af08183611bde565b386138bb565b925060ff61390f613470565b93905061383d565b5190611c0e82610d9d565b9081602091031261045d5751611cc781610d9d565b8151815460208401516001600160a01b039092166001600160a81b03199091161790151560a01b60ff60a01b16178155604090910151600190910155565b8054600160401b811015611b865761399291600182018155613777565b9190916139a257611c0e91613937565b634e487b7160e01b600052600060045260246000fd5b90604051916139c683611b8b565b6000835b600282106139d757505050565b600260206001926040516139ea81611b8b565b848060a01b03875416815284870154838201528152019301910190916139ca565b6005821015612bea5752565b908154613a2381613210565b92613a316040519485611bde565b818452602084019060005260206000206000915b838310613a525750505050565b600160208192604051613a6481611b6b565b60ff86548181168352818160081c168584015260101c1615156040820152815201920192019190613a45565b90600a613a9b611c10565b92613aa5816139b8565b8452613ab36004820161359b565b602085015260058101546040850152613adc613ad3600683015460ff1690565b60608601613a0b565b613ae860078201613a17565b6080850152613b22613b186008830154613b0f613b058260ff1690565b60ff1660a0890152565b60081c60ff1690565b60ff1660c0860152565b600981015460e08501520154610100830152565b70014551231950b75fc4402da1732fc9bebe19039070014551231950b75fc4402da1732fc9bebe1982116126bc57565b919082039182116126bc57565b90600281101561333b5760051b0190565b60405190611c0e60a0613b978185611bde565b83613246565b90600581101561333b5760051b0190565b91906101e08301926000905b60058210613bc757505050565b6020613bf8600192855190604060609260ff815116835260ff60208201511660208401520151151560408201520190565b930191019091613bba565b604090815191613c138184611bde565b368337565b604051906080613c138184611bde565b6040519060026000835b60028210613c4857505050611c0e604083611bde565b6001602081928554815201930191019091613c32565b91613c6761439b565b613c7183516147c8565b6020830191613c8083516147c8565b60208451015160208451015114612b0057613e0593613e197fd478fa2472011ca0798d35115fc3caa7268c49cb7dc88a2518344fc9631bbf2c93613d1a8460018060a01b037f000000000000000000000000000000000000000000000000000000000000000016613d0582613cfd885160018060a01b0390511690565b3090846145bf565b8851513091906001600160a01b0316906145bf565b613d2d613d28600a54613e1f565b600a55565b600a54968796604092613d3f84611c2f565b8651519092906001600160a01b0316602088510151613d6e613d5f611c20565b6001600160a01b039093168352565b6020828101919091529084528151516001600160a01b031691510151613d95613d5f611c20565b60208201526020830152613da76136ed565b613daf61326a565b90613db8611c10565b93845260208401528785840152600060608401526080830152600060a0830152600060c0830152600060e0830152610100820152613e0088600052600b602052604060002090565b613f49565b613e0e866150b3565b505192839283613ff5565b0390a290565b60001981146126bc5760010190565b916133699183549060031b91821b91600019901b19161790565b906000905b60028210613e5a57505050565b8051805184546001600160a01b0319166001600160a01b0391909116178455600191600291602091908201518487015501930191019091613e4d565b815191600160401b8311611b86578154838355808410613ef4575b506020613ec5910191600052602060002090565b6000915b838310613ed65750505050565b6002602082613ee86001945186613937565b01920192019190613ec9565b6001600160ff1b03811681036126bc576001600160ff1b03841684036126bc578260005260206000209060011b8101908460011b015b818110613f375750613eb1565b60008082556001820155600201613f2a565b90610100600a91613f5b815185613e48565b613f6c602082015160048601613e96565b60408101516005850155613f906060820151613f8781612be0565b600686016131f8565b613fa160808201516007860161336d565b613fe460088501613fc9613fb960a085015160ff1690565b825460ff191660ff909116178255565b60c0830151815461ff00191660089190911b61ff0016179055565b60e081015160098501550151910155565b60a081019392916000825b600282106140115750505060800152565b825180516001600160a01b0316825260209081015182820152600191604001930191019091614000565b5190611c0e82611571565b519063ffffffff8216820361045d57565b5190611c0e826116ca565b908161010091031261045d576140f060e06040519261408084611ba6565b61408981613917565b84526140976020820161403b565b60208501526140a860408201614046565b6040850152606081015160608501526140c36080820161403b565b60808501526140d460a08201613917565b60a08501526140e560c08201614057565b60c085015201614057565b60e082015290565b60408051631fc50ef560e31b815230600482015290816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015610b0557600091829161415a575b5081039081116126bc5790565b90506040813d60401161418c575b8161417560409383611bde565b81010312610d62576020908051925001513861414d565b3d9150614168565b9081602091031261045d575190565b801580156142a2575b611197576141c481600052600b602052604060002090565b60068101906141d4825460ff1690565b916005820154926141e481612be0565b6003811490811561428e575b5061428857805460ff19166004179055614261916119509061421185614e2f565b5082546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169161424d91849116836146c1565b61425b60028501600061111b565b906146c1565b7fec5ea23f72a00a2e477d714dc012986271cd3c96ad95c7fe5f629ff79847fd21600080a2565b50505050565b6004915061429b81612be0565b14386141f0565b50600a5481116141ac565b60005b600281106142bc575050565b600190602083519301928160020155016142b0565b604081019291611c0e9190611d82565b600061432d6105216143216142fe602095868151910151906151ae565b604051607f60f91b87820152600360f81b602182015292839160228301906148f5565b604051918280926148f5565b039060025afa15610b055760005190565b602081519101519060208110614352575090565b6000199060200360031b1b1690565b9081600052600760205260ff60406000205416159160005260086020526040600020548280614393575b610cb1579190565b50801561438b565b638b78c6d8600c523360005260016020600c205416156143b757565b638b78c6d8195433036143c657565b6382b429006000526004601cfd5b638b78c6d8600c523360005260026020600c205416156143b757565b600081158015614467575b61445857818152600b602052604081209160ff600684015416915061441f82612be0565b6001820361442c57505090565b637765da3560e01b60005260045261444690602490612c00565b61445260446001612c00565b60646000fd5b635df626e160e11b8152600490fd5b50600a5482116143fb565b6000811580156144d1575b61445857818152600b602052604081209160ff60068401541691506144a182612be0565b816144ab57505090565b637765da3560e01b6000526004526144c590602490612c00565b61445260446000612c00565b50600a54821161447d565b60008115801561453e575b61445857818152600b602052604081209160ff600684015416915061450b82612be0565b6002820361451857505090565b637765da3560e01b60005260045261453290602490612c00565b61445260446002612c00565b50600a5482116144e7565b9081602091031261045d5751611cc781611571565b7812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f22811082021561458f57670de0b6b3a7640000020490565b637c5f487d6000526004601cfd5b906001600160401b03611c0e9216806000526005602052604060002054614ca0565b916040519360605260405260601b602c526323b872dd60601b600c52602060006064601c82855af190816001600051141615614602575b50506000606052604052565b3b153d1710156146135738806145f6565b637939f4246000526004601cfd5b600260005414614632576002600055565b633ee5aeb560e01b60005260046000fd5b8181029161271081838504148315170215614662575050612710900490565b61271090600019818409848110850190039209908061271011156146b357828211900360fc1b910360041c177fbc01a36e2eb1c432ca57a786c226809d495182a9930be0ded288ce703afb7e910290565b63ae47f7026000526004601cfd5b919060145260345263a9059cbb60601b600052602060006044601082855af1908160016000511416156146f8575b50506000603452565b3b153d1710156147095738806146ef565b6390b8ec186000526004601cfd5b9080600019048211614733575b670de0b6b3a764000091020490565b80156147245763bac65e5b6000526004601cfd5b6004614753910161359b565b8051907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169060005b8381106147915750505050565b6001906147c26001600160a01b036147a98386613327565b51511660406147b88487613327565b51015190866146c1565b01614784565b9060208201906147f460208351604051809381926331a9108f60e11b8352600483019190602083019252565b03817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa60009181614896575b506148565783518351630967a7eb60e11b6000526001600160a01b0390911660045260245260446000fd5b925190926001600160a01b03918216929116829003614873575050565b51630967a7eb60e11b6000526001600160a01b0390911660045260245260446000fd5b6148b091925060203d602011611525576115188183611bde565b903861482b565b60018060a01b031680638b78c6d819547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3638b78c6d81955565b9081519160005b83811061490d575050016000815290565b80602080928401015181850152016148fc565b929161492f9094919484614f23565b61493b86929660600190565b8051969061496a6129af60408601998a519961495981519160200190565b518a519160208c019c8d51946151e5565b908115614a0b575b5080156149de575b6149d2576001600160801b03956149ca956149b061282c9680519061499f8160200190565b516040820151916060015192615322565b9590946149bf82519260200190565b519251935194615132565b915191161490565b50505050505050600090565b50614a066129af885185516149f38760200190565b5160408901519160608a015b51936152b9565b61497a565b614a2391506129af9051865185856149ff8a60200190565b38614972565b91906004614a4461090a856000526007602052604060002090565b1615614b775750614a7e614a62836000526007602052604060002090565b6004614a6f825460ff1690565b1860ff1660ff19825416179055565b610521614ab6614a98846000526008602052604060002090565b54926040519283916020830195869091604092825260208201520190565b519020614acd826000526008602052604060002090565b556004817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b15614b185750565b807fb26fe08e4e51c01e5cffff5f4887249599779aa0d4f8636ff4e7cd4831b495ed600080a27f0000000000000000000000000000000000000000000000000000000000000000614b665750565b600090815260096020526040812055565b60405190815260049291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c009080602081015b0390a3565b91906002614bca61090a856000526007602052604060002090565b1615614c695750614bf5614be8836000526007602052604060002090565b6002614a6f825460ff1690565b610521614c0f614a98846000526008602052604060002090565b519020614c26826000526008602052604060002090565b556002817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b60405190815260029291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c00908060208101614baa565b91906001614cbb61090a856000526007602052604060002090565b1615614d5a5750614ce6614cd9836000526007602052604060002090565b6001614a6f825460ff1690565b610521614d00614a98846000526008602052604060002090565b519020614d17826000526008602052604060002090565b556001817fc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55600080a3614b1061053e61090a836000526007602052604060002090565b60405190815260019291507f2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c00908060208101614baa565b638b78c6d8600c526000526020600c2090815490811618809155600c5160601c7f715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26600080a3565b805482101561333b5760005260206000200190600090565b80548015614e19576000190190614e078282614dd8565b8154906000199060031b1b1916905555565b634e487b7160e01b600052603160045260246000fd5b6000818152600d6020526040902054908115614ed0576000198201908282116126bc57600c546000198101939084116126bc578383600095614e8f9503614e95575b505050614e7e600c614df0565b600d90600052602052604060002090565b55600190565b614e7e614ec191614eb7614ead614ec795600c614dd8565b90549060031b1c90565b928391600c614dd8565b90613e2e565b55388080614e71565b5050600090565b607f60f91b8152600160f81b6001820152611cc79291614efa91600201906148f5565b906148f5565b614f0d90600193926148f5565b60f89190911b6001600160f81b03191681520190565b614f3d614f4f91614f3681519160200190565b51906151ae565b61052160405193849260208401614ed7565b60005b61010060ff821610614fa35760405162461bcd60e51b815260206004820152601860248201527f4e6f2076616c696420706f696e742077617320666f756e6400000000000000006044820152606490fd5b60206000614fbe604051614321816105218789888401614f00565b039060025afa15610b0557600051614fd581615353565b90614fe082826153b6565b614ff4575050614fef906132da565b614f52565b939092509050565b6150619192936150596150537f483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b87f79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179861505395615512565b91615599565b959094615512565b6401000003d01903926401000003d01984116126bc5761508a936401000003d01990069261544f565b9091565b615053615053936150619596979361505993615512565b916150539161508a93615512565b80600052600d6020526040600020541560001461512c57600c54600160401b811015611b865760018101600c556000600c5482101561333b57600c90527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c701819055600c5490600052600d602052604060002055600190565b50600090565b93614efa600097614efa61517260209b61516c6151989b6151666143219b6151606105219b614efa9f6151ae565b9b6151ae565b976151ae565b936151ae565b604051607f60f91b8d820152600160f91b602182015298899791959160228901906148f5565b039060025afa15610b0557600051806040515290565b9060011660020190816002116126bc576040519160ff60f81b9060f81b166020830152602182015260218152611cc7604182611bde565b9160ff91602094600161521a6151ff6000979a999a613b36565b70014551231950b75fc4402da1732fc9bebe19900693613b36565b70014551231950b75fc4402da1732fc9bebe1990069116151585146152b157601c925b60405194859460808601948370014551231950b75fc4402da1732fc9bebe1991098652168785015280604085015270014551231950b75fc4402da1732fc9bebe1991096060830152838052039060015afa15610b05576152a09060005192615420565b6001600160a01b0390811691161490565b601b9261523d565b92939260209260009260809290916001161561531a57601c915b60ff60405193868552168684015280604084015270014551231950b75fc4402da1732fc9bebe199109606082015282805260015afa15610b05576152a09060005192615420565b601b916152d3565b91926401000003d01903916401000003d01983116126bc5761508a936401000003d0199360009390859006926154b5565b6153899063400000f4600160fe1b03906401000003d01990816007816000840908906401000003d0199081818009900908615bef565b600281018082116126bc5760011661539e5790565b6401000003d019036401000003d01981116126bc5790565b80158015615410575b8015615408575b80156153f8575b614ed0576401000003d01990818180090960076401000003d0199108906401000003d0199080091490565b506401000003d0198210156153cd565b5081156153c6565b506401000003d0198110156153bf565b604051916020830191825260408301526040825261543f606083611bde565b905190206001600160a01b031690565b92909180840361549857506401000003d019908208615472575050600090600090565b61508a916000615489926401000003d01992615aa8565b905b6401000003d0199261569c565b61508a936154af936401000003d01993929161577e565b9061548b565b939493909290918083036154f8575083156154f357839083086154de5750505050600090600090565b61508a936154ed928492615aa8565b9161569c565b6132eb565b61508a95506154ed93859361577e565b81156154f3570490565b92909192600190801561558f57600094600194869392805b6155375750505050929190565b60018116615563575b90600061555a9260011c9485946401000003d01993615b1e565b9290929361552a565b936155809084848460009a61555a969c6401000003d01995615914565b90989097509094909150615540565b5050909190600190565b919291906000841515858161568b575b5080615683575b1561564d5760009490856401000003d0196001845b6155f45750505050506401000003d01984800991826401000003d0199109936401000003d01992839109900990565b61560285839a95969a615508565b9181936154f35761563e615629615644936401000003d0199086096401000003d019613b66565b87966401000003d019919008949a8094613356565b90613b66565b939291846155c5565b60405162461bcd60e51b815260206004820152600e60248201526d24b73b30b634b210373ab6b132b960911b6044820152606490fd5b5060016155b0565b6401000003d01914159050386155a9565b91939291841515838682615727575b50508061571e575b1561564d5760009483159081856001835b6156e157505050506154f357829081808780098092099509900990565b6156ee84839b959b615508565b9181936154f35761563e896157098161571695870982613b66565b60009708949b8094613356565b9291836156c4565b508215156156b3565b1415905083386156ab565b1561573957565b60405162461bcd60e51b815260206004820152601e60248201527f557365206a6163446f75626c652066756e6374696f6e20696e737465616400006044820152606490fd5b939190949284158061590c575b615900578115806158f8575b6158ed576157a3613c18565b9583156154f3578380938160018009808a529882808b6001099460208301958652604083018c81529a82808e60010991606086019283526157e46080611c2f565b9d5190098c5251900960208a01525190096040870152519009606084015282519360408401948551148015906158db575b61581e90615732565b81615827613c18565b9551615834865183613b66565b900885528160608501516158d08288818060208b0195615855875183613b66565b900899602083019a8b5281808c8180808089518a5190099360408a019485526158858286518c5190099a60600190565b998a52518009615896895183613b66565b90086158ac828088518651900960020983613b66565b90089d519351905190096158c08d83613b66565b9008900993519051900983613b66565b900894510991929190565b50602084015160608501511415615815565b505050909190600190565b508015615797565b90945092506001919050565b50851561578b565b9694969593909195801580615aa0575b615a9457831580615a8c575b615a815761593c613c18565b9285156154f35788948694858093818c800983528183518d0995602084019687528280604086019b81818009808e529009916060860192835261597f6080611c2f565b9b5190098a52519009602088015251900960408501525190096060820152818151956159ab8360400190565b96875114801590615a6f575b6159c090615732565b816159c9613c18565b97516159d6855183613b66565b90088752816060840151615a62828a818060208a01956159f7875183613b66565b90089860208301998a5281808b8180808089518a5190099360408a01948552615a278286518c5190099a60600190565b998a52518009615a38895183613b66565b9008615a4e828088518651900960020983613b66565b90089c519351905190096158c08c83613b66565b9008965192969509900990565b506020830151606084015114156159b7565b935050945050929190565b508115615930565b50959450509050929190565b508215615924565b93919392909281156154f3578180858009918180808060018009998180808988096004099b80099009928009600309088286800883038381116126bc5783908183800908808403928484116126bc57848091800960080984038481116126bc578460019381809681959b08900908940960020990565b9093919492948015615b9b5782156154f357828086800992818080808680099a8180808a88096004099c8009900992800960030908918387800884038481116126bc578490818580090890818503908582116126bc5785809180096008098503908582116126bc5785948580949281939b08900908940960020990565b909450919050565b15615baa57565b60405162461bcd60e51b815260206004820152601e60248201527f456c6c697074696343757276653a206d6f64756c7573206973207a65726f00006044820152606490fd5b615bf96001615ba3565b8015614ed0578115615c9057600191600160ff1b9190825b615c1b5750505090565b9091926401000003d019908483161515840a906401000003d019908009096401000003d01990600185901c83161515840a9082908009096401000003d01990600285901c83161515840a9082908009096401000003d01990600385901c83161515840a9082908009099260041c919082615c11565b505060019056fea26469706673582212208b4e68c1c777d955336be78b0e249721a20666142fded4ca286024a63f85fc4f64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x12W`\0\x80\xFD[`\x005`\xE0\x1C\x80c\x02\x89\x95\xCD\x14a\x04MW\x80c\x05\xA85\xBF\x14a\x04HW\x80c\x0B\x12\xE4\xBA\x14a\x04CW\x80c\x0E\xBB\xCF\xB5\x14a\x04>W\x80c\x16/\xC3\x01\x14a\x049W\x80c\x18:On\x14a\x044W\x80c\x19<\xCBa\x14a\x03\xDAW\x80c\x1C\x10\x89?\x14a\x04/W\x80c\x1C\xD6M\xF4\x14a\x04*W\x80c\x1EFC\t\x14a\x04%W\x80c\x1F\xDA\x9A\x02\x14a\x04 W\x80c!\xDD\x95v\x14a\x04\x1BW\x80c#\xA8\xC4\xBA\x14a\x04\x16W\x80c%J9\xFE\x14a\x04\x11W\x80c%i)b\x14a\x04\x0CW\x80c,*\xABA\x14a\x03\xEEW\x80c-\xE9H\x07\x14a\x04\x07W\x80c1\x05,0\x14a\x04\x02W\x80c3\xE7\x97z\x14a\x03\xFDW\x80c63\x93\x88\x14a\x03\xF8W\x80c9v\x06\xC0\x14a\x03\xF3W\x80c;f\xF1\xC0\x14a\x03\xEEW\x80c=\xB12\xB1\x14a\x03\xE9W\x80cC\\\x02\x98\x14a\x03\xE4W\x80cCl\xFB\x9B\x14a\x03\xDFW\x80cD\x19\xDF:\x14a\x03\xDAW\x80cJN\xE7\xB1\x14a\x03\xD5W\x80cP\xF1\xC5Z\x14a\x03\xD0W\x80cQNb\xFC\x14a\x03\xCBW\x80cR\xA5\xF1\xF8\x14a\x03\xC6W\x80cT\xD1\xF1=\x14a\x03\xC1W\x80c[\xBE\x06\x94\x14a\x03\xBCW\x80ce\x83^Z\x14a\x03\xB7W\x80cg\xF1\x88\xB7\x14a\x03\xB2W\x80cjA\x1B\x0C\x14a\x03\xADW\x80coY#/\x14a\x03\xA8W\x80cqP\x18\xA6\x14a\x03\xA3W\x80c\x82(\xB1\xE2\x14a\x03\x9EW\x80c\x8A\x95\xE6\xDF\x14a\x03\x99W\x80c\x8D>DZ\x14a\x03\x94W\x80c\x8D\xA5\xCB[\x14a\x03\x8FW\x80c\x8E\xAAI]\x14a\x03\x8AW\x80c\x91q\xE5X\x14a\x03\x85W\x80c\x94\xC5\x93\x14\x14a\x03\x80W\x80c\x94\xE7\xEC\xFB\x14a\x03{W\x80c\x98\xE5\x03\n\x14a\x03vW\x80c\x9D\xCC!\xBD\x14a\x03qW\x80c\xA1\xBD\xC6\x08\x14a\x03lW\x80c\xAA\xB5\x86\xC2\x14a\x03gW\x80c\xAC\xE3\xA1S\x14a\x03bW\x80c\xAF\xB2\x18\xF5\x14a\x03]W\x80c\xB5\x16\x10\\\x14a\x03XW\x80c\xB6\xF9\0T\x14a\x03SW\x80c\xBA\xD0\x18\x99\x14a\x03NW\x80c\xBC?\x1F\n\x14a\x03IW\x80c\xC0\xA7yR\x14a\x03DW\x80c\xD0\xBE\x0B\x9C\x14a\x03?W\x80c\xD9\xFB:\xBA\x14a\x03:W\x80c\xDE\x85\x847\x14a\x035W\x80c\xE1\xFA\x8E\x84\x14a\x030W\x80c\xE2C\xAD\xBF\x14a\x03+W\x80c\xEB\xE9<\xAF\x14a\x03&W\x80c\xEC\xC0D\x85\x14a\x03!W\x80c\xF0N(>\x14a\x03\x1CW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x17W\x80c\xF7\xD2Fs\x14a\x03\x12W\x80c\xF9\x81\x18\xD5\x14a\x03\rWc\xFE\xE8\x1C\xF4\x14a\x03\x08W`\0\x80\xFD[a1\x80V[a1TV[a0\xF2V[a0\xB2V[a0^V[a/\x87V[a/\x17V[a.\xFBV[a-\xF9V[a-\xCDV[a,\xFEV[a+\x11V[a*\xD6V[a(\xBEV[a(yV[a(JV[a'\xACV[a'gV[a&\xC1V[a%\xEEV[a%\x92V[a$%V[a#TV[a#8V[a\"\x07V[a!^V[a!8V[a!\x0BV[a \x88V[a +V[a\x1F\xCFV[a\x1F\x83V[a\x1E\xF1V[a\x1E\xC4V[a\x1D\xE7V[a\x17\xEDV[a\x16\xD4V[a\x16\x82V[a\x15\x82V[a\x15,V[a\x13\xD6V[a\x13\xAAV[a\r\x81V[a\x13\x84V[a\x13KV[a\x12\xB0V[a\x0F\xEBV[a\x12=V[a\x11\xF8V[a\x11\xB3V[a\x10\xABV[a\x10\x11V[a\x0F\x9FV[a\x0F\x81V[a\x0FKV[a\x0E\xBFV[a\x0EzV[a\x0E\\V[a\x0E\x16V[a\r\xAEV[a\rgV[a\x0C\xDAV[a\x08qV[a\x08EV[a\x04\x88V[a\x04bV[`\0\x91\x03\x12a\x04]WV[`\0\x80\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` a\x04}a1\xB7V[`\xFF`@Q\x91\x16\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x04\xA4aC\x9BV[a\x04\xAD\x81aC\xF0V[`\x06\x81\x01\x80T`\xFF\x19\x16`\x02\x17\x90U\x90`\0\x91\x82a\x04\xCA\x83aCaV[\x91\x90\x91\x15a\x086Wa\x04\xDAa2jV[\x91\x85[`\xFF\x81\x16\x91`\x05\x83\x10\x80a\x08)W[\x80a\x08\x1CW[\x15a\x06\xB7W`@\x80Q` \x81\x01\x92\x83R`\xF8\x84\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x91\x81\x01\x91\x90\x91Ra\x05/\x81`A\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a\x1B\xDEV[Q\x90 \x91a\x05Ia\x05D`\x06\x85\x06[`\xFF\x16\x90V[a3\x01V[\x92a\x05!a\x05\x82a\x05Y\x85a3\x01V[`@\x80Q` \x81\x01\x95\x86R`\xF8\x92\x90\x92\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x82\x01R\x91\x82\x90`A\x82\x01\x90V[Q\x90 \x92a\x05\x95a\x05D`\x06\x86\x06a\x05>V[\x98[`\xFF\x8A\x16`\xFF\x83\x16\x14a\x065W`\xFF\x8A\x16`\xFF\x83\x16\x11\x90\x81`\0\x14a\x06\x14W\x91a\x05\xF8a\x06\x0F\x95\x94\x92a\x05\xEFa\x05\xCFa\x06\t\x96a2\xDAV[\x9D[a\x05\xE5a\x05\xDCa\x1B\xFFV[`\xFF\x90\x96\x16\x86RV[`\xFF\x16` \x85\x01RV[\x15\x15`@\x83\x01RV[a\x06\x02\x82\x89a3'V[R\x86a3'V[Pa2\xDAV[a\x04\xDDV[\x99\x95\x91a\x05\xF8a\x06\x0F\x95\x94\x92a\x05\xEFa\x06/a\x06\t\x96a2\xDAV[\x99a\x05\xD1V[\x98PP\x91`@Qa\x06a\x81a\x05!` \x82\x01\x94\x85`&\x91\x81Re\x1C\x99\\\x9B\xDB\x1B`\xD2\x1B` \x82\x01R\x01\x90V[Q\x90 \x91a\x06ta\x05D`\x06\x85\x06a\x05>V[\x92`@Qa\x06\x9E\x81a\x05!` \x82\x01\x94\x85`'\x91\x81Rf92\xB97\xB66\x19`\xC9\x1B` \x82\x01R\x01\x90V[Q\x90 \x92a\x06\xB1a\x05D`\x06\x86\x06a\x05>V[\x98a\x05\x97V[PPP\x93\x91`\xFFa\x06\xC8\x86\x85a3\x13V[\x16\x93a\x06\xD3\x85a2\x8FV[\x93`\0[`\xFF\x81\x16\x87\x81\x10\x15a\x07\x10W`\xFF\x91a\x07\x08\x82a\x06\xF6`\x01\x94\x8Aa3'V[Qa\x07\x01\x82\x8Ca3'V[R\x89a3'V[P\x01\x16a\x06\xD7V[PPa\x07\xD3`\x01a\x07\x85`\x02\x93`\xFF\x80\x8Ca\x07.\x8C`\x07\x8C\x01a3mV[`\x08\x8A\x81\x01\x80T`\xFF\x87\x16a\xFF\xFF\x19\x90\x91\x16\x17\x91\x83\x90\x1Ba\xFF\0\x16\x91\x90\x91\x17\x90U\x16\x91\x16\x11\x95`\0\x96a\x07n\x84\x83\x01T`\0R`\x0E` R`@`\0 \x90V[a\x07x\x81Ta4IV[\x90Ua\x07\x98\x84`\x02\x84\x01`\0[P\x01T`\0R`\x0E` R`@`\0 \x90V[a\x07\xA2\x81Ta4IV[\x90U\x80\x15a\x08\x0EW\x83a\x07\xBA\x81a\x07\x85\x8B[\x86a45V[\x01a\x07\xC5\x81Ta4IV[\x90U\x15a\x08\x07W\x82\x90a45V[\x01a\x07\xDE\x81Ta4IV[\x90U\x7F1T9a\xBA\xD6\xE1\xB8\x86\xFEK<\x06\r=\x97\xC2\x1F\xBC\x80\xE6:\xB2.\x9E\xEAe\xD9\xD2\xDC|w\x82\x80\xA2\x80\xF3[\x86\x90a45V[\x83a\x07\xBA\x81a\x07\x85\x81a\x07\xB4V[P`\x03`\xFF\x85\x16\x10a\x04\xF2V[P`\x03`\xFF\x89\x16\x10a\x04\xECV[c2\x92n\xDD`\xE0\x1B\x85R`\x04\x85\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` a\x08`a4pV[`\x01`\x01`\x80\x1B\x03`@Q\x91\x16\x81R\xF3[` 6`\x03\x19\x01\x12a\x04]W`\x045a\x08\x88aC\x9BV[a\x08\x91\x81aDrV[a\x08\x99a8+V[PP\x804\x10a\x0C\xC2WP`\x06\x81\x01\x80T`\xFF\x19\x16`\x01\x17\x90Ua\x08\xDB\x90`\n\x81\x01T\x81T`\x02\x90\x92\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x90\x83\x16\x18\x90\x91\x16\x83\x18\x18\x90V[a\x08\xE3aC\x9BV[a\x08\xEBaF!V[\x81\x15a\x0C\xB1W`\xFFa\t\x11a\t\n\x84`\0R`\x07` R`@`\0 \x90V[T`\xFF\x16\x90V[\x16a\x0C\x9BW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x0C\x80W[4\x90a\tFa8+V[\x92\x91\x804\x10a\x0ChWP`\x01T`\xFF\x16a\x0B\x19W[PP`\x01T`\x08\x1C`\xFF\x16a\n\x0CW[PP`\x01T`\x10\x1C`\xFF\x16a\t\xACW[a\t\x85`\x01`\0UV[\x7FP\xAD\x08\xF5\x8A'\xF2\x85\x1D~:\x1B:jF\xB2\x90\xF2\xCEg~\x99d-0\xFFc\x97!\xE7w\x90`\0\x80\xA2\0[a\t\xDFa\t\xC3\x82`\0R`\x07` R`@`\0 \x90V[`\x04a\t\xD0\x82T`\xFF\x16\x90V[\x17`\xFF\x16`\xFF\x19\x82T\x16\x17\x90UV[`\x04\x81\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA3a\t{V[a\n0a\n#\x84`\0R`\x07` R`@`\0 \x90V[`\x02a\t\xD0\x82T`\xFF\x16\x90V[a\x0B\nW[P`@Qc\xD8E\xA4\xB3`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R` \x81`$\x81`\0`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xF1\x90\x81\x15a\x0B\x05W\x82\x91a\n\xA6\x91`\0\x91a\n\xD6W[P`\0R`\x06` R`@`\0 \x90V[U`\x02\x81\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA38\x80a\tkV[a\n\xF8\x91P` =` \x11a\n\xFEW[a\n\xF0\x81\x83a\x1B\xDEV[\x81\x01\x90aA\x94V[8a\n\x95V[P=a\n\xE6V[a4dV[a\x0B\x13\x90a5,V[8a\n5V[a\x0B\xA2\x92\x93P`\x01`\x01`\x80\x1B\x03` \x91a\x0BNa\x0BA\x88`\0R`\x07` R`@`\0 \x90V[`\x01a\t\xD0\x82T`\xFF\x16\x90V[`@Qc\x19\xCB\x82_`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x04\x82\x01R`$\x81\x01\x94\x90\x94R\x92\x93\x92\x16\x91\x83\x90\x81\x90`D\x82\x01\x90V[\x03\x81\x84\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x80\x15a\x0B\x05Wa\x0C\x02\x85\x91a\x0C\t\x94`\0\x91a\x0C9W[P`\x01`\x01`@\x1B\x03\x16`\0R`\x05` R`@`\0 \x90V[U4a;fV[\x90`\x01\x83\x7F>\xC8d/\x8Bv\x84\x99\x11^\xA1\x87\xDCh\x9Ak\x03\xE5\x02\xD0\x81\t\xC7\x8B\x84m\xE2\x02\x02\xF6\xF9\x10`\0\x80\xA38\x80a\t[V[a\x0C[\x91P` =` \x11a\x0CaW[a\x0CS\x81\x83a\x1B\xDEV[\x81\x01\x90aEIV[8a\x0B\xE8V[P=a\x0CIV[c\xA4X&\x1B`\xE0\x1B`\0R4`\x04R`$R`D`\0\xFD[\x80a\x0C\x95\x83`\0R`\t` R`@`\0 \x90V[Ua\t<V[cj\xE0\tg`\xE0\x1B`\0R`\x04\x82\x90R`$`\0\xFD[cA\xAB\xC8\x01`\xE0\x1B`\0R`\x04`\0\xFD[c\xA4X&\x1B`\xE0\x1B`\0R4`\x04R`$R`D`\0\xFD[4a\x04]W`\0` 6`\x03\x19\x01\x12a\rdW`\x045a\x0C\xF8aC\x9BV[\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\rbW`$`@Q\x80\x94\x81\x93cO\xFD.C`\xE0\x1B\x83R0`\x04\x84\x01RZ\xF1\x80\x15a\x0B\x05W\x82\x90a\rTW\x80\xF3[a\r]\x91a\x1B\xDEV[8\x81\x80\xF3[P[\x80\xFD[` 6`\x03\x19\x01\x12a\x04]Wa\r\x7F`\x0453aM\x91V[\0[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\x03\x81R\xF3[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x04]WV[`@6`\x03\x19\x01\x12a\x04]W`\x045a\r\xC6\x81a\r\x9DV[`$5\x90a\r\xD2aC\xB7V[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C \x90\x81T\x17\x80\x91U`\x0CQ``\x1C\x7FqZ\xD5\xCEa\xFC\x95\x95\xC7\xB4\x15(\x9DY\xCF ?#\xA9O\xA0o\x04\xAF~H\x9A\nv\xE1\xFE&`\0\x80\xA3\0[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W` a\x0ER`\x045a\x0E8\x81a\r\x9DV[`$5\x91\x82\x91c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[\x16\x14`@Q\x90\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\x04T`@Q\x90\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W`\0` 6`\x03\x19\x01\x12a\rdW\x80`\x045a\x0E\xDEaC\x9BV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90\x81;\x15a\x0FGW`@Qc$e\xF8\xF5`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x91\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x0B\x05W\x82\x90a\rTW\x80\xF3[PP\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x80a\x0Fi`\x045a6\x18V[\x91`@Q\x93\x84R` \x84\x01R`@\x83\x01R``\x82\x01R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\x0FT`@Q\x90\x81R\xF3[`\x006`\x03\x19\x01\x12a\x04]Wc8\x9Au\xE1`\x0CR3`\0Rb\x02\xA3\0B\x01` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D`\0\x80\xA2\0[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W` a\x10\t`\x045a7\x93V[`@Q\x90\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W` a\x10\t`\x045a\x103\x81a\r\x9DV[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90`\0[\x81\x81\x10a\x10kWPPP\x90V[\x90\x91\x92` a\x10\xA1`\x01\x92\x86Q\x90`@``\x92`\x01\x80`\xA0\x1B\x03\x81Q\x16\x83R` \x81\x01Q\x15\x15` \x84\x01R\x01Q`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a\x10^V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045\x80\x15\x80\x15a\x11\xA8W[a\x11\x97Wa\x10\xE2`\x04\x91`\0R`\x0B` R`@`\0 \x90V[\x01\x80Ta\x10\xEE\x81a7'V[\x91`\0[\x82\x81\x10a\x11\x0BW`@Q\x80a\x11\x07\x86\x82a\x10GV[\x03\x90\xF3[\x80a\x11)a\x11\x1B`\x01\x93\x85a7wV[PT`\x01`\x01`\xA0\x1B\x03\x16\x90V[a\x11Aa\x116\x83\x86a7wV[PT`\xA0\x1C`\xFF\x16\x90V[a\x11v\x84a\x11O\x85\x88a7wV[P\x01T\x91a\x11ma\x11^a\x1B\xFFV[`\x01`\x01`\xA0\x1B\x03\x90\x95\x16\x85RV[\x15\x15` \x84\x01RV[`@\x82\x01Ra\x11\x85\x82\x87a3'V[Ra\x11\x90\x81\x86a3'V[P\x01a\x10\xF2V[c]\xF6&\xE1`\xE1\x1B`\0R`\x04`\0\xFD[P`\nT\x81\x11a\x10\xC8V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x12Ya2'V[P`\0R`\x0E` R`@`\0 `\x02`@Q\x91a\x12v\x83a\x1BkV[\x80T\x83R`\x01\x81\x01T` \x84\x01R\x01T`@\x82\x01R`@Q\x80\x91`@``\x83\x01\x91\x80Q\x84R` \x81\x01Q` \x85\x01R\x01Q`@\x83\x01R\x03\x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]Wa\x12\xC9aC\xB7V[G\x80\x15a\x13\x0EW`\0\x80\x80\x80a\r\x7F\x943Z\xF1=\x15a\x13\tW=a\x12\xEC\x81a\x1C\xE0V[\x90a\x12\xFA`@Q\x92\x83a\x1B\xDEV[\x81R`\0` =\x92\x01>a7\xDFV[a7\xDFV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01Rt'7\x90\"\xAA$\x17\xA2&\xAA\x10:7\x9092\xB1\xB7\xBB2\xB9`Y\x1B`D\x82\x01R`d\x90\xFD[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W```\x01`\x01`\x80\x1B\x03a\x13na8+V[\x91\x92\x90`@Q\x93\x84R\x16` \x83\x01R`@\x82\x01R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T`\x08\x1C\x16`@Q\x90\x15\x15\x81R\xF3[`@6`\x03\x19\x01\x12a\x04]Wa\r\x7F`\x045a\x13\xC5\x81a\r\x9DV[`$5\x90a\x13\xD1aC\xB7V[aM\x91V[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W`\x045a\x13\xF3\x81a\r\x9DV[`$5\x90a\x13\xFFaC\xB7V[`@Qc1\xA9\x10\x8F`\xE1\x1B\x81R`\x04\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x91\x90` \x81`$\x81\x86Z\xFA\x90\x81a\x14\xFFW[Pa\x14\xA7WP\x7F\xB3\x98\xCA#[>\xFF/g\xE7'\x07$e\r\x13\xE4|\xD5\xF9\xDA\xC1;\x91\x87\xED\x81\xB1'\xCE$\xC7`@Q\x80a\x14\xA2\x81`\x80\x90` \x81R`!` \x82\x01R\x7FNot an ERC721 or invalid token I`@\x82\x01R`\x11`\xFA\x1B``\x82\x01R\x01\x90V[\x03\x90\xA2\0[\x90\x80;\x15a\x04]W`@Qc!B\x17\x07`\xE1\x1B\x81R0`\x04\x82\x01R3`$\x82\x01R`D\x81\x01\x92\x90\x92R`\0\x90\x82\x90`d\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x0B\x05Wa\x14\xEAW\0[\x80a\x14\xF9`\0a\r\x7F\x93a\x1B\xDEV[\x80a\x04RV[a\x15 \x90` =` \x11a\x15%W[a\x15\x18\x81\x83a\x1B\xDEV[\x81\x01\x90a9\"V[a\x141V[P=a\x15\x0EV[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W` `\x045a\x15K\x81a\r\x9DV[a\x15f`$5\x91c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C T\x90V[\x16\x15\x15`@Q\x90\x81R\xF3[`\x01`\x01`@\x1B\x03\x81\x16\x03a\x04]WV[4a\x04]W``6`\x03\x19\x01\x12a\x04]W`\x045a\x15\x9F\x81a\x15qV[a\x15\xAA`$5a\r\x9DV[`D5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\x16=W3\x03a\x15\xECWa\r\x7F\x91aE\x9DV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`#`$\x82\x01R\x7FOnly Entropy can call this funct`D\x82\x01Rb4\xB7\xB7`\xE9\x1B`d\x82\x01R`\x84\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FEntropy address not set\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`\x006`\x03\x19\x01\x12a\x04]Wc8\x9Au\xE1`\x0CR3`\0R`\0` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92`\0\x80\xA2\0[\x80\x15\x15\x03a\x04]WV[4a\x04]W`\x806`\x03\x19\x01\x12a\x04]W`$5`\x045a\x16\xF4\x82a\r\x9DV[`D5\x90a\x17\x01\x82a\x16\xCAV[`d5\x91a\x17\raC\x9BV[a\x17\x16\x82aDrV[\x83\x15a\x17\xDCW\x7FJ\xF7\x1B\x02\x1Ey\x9Cb\xC1X\xBDTcl\xA8\xDA/\xA2a\x15\xA2\x1A-\xC6\xEF\xE4\x86\xEC\x10O\xD1_\x91a\x17\xD7\x91`\t\x90a\x17z\x870\x8A\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16aE\xBFV[a\x17\xAC`@Qa\x17\x89\x81a\x1BkV[`\x01`\x01`\xA0\x1B\x03\x8A\x16\x81R\x84\x15\x15` \x82\x01R\x88`@\x82\x01R`\x04\x83\x01a9uV[\x01a\x17\xB8\x86\x82Ta4WV[\x90U`@Q\x94\x85R\x15\x15\x94`\x01`\x01`\xA0\x1B\x03\x16\x93\x90\x81\x90` \x82\x01\x90V[\x03\x90\xA4\0[c\x16)\x08\xE3`\xE1\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x18\taF!V[a\x18\x11aC\x9BV[a\x18\"a\x18\x1D\x82aD\xDCV[a:\x90V[\x90a\x181`\xA0\x83\x01Q`\xFF\x16\x90V[`\xFFa\x18Da\x05>`\xC0\x86\x01Q`\xFF\x16\x90V[\x91\x16\x11`\0\x90`\0\x14a\x1BPWP`\x01[a\x18b`@\x84\x01Qa3@V[\x92`\0\x80\x94`\xE0\x83\x01Q\x95a\x18v\x86a6\x18V[\x90\x91\x8A\x15\x15\x93\x84a\x1BFW[P\x83a\x1B<W[P\x87\x15a\x1B4WP\x90[`\x10T`\xFF\x16a\x1A\xEAW[a\x18\xC5`\x06a\x18\xB7\x8A`\0R`\x0B` R`@`\0 \x90V[\x01\x80T`\xFF\x19\x16`\x03\x17\x90UV[a\x18\xCE\x88aN/V[P\x85Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x94a\x19.\x91a\x19(\x90a\x19\x1A\x90\x8B\x15a\x1A\xE1W`\xFF`\0[\x16\x90a;sV[QQ`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x86aF\xC1V[a\x1AWWP\x85\x96Pa\x19Ua\x19P`\x80\x96\x97`\0R`\x0B` R`@`\0 \x90V[aGGV[`\x10T`\xFF\x81\x16a\x1A.W[PPPP\x01\x80QQ`\xFF\x16\x90a\x19ua;\x84V[\x93`\xFF`\0\x93\x16\x92[`\xFF\x81\x16\x84\x81\x10\x15a\x19\xB8W`\xFF\x91a\x19\xB0\x82a\x19\x9E`\x01\x94\x88Qa3'V[Qa\x19\xA9\x82\x8Ca;\x9DV[R\x89a;\x9DV[P\x01\x16a\x19~V[\x86\x83\x87\x15a\x1A\x04W\x7F\x8E\xF0\x1D\xE7HU\\\xD1\xD5C\x1De=\xAB\x86C*\x1D}u\tf!\xDE\xCAznKAM\xE66`\xFF`\0[a\x19\xF7`@Q\x92\x83\x92\x16\x95\x82a;\xAEV[\x03\x90\xA3a\r\x7F`\x01`\0UV[\x7F\x8E\xF0\x1D\xE7HU\\\xD1\xD5C\x1De=\xAB\x86C*\x1D}u\tf!\xDE\xCAznKAM\xE66`\xFF`\x01a\x19\xE6V[a\x1AN\x93a\x1AH\x91`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16\x92a4WV[\x91aF\xC1V[8\x80\x80\x80a\x19aV[` \x85\x01Q\x80Q\x91`\0[\x83\x81\x10a\x1AxWPPPP`\x80\x94\x95\x96Pa\x19UV[\x80a\x1A\x92` a\x1A\x8A`\x01\x94\x87a3'V[Q\x01Q\x15\x15\x90V[\x8A\x15\x15\x90\x15\x15\x03a\x1A\xA4W[\x01a\x1AbV[a\x1A\xDCa\x1A\xC9\x8Da\x1A\xC3\x86`@a\x1A\xBB\x87\x8Ba3'V[Q\x01QaE^V[\x90aG\x17V[a\x1A\xD6a\x19\x1A\x84\x88a3'V[\x89aF\xC1V[a\x1A\x9EV[`\xFF`\x01a\x19\x13V[\x97\x92\x91P\x92P`\x0FT\x92a\x1A\xFE\x84\x83aFCV[\x93\x88\x15a\x1B)Wa\x1B\x12a\x1B#\x91\x85aFCV[a\x1B\x1D\x86\x82\x95a;fV[\x94a;fV[\x97a\x18\x9EV[Pa\x1B#`\0a\x1B\x12V[\x90P\x90a\x18\x93V[\x15\x15\x92P8a\x18\x89V[\x15\x15\x93P8a\x18\x82V[a\x18UV[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x1BUV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x01\0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[a\x01 \x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x1B\x86W`@RV[`@Q\x90a\x1C\x0E``\x83a\x1B\xDEV[V[`@Q\x90a\x1C\x0Ea\x01 \x83a\x1B\xDEV[`@Q\x90a\x1C\x0E`@\x83a\x1B\xDEV[\x90a\x1C\x0E`@Q\x92\x83a\x1B\xDEV[\x91\x90`@Q\x92a\x1CN`\x80\x85a\x1B\xDEV[\x83\x90`\x80\x81\x01\x92\x83\x11a\x04]W\x90[\x82\x82\x10a\x1CiWPPPV[\x815\x81R` \x91\x82\x01\x91\x01a\x1C]V[\x91\x90`@\x80Q\x93a\x1C\x8A\x82\x86a\x1B\xDEV[\x84\x91\x81\x01\x92\x83\x11a\x04]W\x90[\x82\x82\x10a\x1C\xA3WPPPV[\x815\x81R` \x91\x82\x01\x91\x01a\x1C\x97V[\x80`\x83\x12\x15a\x04]Wa\x1C\xC7\x90`da\x1C=V[\x90V[\x80a\x01C\x12\x15a\x04]Wa\x1C\xC7\x90a\x01$a\x1C=V[`\x01`\x01`@\x1B\x03\x81\x11a\x1B\x86W`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x81`\x1F\x82\x01\x12\x15a\x04]W\x805\x90a\x1D\x12\x82a\x1C\xE0V[\x92a\x1D `@Q\x94\x85a\x1B\xDEV[\x82\x84R` \x83\x83\x01\x01\x11a\x04]W\x81`\0\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90`\xA0`\x03\x19\x83\x01\x12a\x04]W\x81`#\x12\x15a\x04]Wa\x1Dc\x82`\x04a\x1C=V[\x91`\x845\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04]Wa\x1C\xC7\x91`\x04\x01a\x1C\xFBV[\x90`\0\x90[`\x02\x82\x10a\x1D\x94WPPPV[` \x80`\x01\x92\x85Q\x81R\x01\x93\x01\x91\x01\x90\x91a\x1D\x87V[`@\x90\x93\x92\x91\x93a\x1D\xBF\x81`\xC0\x81\x01\x96a\x1D\x82V[\x01`\0\x90[`\x04\x82\x10a\x1D\xD1WPPPV[` \x80`\x01\x92\x85Q\x81R\x01\x93\x01\x91\x01\x90\x91a\x1D\xC4V[4a\x04]Wa\x1D\xF56a\x1DBV[\x90a\x11\x07`@\x80\x80Qa\x1E\x08\x82\x82a\x1B\xDEV[6\x907`\x80\x80\x82Qa\x1E\x1A\x82\x82a\x1B\xDEV[6\x907a\x1EAa\x1E(a<(V[\x95a\x1E1a<\x03V[Pa\x1E:a<\x18V[P\x86aO#V[\x94a\x1E\xA9a\x1E\x90a\x1Ex``\x84\x01\x98a\x1Eo\x8AQa\x1E_\x87`@\x01\x90V[\x80Q\x8EQ\x91\x9E` \x01Q\x92aO\xFCV[\x96\x90\x9AQaP\xA5V[\x93\x90\x99Q\x90a\x1E\x89\x81Q\x91` \x01\x90V[Q\x91aP\xA5V[\x94\x90\x93a\x1E\x9C\x87a\x1C/V[\x98\x89R` \x89\x01Ra\x1C/V[\x96\x87R` \x87\x01R\x82\x86\x01R``\x85\x01RQ\x92\x83\x92\x83a\x1D\xAAV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`\x10T`@Q`\x08\x91\x90\x91\x1C`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[`\xC06`\x03\x19\x01\x12a\x04]W6`#\x12\x15a\x04]W`@\x80Qa\x1F\x14\x82\x82a\x1B\xDEV[\x806`\x84\x11a\x04]W`\x04\x90[`\x84\x82\x10a\x1FKWa\x11\x07\x84a\x1F<`\xA45`\x845\x87a<^V[\x90Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[\x83\x826\x03\x12a\x04]W` \x84\x91\x82Qa\x1Fc\x81a\x1B\x8BV[\x845a\x1Fn\x81a\r\x9DV[\x81R\x82\x85\x015\x83\x82\x01R\x81R\x01\x91\x01\x90a\x1F!V[`\x006`\x03\x19\x01\x12a\x04]Wa\x1F\x97aC\xB7V[`\0c\x8Bx\xC6\xD8\x19T\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3`\0c\x8Bx\xC6\xD8\x19U\0[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a\x1F\xEBaC\x9BV[\x80`\0R`\x07` R`\xFF`@`\0 T\x16\x15a \x04W\0[\x7FbH\xD5\xA2\tp-\xB8r\xB80E\xD5nK\xAFH6,\xE7\xA7\xCD\xA2\x85\xA6q\xE7\xC1\xE6?D\xB9`\0\x80\xA2\0[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90`\0[\x81\x81\x10a rWPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a eV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x80` `\x0CT\x91\x82\x81R\x01\x90`\x0C`\0R\x7F\xDFif\xC9q\x05\x1C=T\xECY\x16&\x06S\x14\x93\xA5\x14\x04\xA0\x02\x84/V\0\x9D~\\\xF4\xA8\xC7\x90`\0[\x81\x81\x10a \xF5Wa\x11\x07\x85a \xE9\x81\x87\x03\x82a\x1B\xDEV[`@Q\x91\x82\x91\x82a NV[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a \xD2V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]Wc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\xFF`\x01T`\x10\x1C\x16`@Q\x90\x15\x15\x81R\xF3[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `\nT`@Q\x90\x81R\xF3[a\x1C\x0E\x90\x92\x91\x92`\xE0\x80a\x01\0\x83\x01\x95`\x01\x80`\xA0\x1B\x03\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01R``\x81\x01Q``\x85\x01Ra!\xDF`\x80\x82\x01Q`\x80\x86\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\xA0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`\xC0\x81\x81\x01Q\x15\x15\x90\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x04]W` 6`\x03\x19\x01\x12a\x04]Wa\"\xBCa\x01\0`\x045a\"*\x81a\x15qV[`\0`\xE0`@Qa\":\x81a\x1B\xA6V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x01R`@Q\x80\x93\x81\x92caQ\xAB\x1F`\xE0\x1B\x83R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x84\x01\x90\x92\x91`\x01`\x01`@\x1B\x03` \x91`@\x84\x01\x95`\x01\x80`\xA0\x1B\x03\x16\x84R\x16\x91\x01RV[\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x0B\x05Wa\x11\x07\x91`\0\x91a#\tW[P`@Q\x91\x82\x91\x82a!|V[a#+\x91Pa\x01\0=\x81\x11a#1W[a##\x81\x83a\x1B\xDEV[\x81\x01\x90a@bV[8a\"\xFCV[P=a#\x19V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\t\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a#q\x81a\x16\xCAV[`@\x80Qc\x1F\xC5\x0E\xF5`\xE3\x1B\x81R0`\x04\x82\x01R`\0\x92\x90\x91\x82`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x90\x81\x15a\x0B\x05W\x83\x92\x84\x92a#\xE3W[P` \x93P\x15a#\xDDWa\x10\t\x91a;fV[Pa\x10\tV[\x92P\x90P`@\x82=`@\x11a$\x1DW[\x81a$\0`@\x93\x83a\x1B\xDEV[\x81\x01\x03\x12a$\x19W\x91` \x92\x83\x83Q\x93\x01Q\x91\x93a#\xCAV[\x82\x80\xFD[=\x91Pa#\xF3V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a$B\x81a\r\x9DV[a$JaC\xB7V[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x91\x90\x81\x16\x90\x81\x83\x03a$\xDCWPP`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R\x90` \x82`$\x81\x84Z\xFA\x90\x81\x15a\x0B\x05Wa\r\x7F\x92`\0\x92a$\xBBW[P3\x90aF\xC1V[a$\xD5\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a$\xB3V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R\x91\x92P\x90` \x81`$\x81\x86Z\xFA`\0\x91\x81a%qW[Pa%\\WPP\x7F\xB3\x98\xCA#[>\xFF/g\xE7'\x07$e\r\x13\xE4|\xD5\xF9\xDA\xC1;\x91\x87\xED\x81\xB1'\xCE$\xC7`@Q\x80a\x14\xA2\x81``\x90` \x81R`\x0C` \x82\x01Rk\x04\xE6\xF7B\x06\x16\xE2\x04U$3#`\xA4\x1B`@\x82\x01R\x01\x90V[\x80\x91\x92Pa%fW\0[a\r\x7F\x913\x90aF\xC1V[a%\x8B\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a%\x05V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]Wa%\xBE`\x045a%\xB1aF!V[a%\xB9aC\x9BV[aA\xA3V[`\x01`\0U\0[\x80`#\x12\x15a\x04]Wa\x1C\xC7\x90`\x04a\x1CyV[\x80a\x01\x03\x12\x15a\x04]Wa\x1C\xC7\x90`\xE4a\x1CyV[4a\x04]W`@6`\x03\x19\x01\x12a\x04]Wa&\x086a%\xC5V[a&\x10aC\xD4V[`\x04Ta8@\x81\x01\x80\x91\x11a&\xBCWB\x10a&mWa&h\x81a&S\x7F\xC6\xA4h\xB8C\x85\xCDM\xFCD\r\xB2\x1D\r\xF6\xF06\x12\xBAC\xB3^\xFE\x19\r\xEE\x99;FjQ\x98\x93aB\xADV[a&\\B`\x04UV[`@Q\x91\x82\x91\x82aB\xD1V[\x03\x90\xA1\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FKey change cooldown: wait 4 hour`D\x82\x01R`s`\xF8\x1B`d\x82\x01R`\x84\x90\xFD[a2\xC4V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\xFF\x81\x16\x81\x03a\x04]W\x7F\xA1\x88\x93\xA1k\x81\x8F>\x8CS\x18\x921%\x0C\xB0+\xB5\\\xB3(\x02\xA6\xD5\xC2\xB5\xEB\x85l\xDB\x7F\x1E\x90a'\taC\xB7V[a'\x11a1\xB7V[`\x01\x80Ta\xFF\xFF\x19\x16\x90\x83\x16\x15\x15`\xFF\x16\x17`\x02\x83\x16\x15\x15`\x08\x1Ba\xFF\0\x16\x17b\xFF\0\0\x19\x16`\x04\x83\x16\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17`\x01U`@\x80Q`\xFF\x92\x83\x16\x81R\x91\x90\x92\x16` \x82\x01R\x90\x81\x90\x81\x01a&hV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]Wa\x11\x07a'\xFD`\x01`\x01`\x80\x1B\x03a(2a(,a'\xCE6a\x1DBV[\x94\x90a'\xE2a'\xDBa<(V[\x96\x87aO#V[\x92\x90\x96``\x83\x01Q\x90`@\x84\x01Q` \x82Q\x92\x01Q\x92aO\xFCV[\x90``\x83\x01Q\x97`@\x84\x01\x98a( \x8AQ\x91\x86Q` \x88\x01\x93\x89\x86\x86Q\x94aP\x8EV[\x96\x90\x95Q\x91Q\x92aQ2V[`\x80\x1C\x90V[\x91Q`@Q\x91\x90\x92\x16\x90\x91\x14\x81R\x90\x81\x90` \x82\x01\x90V[4a\x04]W`\x806`\x03\x19\x01\x12a\x04]W6`#\x12\x15a\x04]W` a\x10\ta(t6`\x04a\x1C=V[aB\xE1V[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x04]Wa\x01\xA06`\x03\x19\x01\x12a\x04]W`\x045`$5`\x01`\x01`@\x1B\x03\x81\x11a\x04]Wa(\xF2\x906\x90`\x04\x01a\x1C\xFBV[`D5\x90a(\xFF6a\x1C\xB3V[a)\x086a%\xD9V[a)\x116a\x1C\xCAV[\x90a)\x1AaC\xD4V[`\x04`\xFFa)5a\t\n\x89`\0R`\x07` R`@`\0 \x90V[\x16\x03a*kWa)D\x86a7\x93V[a)M\x85aC>V[`@Qa)f\x81a\x05!` \x82\x01\x94\x85` \x91\x81R\x01\x90V[Q\x90 \x90`@Qa)\x83\x81a\x05!` \x82\x01\x94\x85` \x91\x81R\x01\x90V[Q\x90 \x03a*4W\x84a)\x95\x84aB\xE1V[\x03a)\xFDWa)\xB3\x93a)\xAF\x93a)\xAAa<(V[aI V[\x15\x90V[a)\xC1W\x81a\r\x7F\x92aJ)V[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x1D\x99\\\x9AY\x9AX\xD8]\x1A[\xDB\x88\x19\x98Z[\x19Y`j\x1B`D\x82\x01R`d\x90\xFD[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x0E\x0EM\xED\xEC\xC4\r\xAD.m\xAC.\x8Cm`\x93\x1B`D\x82\x01R`d\x90\xFD[`@Qc\x1F{I\xED`\xE3\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x0C-\x8E\r\x0C$\r\xAD.m\xAC.\x8Cm`\x93\x1B`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7FSAV must be last callback: other`D\x82\x01R\x7F providers have not completed\0\0\0`d\x82\x01R`\x84\x90\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a*\xF2aC\xB7V[a\x0B\xB8\x81\x11a+\0W`\x0FU\0[c\xB4\xFA?\xB3`\xE0\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\0R`\x07` R`@`\xFF\x81`\0 T\x16\x81Q\x90\x80\x15\x15\x82R` \x82\x01R\xF3[\x90`\0\x90[`\x02\x82\x10a+XWPPPV[\x82Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x90\x81\x01Q\x82\x82\x01R`\x01\x91`@\x01\x93\x01\x91\x01\x90\x91a+KV[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90`\0[\x81\x81\x10a+\xA0WPPP\x90V[\x90\x91\x92` a+\xD6`\x01\x92\x86Q\x90`@``\x92`\x01\x80`\xA0\x1B\x03\x81Q\x16\x83R` \x81\x01Q\x15\x15` \x84\x01R\x01Q`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a+\x93V[`\x05\x11\x15a+\xEAWV[cNH{q`\xE0\x1B`\0R`!`\x04R`$`\0\xFD[\x90`\x05\x82\x10\x15a+\xEAWRV[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90`\0[\x81\x81\x10a,+WPPP\x90V[\x90\x91\x92` a,_`\x01\x92\x86Q\x90`@``\x92`\xFF\x81Q\x16\x83R`\xFF` \x82\x01Q\x16` \x84\x01R\x01Q\x15\x15`@\x82\x01R\x01\x90V[\x94\x01\x92\x91\x01a,\x1EV[` \x81Ra,{` \x82\x01\x83Qa+FV[a\x01\x80a\x01\0a,\xCEa,\x9D` \x86\x01Q\x84`\xA0\x87\x01Ra\x01\xA0\x86\x01\x90a+\x82V[`@\x86\x01Q`\xC0\x86\x01Ra,\xB9``\x87\x01Q`\xE0\x87\x01\x90a,\0V[`\x80\x86\x01Q\x85\x82\x03`\x1F\x19\x01\x84\x87\x01Ra,\rV[`\xA0\x85\x01Q`\xFF\x16a\x01 \x85\x01R\x93`\xC0\x81\x01Q`\xFF\x16a\x01@\x85\x01R`\xE0\x81\x01Qa\x01`\x85\x01R\x01Q\x91\x01R\x90V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`@Qa-\x1E\x81a\x1B\xC2V[`@\x90\x81Qa--\x83\x82a\x1B\xDEV[`\0[\x83\x81\x10a-\xABWP\x81a\x01\0\x91`\0\x93R``` \x82\x01R\x82\x84\x82\x01R\x82``\x82\x01R```\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x82`\xE0\x82\x01R\x01R\x81\x15\x80\x15a-\xA0W[a\x11\x97Wa-\x95a\x18\x1Da\x11\x07\x93`\0R`\x0B` R`@`\0 \x90V[\x90Q\x91\x82\x91\x82a,iV[P`\nT\x82\x11a-wV[` \x90\x84Qa-\xB9\x81a\x1B\x8BV[`\0\x81R`\0\x83\x82\x01R\x81\x84\x01R\x01a-0V[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`@a-\xEB`\x045aCaV[\x82Q\x91\x82R\x15\x15` \x82\x01R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`@Qcn\xB1v\x9F`\xE1\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R` \x81\x80`D\x81\x01\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a.\xDCW[P`\0\x19\x11a.\x9DW3\x90\x7F\xF6+\xA4\x7F\xE3\xFFa\x08\x89\x16\x0F\x02W\x13\x96\xE8n!\xB7\xAA\xDC\xBD\xE2q\x91\x92\xE2\x06\x85;3\x1F`\0\x80\xA3\0[`@Qc\x10\xD0_\x11`\xE2\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01RuInsufficient allowance`P\x1B`D\x82\x01R`d\x90\xFD[a.\xF5\x91P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[8a.kV[4a\x04]W`\x006`\x03\x19\x01\x12a\x04]W` `@Q`\x05\x81R\xF3[4a\x04]W`@6`\x03\x19\x01\x12a\x04]W`\x045`$5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x163\x03a/vW\x81a\r\x7F\x92`\0R`\x06` R`@`\0 TaK\xAFV[c\\B|\xD9`\xE0\x1B`\0R`\x04`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a/\xA4\x81a\x16\xCAV[`@Qc\x12~\x8EM`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R\x90` \x82`$\x81`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x91\x82\x15a\x0B\x05W`\0\x92a0=W[P\x81\x90\x15a0\x10W[`@Q\x90\x81R` \x90\xF3[Pa0\x19a@\xF8V[\x90\x80\x82\x10a0,WPP` `\0a0\x05V[` \x91a08\x91a;fV[a0\x05V[a0W\x91\x92P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[\x908a/\xFCV[` 6`\x03\x19\x01\x12a\x04]W`\x045a0v\x81a\r\x9DV[a0~aC\xB7V[c8\x9Au\xE1`\x0CR\x80`\0R` `\x0C \x90\x81TB\x11a0\xA4W`\0a\r\x7F\x92UaH\xB7V[co^\x88\x18`\0R`\x04`\x1C\xFD[` 6`\x03\x19\x01\x12a\x04]W`\x045a0\xCA\x81a\r\x9DV[a0\xD2aC\xB7V[\x80``\x1B\x15a0\xE4Wa\r\x7F\x90aH\xB7V[ctH\xFB\xAE`\0R`\x04`\x1C\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a1\x0F\x81a\r\x9DV[a1\x17aC\xB7V[`\x10\x80Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x92\x90\x92\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x91\x90\x91\x17\x90U\0[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045`\x02\x81\x10\x15a\x04]W` \x90`\x02\x01T`@Q\x90\x81R\xF3[4a\x04]W` 6`\x03\x19\x01\x12a\x04]W`\x045a1\x9D\x81a\r\x9DV[c8\x9Au\xE1`\x0CR`\0R` \x80`\x0C T`@Q\x90\x81R\xF3[`\0`\x01T`\xFF\x81\x16a1\xEFW[`\xFF\x81`\x08\x1C\x16a1\xE4W[`\x10\x1C`\xFF\x16a1\xDEW\x90V[`\x04\x17\x90V[`\x02\x90\x91\x17\x90a1\xD1V[`\x01\x91Pa1\xC5V[\x90`\x05\x81\x10\x15a+\xEAW`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[`\x01`\x01`@\x1B\x03\x81\x11a\x1B\x86W`\x05\x1B` \x01\x90V[`@Q\x90a24\x82a\x1BkV[`\0`@\x83\x82\x81R\x82` \x82\x01R\x01RV[`\0[\x82\x81\x10a2UWPPPV[` \x90a2`a2'V[\x81\x84\x01R\x01a2IV[`@Q\x90`\xC0a2z\x81\x84a\x1B\xDEV[`\x05\x83Ra\x1C\x0E\x90`\x1F\x19\x01` \x84\x01a2FV[\x90a\x1C\x0Ea2\x9C\x83a2\x10V[a2\xA9`@Q\x91\x82a\x1B\xDEV[\x83\x81R` \x81\x94a2\xBC`\x1F\x19\x91a2\x10V[\x01\x91\x01a2FV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\xFF\x16`\xFF\x81\x14a&\xBCW`\x01\x01\x90V[cNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[`\xFF`\x01\x91\x16\x01\x90`\xFF\x82\x11a&\xBCWV[\x90`\xFF\x80\x91\x16\x91\x16\x01\x90`\xFF\x82\x11a&\xBCWV[\x80Q\x82\x10\x15a3;W` \x91`\x05\x1B\x01\x01\x90V[a1>V[\x90\x81`\x01\x1B\x91\x80\x83\x04`\x02\x14\x90\x15\x17\x15a&\xBCWV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a&\xBCWV[\x90UV[\x81Q\x91`\x01`@\x1B\x83\x11a\x1B\x86W\x81T\x83\x83U\x80\x84\x10a4\x0CW[P` a3\x9C\x91\x01\x91`\0R` `\0 \x90V[`\0\x91[\x83\x83\x10a3\xADWPPPPV[`\x01` \x82a4\0\x83\x94Q\x86\x81Q\x81T`\xFF\x19\x16`\xFF\x91\x90\x91\x16\x17\x81U\x90`@\x90` \x81\x01Q\x83Ta\xFF\0\x19\x16`\x08\x91\x90\x91\x1Ba\xFF\0\x16\x17\x91\x01Qb\xFF\0\0\x19\x90\x91\x16\x90\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17\x90UV[\x01\x92\x01\x92\x01\x91\x90a3\xA0V[\x82`\0R\x83` `\0 \x91\x82\x01\x91\x01[\x81\x81\x10a4)WPa3\x88V[`\0\x81U`\x01\x01a4\x1CV[\x90`\x02\x81\x10\x15a3;W`\x01\x1B\x01\x90`\0\x90V[\x90`\x01\x82\x01\x80\x92\x11a&\xBCWV[\x91\x90\x82\x01\x80\x92\x11a&\xBCWV[`@Q=`\0\x82>=\x90\xFD[`@Qc\x17\x11\x92)`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R` \x90\x82\x90`$\x90\x82\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a4\xEDWP\x90V[` \x81=` \x11a5$W[\x81a5\x06` \x93\x83a\x1B\xDEV[\x81\x01\x03\x12a\rbWQ\x90`\x01`\x01`\x80\x1B\x03\x82\x16\x82\x03a\rdWP\x90V[=\x91Pa4\xF9V[a54aC\x9BV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\x04]W`\0\x90`$`@Q\x80\x94\x81\x93cO\xFD.C`\xE0\x1B\x83R0`\x04\x84\x01RZ\xF1\x80\x15a\x0B\x05Wa5\x90WPV[`\0a\x1C\x0E\x91a\x1B\xDEV[\x90\x81Ta5\xA7\x81a2\x10V[\x92a5\xB5`@Q\x94\x85a\x1B\xDEV[\x81\x84R` \x84\x01\x90`\0R` `\0 `\0\x91[\x83\x83\x10a5\xD6WPPPPV[`\x02` `\x01\x92`@Qa5\xE9\x81a\x1BkV[`\xFF\x86T\x86\x80`\xA0\x1B\x03\x81\x16\x83R`\xA0\x1C\x16\x15\x15\x83\x82\x01R\x84\x86\x01T`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a5\xC9V[\x80\x15\x80\x15a6\xE2W[a\x11\x97W`\x04a6>a6D\x92`\0R`\x0B` R`@`\0 \x90V[\x01a5\x9BV[\x80Q`\0\x92\x91\x83\x91\x82\x91[\x81\x83\x10a6\x90WPPP\x80\x15\x15\x80a6\x87W[\x15a6\x7FWa6q\x83\x82aE^V[\x92a6|\x82\x82aE^V[\x92V[`\0\x92`\0\x92V[P\x82\x15\x15a6bV[\x90\x91\x92a6\xA5a)\xAF` a\x1A\x8A\x87\x86a3'V[\x15a6\xC7W`\x01\x90`@a6\xB9\x86\x85a3'V[Q\x01Q\x01\x93[\x01\x91\x90a6OV[\x92\x94`\x01\x90`@a6\xD8\x88\x85a3'V[Q\x01Q\x01\x95a6\xBFV[P`\nT\x81\x11a6!V[`@Q\x90a6\xFC` \x83a\x1B\xDEV[`\0\x80\x83R\x82\x81[\x82\x81\x10a7\x10WPPPV[` \x90a7\x1Ba2'V[\x82\x82\x85\x01\x01R\x01a7\x04V[\x90a71\x82a2\x10V[a7>`@Q\x91\x82a\x1B\xDEV[\x82\x81R\x80\x92a7O`\x1F\x19\x91a2\x10V[\x01\x90`\0[\x82\x81\x10a7`WPPPV[` \x90a7ka2'V[\x82\x82\x85\x01\x01R\x01a7TV[\x80T\x82\x10\x15a3;W`\0R` `\0 \x90`\x01\x1B\x01\x90`\0\x90V[\x80\x15\x80\x15a7\xD4W[a\x11\x97W`\0\x81\x81R`\x0B` R`@\x90 `\n\x81\x01T\x81T`\x02\x90\x92\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x90\x83\x16\x18\x90\x91\x16\x90\x91\x18\x18\x90V[P`\nT\x81\x11a7\x9CV[\x15a7\xE6WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FETH/DMT transfer failed\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`\0\x90`\0\x90`\x01T`\xFF\x81\x16a9\x03W[`\x08\x1C`\xFF\x16a8aW[`\x01`\x01`\x80\x1B\x03\x83\x16\x82\x81\x01\x80\x91\x11a&\xBCW\x92\x91\x90V[`@Qc\x12~\x8EM`\xE0\x1B\x81Rb\x01\x86\xA0`\x04\x82\x01R\x90\x91P` \x81`$\x81`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xFA\x90\x81\x15a\x0B\x05W`\0\x91a8\xE4W[Pa8\xC4a@\xF8V[\x81\x81\x10a8\xD6WPP`\0[\x90a8HV[a8\xDF\x91a;fV[a8\xD0V[a8\xFD\x91P` =` \x11a\n\xFEWa\n\xF0\x81\x83a\x1B\xDEV[8a8\xBBV[\x92P`\xFFa9\x0Fa4pV[\x93\x90Pa8=V[Q\x90a\x1C\x0E\x82a\r\x9DV[\x90\x81` \x91\x03\x12a\x04]WQa\x1C\xC7\x81a\r\x9DV[\x81Q\x81T` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U`@\x90\x91\x01Q`\x01\x90\x91\x01UV[\x80T`\x01`@\x1B\x81\x10\x15a\x1B\x86Wa9\x92\x91`\x01\x82\x01\x81Ua7wV[\x91\x90\x91a9\xA2Wa\x1C\x0E\x91a97V[cNH{q`\xE0\x1B`\0R`\0`\x04R`$`\0\xFD[\x90`@Q\x91a9\xC6\x83a\x1B\x8BV[`\0\x83[`\x02\x82\x10a9\xD7WPPPV[`\x02` `\x01\x92`@Qa9\xEA\x81a\x1B\x8BV[\x84\x80`\xA0\x1B\x03\x87T\x16\x81R\x84\x87\x01T\x83\x82\x01R\x81R\x01\x93\x01\x91\x01\x90\x91a9\xCAV[`\x05\x82\x10\x15a+\xEAWRV[\x90\x81Ta:#\x81a2\x10V[\x92a:1`@Q\x94\x85a\x1B\xDEV[\x81\x84R` \x84\x01\x90`\0R` `\0 `\0\x91[\x83\x83\x10a:RWPPPPV[`\x01` \x81\x92`@Qa:d\x81a\x1BkV[`\xFF\x86T\x81\x81\x16\x83R\x81\x81`\x08\x1C\x16\x85\x84\x01R`\x10\x1C\x16\x15\x15`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a:EV[\x90`\na:\x9Ba\x1C\x10V[\x92a:\xA5\x81a9\xB8V[\x84Ra:\xB3`\x04\x82\x01a5\x9BV[` \x85\x01R`\x05\x81\x01T`@\x85\x01Ra:\xDCa:\xD3`\x06\x83\x01T`\xFF\x16\x90V[``\x86\x01a:\x0BV[a:\xE8`\x07\x82\x01a:\x17V[`\x80\x85\x01Ra;\"a;\x18`\x08\x83\x01Ta;\x0Fa;\x05\x82`\xFF\x16\x90V[`\xFF\x16`\xA0\x89\x01RV[`\x08\x1C`\xFF\x16\x90V[`\xFF\x16`\xC0\x86\x01RV[`\t\x81\x01T`\xE0\x85\x01R\x01Ta\x01\0\x83\x01RV[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x03\x90p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x82\x11a&\xBCWV[\x91\x90\x82\x03\x91\x82\x11a&\xBCWV[\x90`\x02\x81\x10\x15a3;W`\x05\x1B\x01\x90V[`@Q\x90a\x1C\x0E`\xA0a;\x97\x81\x85a\x1B\xDEV[\x83a2FV[\x90`\x05\x81\x10\x15a3;W`\x05\x1B\x01\x90V[\x91\x90a\x01\xE0\x83\x01\x92`\0\x90[`\x05\x82\x10a;\xC7WPPPV[` a;\xF8`\x01\x92\x85Q\x90`@``\x92`\xFF\x81Q\x16\x83R`\xFF` \x82\x01Q\x16` \x84\x01R\x01Q\x15\x15`@\x82\x01R\x01\x90V[\x93\x01\x91\x01\x90\x91a;\xBAV[`@\x90\x81Q\x91a<\x13\x81\x84a\x1B\xDEV[6\x837V[`@Q\x90`\x80a<\x13\x81\x84a\x1B\xDEV[`@Q\x90`\x02`\0\x83[`\x02\x82\x10a<HWPPPa\x1C\x0E`@\x83a\x1B\xDEV[`\x01` \x81\x92\x85T\x81R\x01\x93\x01\x91\x01\x90\x91a<2V[\x91a<gaC\x9BV[a<q\x83QaG\xC8V[` \x83\x01\x91a<\x80\x83QaG\xC8V[` \x84Q\x01Q` \x84Q\x01Q\x14a+\0Wa>\x05\x93a>\x19\x7F\xD4x\xFA$r\x01\x1C\xA0y\x8D5\x11_\xC3\xCA\xA7&\x8CI\xCB}\xC8\x8A%\x184O\xC9c\x1B\xBF,\x93a=\x1A\x84`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a=\x05\x82a<\xFD\x88Q`\x01\x80`\xA0\x1B\x03\x90Q\x16\x90V[0\x90\x84aE\xBFV[\x88QQ0\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x90aE\xBFV[a=-a=(`\nTa>\x1FV[`\nUV[`\nT\x96\x87\x96`@\x92a=?\x84a\x1C/V[\x86QQ\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16` \x88Q\x01Qa=na=_a\x1C V[`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83RV[` \x82\x81\x01\x91\x90\x91R\x90\x84R\x81QQ`\x01`\x01`\xA0\x1B\x03\x16\x91Q\x01Qa=\x95a=_a\x1C V[` \x82\x01R` \x83\x01Ra=\xA7a6\xEDV[a=\xAFa2jV[\x90a=\xB8a\x1C\x10V[\x93\x84R` \x84\x01R\x87\x85\x84\x01R`\0``\x84\x01R`\x80\x83\x01R`\0`\xA0\x83\x01R`\0`\xC0\x83\x01R`\0`\xE0\x83\x01Ra\x01\0\x82\x01Ra>\0\x88`\0R`\x0B` R`@`\0 \x90V[a?IV[a>\x0E\x86aP\xB3V[PQ\x92\x83\x92\x83a?\xF5V[\x03\x90\xA2\x90V[`\0\x19\x81\x14a&\xBCW`\x01\x01\x90V[\x91a3i\x91\x83T\x90`\x03\x1B\x91\x82\x1B\x91`\0\x19\x90\x1B\x19\x16\x17\x90V[\x90`\0\x90[`\x02\x82\x10a>ZWPPPV[\x80Q\x80Q\x84T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x84U`\x01\x91`\x02\x91` \x91\x90\x82\x01Q\x84\x87\x01U\x01\x93\x01\x91\x01\x90\x91a>MV[\x81Q\x91`\x01`@\x1B\x83\x11a\x1B\x86W\x81T\x83\x83U\x80\x84\x10a>\xF4W[P` a>\xC5\x91\x01\x91`\0R` `\0 \x90V[`\0\x91[\x83\x83\x10a>\xD6WPPPPV[`\x02` \x82a>\xE8`\x01\x94Q\x86a97V[\x01\x92\x01\x92\x01\x91\x90a>\xC9V[`\x01`\x01`\xFF\x1B\x03\x81\x16\x81\x03a&\xBCW`\x01`\x01`\xFF\x1B\x03\x84\x16\x84\x03a&\xBCW\x82`\0R` `\0 \x90`\x01\x1B\x81\x01\x90\x84`\x01\x1B\x01[\x81\x81\x10a?7WPa>\xB1V[`\0\x80\x82U`\x01\x82\x01U`\x02\x01a?*V[\x90a\x01\0`\n\x91a?[\x81Q\x85a>HV[a?l` \x82\x01Q`\x04\x86\x01a>\x96V[`@\x81\x01Q`\x05\x85\x01Ua?\x90``\x82\x01Qa?\x87\x81a+\xE0V[`\x06\x86\x01a1\xF8V[a?\xA1`\x80\x82\x01Q`\x07\x86\x01a3mV[a?\xE4`\x08\x85\x01a?\xC9a?\xB9`\xA0\x85\x01Q`\xFF\x16\x90V[\x82T`\xFF\x19\x16`\xFF\x90\x91\x16\x17\x82UV[`\xC0\x83\x01Q\x81Ta\xFF\0\x19\x16`\x08\x91\x90\x91\x1Ba\xFF\0\x16\x17\x90UV[`\xE0\x81\x01Q`\t\x85\x01U\x01Q\x91\x01UV[`\xA0\x81\x01\x93\x92\x91`\0\x82[`\x02\x82\x10a@\x11WPPP`\x80\x01RV[\x82Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x90\x81\x01Q\x82\x82\x01R`\x01\x91`@\x01\x93\x01\x91\x01\x90\x91a@\0V[Q\x90a\x1C\x0E\x82a\x15qV[Q\x90c\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04]WV[Q\x90a\x1C\x0E\x82a\x16\xCAV[\x90\x81a\x01\0\x91\x03\x12a\x04]Wa@\xF0`\xE0`@Q\x92a@\x80\x84a\x1B\xA6V[a@\x89\x81a9\x17V[\x84Ra@\x97` \x82\x01a@;V[` \x85\x01Ra@\xA8`@\x82\x01a@FV[`@\x85\x01R``\x81\x01Q``\x85\x01Ra@\xC3`\x80\x82\x01a@;V[`\x80\x85\x01Ra@\xD4`\xA0\x82\x01a9\x17V[`\xA0\x85\x01Ra@\xE5`\xC0\x82\x01a@WV[`\xC0\x85\x01R\x01a@WV[`\xE0\x82\x01R\x90V[`@\x80Qc\x1F\xC5\x0E\xF5`\xE3\x1B\x81R0`\x04\x82\x01R\x90\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x0B\x05W`\0\x91\x82\x91aAZW[P\x81\x03\x90\x81\x11a&\xBCW\x90V[\x90P`@\x81=`@\x11aA\x8CW[\x81aAu`@\x93\x83a\x1B\xDEV[\x81\x01\x03\x12a\rbW` \x90\x80Q\x92P\x01Q8aAMV[=\x91PaAhV[\x90\x81` \x91\x03\x12a\x04]WQ\x90V[\x80\x15\x80\x15aB\xA2W[a\x11\x97WaA\xC4\x81`\0R`\x0B` R`@`\0 \x90V[`\x06\x81\x01\x90aA\xD4\x82T`\xFF\x16\x90V[\x91`\x05\x82\x01T\x92aA\xE4\x81a+\xE0V[`\x03\x81\x14\x90\x81\x15aB\x8EW[PaB\x88W\x80T`\xFF\x19\x16`\x04\x17\x90UaBa\x91a\x19P\x90aB\x11\x85aN/V[P\x82T`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x91aBM\x91\x84\x91\x16\x83aF\xC1V[aB[`\x02\x85\x01`\0a\x11\x1BV[\x90aF\xC1V[\x7F\xEC^\xA2?r\xA0\n.G}qM\xC0\x12\x98bq\xCD<\x96\xAD\x95\xC7\xFE_b\x9F\xF7\x98G\xFD!`\0\x80\xA2V[PPPPV[`\x04\x91PaB\x9B\x81a+\xE0V[\x148aA\xF0V[P`\nT\x81\x11aA\xACV[`\0[`\x02\x81\x10aB\xBCWPPV[`\x01\x90` \x83Q\x93\x01\x92\x81`\x02\x01U\x01aB\xB0V[`@\x81\x01\x92\x91a\x1C\x0E\x91\x90a\x1D\x82V[`\0aC-a\x05!aC!aB\xFE` \x95\x86\x81Q\x91\x01Q\x90aQ\xAEV[`@Q`\x7F`\xF9\x1B\x87\x82\x01R`\x03`\xF8\x1B`!\x82\x01R\x92\x83\x91`\"\x83\x01\x90aH\xF5V[`@Q\x91\x82\x80\x92aH\xF5V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0Q\x90V[` \x81Q\x91\x01Q\x90` \x81\x10aCRWP\x90V[`\0\x19\x90` \x03`\x03\x1B\x1B\x16\x90V[\x90\x81`\0R`\x07` R`\xFF`@`\0 T\x16\x15\x91`\0R`\x08` R`@`\0 T\x82\x80aC\x93W[a\x0C\xB1W\x91\x90V[P\x80\x15aC\x8BV[c\x8Bx\xC6\xD8`\x0CR3`\0R`\x01` `\x0C T\x16\x15aC\xB7WV[c\x8Bx\xC6\xD8\x19T3\x03aC\xC6WV[c\x82\xB4)\0`\0R`\x04`\x1C\xFD[c\x8Bx\xC6\xD8`\x0CR3`\0R`\x02` `\x0C T\x16\x15aC\xB7WV[`\0\x81\x15\x80\x15aDgW[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaD\x1F\x82a+\xE0V[`\x01\x82\x03aD,WPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaDF\x90`$\x90a,\0V[aDR`D`\x01a,\0V[`d`\0\xFD[c]\xF6&\xE1`\xE1\x1B\x81R`\x04\x90\xFD[P`\nT\x82\x11aC\xFBV[`\0\x81\x15\x80\x15aD\xD1W[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaD\xA1\x82a+\xE0V[\x81aD\xABWPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaD\xC5\x90`$\x90a,\0V[aDR`D`\0a,\0V[P`\nT\x82\x11aD}V[`\0\x81\x15\x80\x15aE>W[aDXW\x81\x81R`\x0B` R`@\x81 \x91`\xFF`\x06\x84\x01T\x16\x91PaE\x0B\x82a+\xE0V[`\x02\x82\x03aE\x18WPP\x90V[cwe\xDA5`\xE0\x1B`\0R`\x04RaE2\x90`$\x90a,\0V[aDR`D`\x02a,\0V[P`\nT\x82\x11aD\xE7V[\x90\x81` \x91\x03\x12a\x04]WQa\x1C\xC7\x81a\x15qV[x\x12r]\xD1\xD2C\xAB\xA0\xE7_\xE6E\xCCHs\xF9\xE6Z\xFEh\x8C\x92\x8E\x1F\"\x81\x10\x82\x02\x15aE\x8FWg\r\xE0\xB6\xB3\xA7d\0\0\x02\x04\x90V[c|_H}`\0R`\x04`\x1C\xFD[\x90`\x01`\x01`@\x1B\x03a\x1C\x0E\x92\x16\x80`\0R`\x05` R`@`\0 TaL\xA0V[\x91`@Q\x93``R`@R``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` `\0`d`\x1C\x82\x85Z\xF1\x90\x81`\x01`\0Q\x14\x16\x15aF\x02W[PP`\0``R`@RV[;\x15=\x17\x10\x15aF\x13W8\x80aE\xF6V[cy9\xF4$`\0R`\x04`\x1C\xFD[`\x02`\0T\x14aF2W`\x02`\0UV[c>\xE5\xAE\xB5`\xE0\x1B`\0R`\x04`\0\xFD[\x81\x81\x02\x91a'\x10\x81\x83\x85\x04\x14\x83\x15\x17\x02\x15aFbWPPa'\x10\x90\x04\x90V[a'\x10\x90`\0\x19\x81\x84\t\x84\x81\x10\x85\x01\x90\x03\x92\t\x90\x80a'\x10\x11\x15aF\xB3W\x82\x82\x11\x90\x03`\xFC\x1B\x91\x03`\x04\x1C\x17\x7F\xBC\x01\xA3n.\xB1\xC42\xCAW\xA7\x86\xC2&\x80\x9DIQ\x82\xA9\x93\x0B\xE0\xDE\xD2\x88\xCEp:\xFB~\x91\x02\x90V[c\xAEG\xF7\x02`\0R`\x04`\x1C\xFD[\x91\x90`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B`\0R` `\0`D`\x10\x82\x85Z\xF1\x90\x81`\x01`\0Q\x14\x16\x15aF\xF8W[PP`\0`4RV[;\x15=\x17\x10\x15aG\tW8\x80aF\xEFV[c\x90\xB8\xEC\x18`\0R`\x04`\x1C\xFD[\x90\x80`\0\x19\x04\x82\x11aG3W[g\r\xE0\xB6\xB3\xA7d\0\0\x91\x02\x04\x90V[\x80\x15aG$Wc\xBA\xC6^[`\0R`\x04`\x1C\xFD[`\x04aGS\x91\x01a5\x9BV[\x80Q\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90`\0[\x83\x81\x10aG\x91WPPPPV[`\x01\x90aG\xC2`\x01`\x01`\xA0\x1B\x03aG\xA9\x83\x86a3'V[QQ\x16`@aG\xB8\x84\x87a3'V[Q\x01Q\x90\x86aF\xC1V[\x01aG\x84V[\x90` \x82\x01\x90aG\xF4` \x83Q`@Q\x80\x93\x81\x92c1\xA9\x10\x8F`\xE1\x1B\x83R`\x04\x83\x01\x91\x90` \x83\x01\x92RV[\x03\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA`\0\x91\x81aH\x96W[PaHVW\x83Q\x83Qc\tg\xA7\xEB`\xE1\x1B`\0R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$R`D`\0\xFD[\x92Q\x90\x92`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x92\x91\x16\x82\x90\x03aHsWPPV[Qc\tg\xA7\xEB`\xE1\x1B`\0R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$R`D`\0\xFD[aH\xB0\x91\x92P` =` \x11a\x15%Wa\x15\x18\x81\x83a\x1B\xDEV[\x908aH+V[`\x01\x80`\xA0\x1B\x03\x16\x80c\x8Bx\xC6\xD8\x19T\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`\0\x80\xA3c\x8Bx\xC6\xD8\x19UV[\x90\x81Q\x91`\0[\x83\x81\x10aI\rWPP\x01`\0\x81R\x90V[\x80` \x80\x92\x84\x01\x01Q\x81\x85\x01R\x01aH\xFCV[\x92\x91aI/\x90\x94\x91\x94\x84aO#V[aI;\x86\x92\x96``\x01\x90V[\x80Q\x96\x90aIja)\xAF`@\x86\x01\x99\x8AQ\x99aIY\x81Q\x91` \x01\x90V[Q\x8AQ\x91` \x8C\x01\x9C\x8DQ\x94aQ\xE5V[\x90\x81\x15aJ\x0BW[P\x80\x15aI\xDEW[aI\xD2W`\x01`\x01`\x80\x1B\x03\x95aI\xCA\x95aI\xB0a(,\x96\x80Q\x90aI\x9F\x81` \x01\x90V[Q`@\x82\x01Q\x91``\x01Q\x92aS\"V[\x95\x90\x94aI\xBF\x82Q\x92` \x01\x90V[Q\x92Q\x93Q\x94aQ2V[\x91Q\x91\x16\x14\x90V[PPPPPPP`\0\x90V[PaJ\x06a)\xAF\x88Q\x85QaI\xF3\x87` \x01\x90V[Q`@\x89\x01Q\x91``\x8A\x01[Q\x93aR\xB9V[aIzV[aJ#\x91Pa)\xAF\x90Q\x86Q\x85\x85aI\xFF\x8A` \x01\x90V[8aIrV[\x91\x90`\x04aJDa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aKwWPaJ~aJb\x83`\0R`\x07` R`@`\0 \x90V[`\x04aJo\x82T`\xFF\x16\x90V[\x18`\xFF\x16`\xFF\x19\x82T\x16\x17\x90UV[a\x05!aJ\xB6aJ\x98\x84`\0R`\x08` R`@`\0 \x90V[T\x92`@Q\x92\x83\x91` \x83\x01\x95\x86\x90\x91`@\x92\x82R` \x82\x01R\x01\x90V[Q\x90 aJ\xCD\x82`\0R`\x08` R`@`\0 \x90V[U`\x04\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[\x15aK\x18WPV[\x80\x7F\xB2o\xE0\x8ENQ\xC0\x1E\\\xFF\xFF_H\x87$\x95\x99w\x9A\xA0\xD4\xF8co\xF4\xE7\xCDH1\xB4\x95\xED`\0\x80\xA2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aKfWPV[`\0\x90\x81R`\t` R`@\x81 UV[`@Q\x90\x81R`\x04\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01[\x03\x90\xA3V[\x91\x90`\x02aK\xCAa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aLiWPaK\xF5aK\xE8\x83`\0R`\x07` R`@`\0 \x90V[`\x02aJo\x82T`\xFF\x16\x90V[a\x05!aL\x0FaJ\x98\x84`\0R`\x08` R`@`\0 \x90V[Q\x90 aL&\x82`\0R`\x08` R`@`\0 \x90V[U`\x02\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[`@Q\x90\x81R`\x02\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01aK\xAAV[\x91\x90`\x01aL\xBBa\t\n\x85`\0R`\x07` R`@`\0 \x90V[\x16\x15aMZWPaL\xE6aL\xD9\x83`\0R`\x07` R`@`\0 \x90V[`\x01aJo\x82T`\xFF\x16\x90V[a\x05!aM\0aJ\x98\x84`\0R`\x08` R`@`\0 \x90V[Q\x90 aM\x17\x82`\0R`\x08` R`@`\0 \x90V[U`\x01\x81\x7F\xC1!\xD8\r\xEA&HH\x83\x1C\xF91\xFB\xB6V\xD7\xA7\x8Fz\x806\x17w\x9A\xD4\xA9)\xC0\x97\xDE\xCFU`\0\x80\xA3aK\x10a\x05>a\t\n\x83`\0R`\x07` R`@`\0 \x90V[`@Q\x90\x81R`\x01\x92\x91P\x7F%T\xBDoK\xAB\xDA\xFE@\xEE\xCD\xC6R\xD40\x11\xFDB\x03\x96e\xB8B\x1AE9W\xE1 \x97\x8C\0\x90\x80` \x81\x01aK\xAAV[c\x8Bx\xC6\xD8`\x0CR`\0R` `\x0C \x90\x81T\x90\x81\x16\x18\x80\x91U`\x0CQ``\x1C\x7FqZ\xD5\xCEa\xFC\x95\x95\xC7\xB4\x15(\x9DY\xCF ?#\xA9O\xA0o\x04\xAF~H\x9A\nv\xE1\xFE&`\0\x80\xA3V[\x80T\x82\x10\x15a3;W`\0R` `\0 \x01\x90`\0\x90V[\x80T\x80\x15aN\x19W`\0\x19\x01\x90aN\x07\x82\x82aM\xD8V[\x81T\x90`\0\x19\x90`\x03\x1B\x1B\x19\x16\x90UUV[cNH{q`\xE0\x1B`\0R`1`\x04R`$`\0\xFD[`\0\x81\x81R`\r` R`@\x90 T\x90\x81\x15aN\xD0W`\0\x19\x82\x01\x90\x82\x82\x11a&\xBCW`\x0CT`\0\x19\x81\x01\x93\x90\x84\x11a&\xBCW\x83\x83`\0\x95aN\x8F\x95\x03aN\x95W[PPPaN~`\x0CaM\xF0V[`\r\x90`\0R` R`@`\0 \x90V[U`\x01\x90V[aN~aN\xC1\x91aN\xB7aN\xADaN\xC7\x95`\x0CaM\xD8V[\x90T\x90`\x03\x1B\x1C\x90V[\x92\x83\x91`\x0CaM\xD8V[\x90a>.V[U8\x80\x80aNqV[PP`\0\x90V[`\x7F`\xF9\x1B\x81R`\x01`\xF8\x1B`\x01\x82\x01Ra\x1C\xC7\x92\x91aN\xFA\x91`\x02\x01\x90aH\xF5V[\x90aH\xF5V[aO\r\x90`\x01\x93\x92aH\xF5V[`\xF8\x91\x90\x91\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x81R\x01\x90V[aO=aOO\x91aO6\x81Q\x91` \x01\x90V[Q\x90aQ\xAEV[a\x05!`@Q\x93\x84\x92` \x84\x01aN\xD7V[`\0[a\x01\0`\xFF\x82\x16\x10aO\xA3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FNo valid point was found\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[` `\0aO\xBE`@QaC!\x81a\x05!\x87\x89\x88\x84\x01aO\0V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0QaO\xD5\x81aSSV[\x90aO\xE0\x82\x82aS\xB6V[aO\xF4WPPaO\xEF\x90a2\xDAV[aORV[\x93\x90\x92P\x90PV[aPa\x91\x92\x93aPYaPS\x7FH:\xDAw&\xA3\xC4e]\xA4\xFB\xFC\x0E\x11\x08\xA8\xFD\x17\xB4H\xA6\x85T\x19\x9CG\xD0\x8F\xFB\x10\xD4\xB8\x7Fy\xBEf~\xF9\xDC\xBB\xACU\xA0b\x95\xCE\x87\x0B\x07\x02\x9B\xFC\xDB-\xCE(\xD9Y\xF2\x81[\x16\xF8\x17\x98aPS\x95aU\x12V[\x91aU\x99V[\x95\x90\x94aU\x12V[d\x01\0\0\x03\xD0\x19\x03\x92d\x01\0\0\x03\xD0\x19\x84\x11a&\xBCWaP\x8A\x93d\x01\0\0\x03\xD0\x19\x90\x06\x92aTOV[\x90\x91V[aPSaPS\x93aPa\x95\x96\x97\x93aPY\x93aU\x12V[\x91aPS\x91aP\x8A\x93aU\x12V[\x80`\0R`\r` R`@`\0 T\x15`\0\x14aQ,W`\x0CT`\x01`@\x1B\x81\x10\x15a\x1B\x86W`\x01\x81\x01`\x0CU`\0`\x0CT\x82\x10\x15a3;W`\x0C\x90R\x7F\xDFif\xC9q\x05\x1C=T\xECY\x16&\x06S\x14\x93\xA5\x14\x04\xA0\x02\x84/V\0\x9D~\\\xF4\xA8\xC7\x01\x81\x90U`\x0CT\x90`\0R`\r` R`@`\0 U`\x01\x90V[P`\0\x90V[\x93aN\xFA`\0\x97aN\xFAaQr` \x9BaQlaQ\x98\x9BaQfaC!\x9BaQ`a\x05!\x9BaN\xFA\x9FaQ\xAEV[\x9BaQ\xAEV[\x97aQ\xAEV[\x93aQ\xAEV[`@Q`\x7F`\xF9\x1B\x8D\x82\x01R`\x01`\xF9\x1B`!\x82\x01R\x98\x89\x97\x91\x95\x91`\"\x89\x01\x90aH\xF5V[\x03\x90`\x02Z\xFA\x15a\x0B\x05W`\0Q\x80`@QR\x90V[\x90`\x01\x16`\x02\x01\x90\x81`\x02\x11a&\xBCW`@Q\x91`\xFF`\xF8\x1B\x90`\xF8\x1B\x16` \x83\x01R`!\x82\x01R`!\x81Ra\x1C\xC7`A\x82a\x1B\xDEV[\x91`\xFF\x91` \x94`\x01aR\x1AaQ\xFF`\0\x97\x9A\x99\x9Aa;6V[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x90\x06\x93a;6V[p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x90\x06\x91\x16\x15\x15\x85\x14aR\xB1W`\x1C\x92[`@Q\x94\x85\x94`\x80\x86\x01\x94\x83p\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t\x86R\x16\x87\x85\x01R\x80`@\x85\x01Rp\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t``\x83\x01R\x83\x80R\x03\x90`\x01Z\xFA\x15a\x0B\x05WaR\xA0\x90`\0Q\x92aT V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x90V[`\x1B\x92aR=V[\x92\x93\x92` \x92`\0\x92`\x80\x92\x90\x91`\x01\x16\x15aS\x1AW`\x1C\x91[`\xFF`@Q\x93\x86\x85R\x16\x86\x84\x01R\x80`@\x84\x01Rp\x01EQ#\x19P\xB7_\xC4@-\xA1s/\xC9\xBE\xBE\x19\x91\t``\x82\x01R\x82\x80R`\x01Z\xFA\x15a\x0B\x05WaR\xA0\x90`\0Q\x92aT V[`\x1B\x91aR\xD3V[\x91\x92d\x01\0\0\x03\xD0\x19\x03\x91d\x01\0\0\x03\xD0\x19\x83\x11a&\xBCWaP\x8A\x93d\x01\0\0\x03\xD0\x19\x93`\0\x93\x90\x85\x90\x06\x92aT\xB5V[aS\x89\x90c@\0\0\xF4`\x01`\xFE\x1B\x03\x90d\x01\0\0\x03\xD0\x19\x90\x81`\x07\x81`\0\x84\t\x08\x90d\x01\0\0\x03\xD0\x19\x90\x81\x81\x80\t\x90\t\x08a[\xEFV[`\x02\x81\x01\x80\x82\x11a&\xBCW`\x01\x16aS\x9EW\x90V[d\x01\0\0\x03\xD0\x19\x03d\x01\0\0\x03\xD0\x19\x81\x11a&\xBCW\x90V[\x80\x15\x80\x15aT\x10W[\x80\x15aT\x08W[\x80\x15aS\xF8W[aN\xD0Wd\x01\0\0\x03\xD0\x19\x90\x81\x81\x80\t\t`\x07d\x01\0\0\x03\xD0\x19\x91\x08\x90d\x01\0\0\x03\xD0\x19\x90\x80\t\x14\x90V[Pd\x01\0\0\x03\xD0\x19\x82\x10\x15aS\xCDV[P\x81\x15aS\xC6V[Pd\x01\0\0\x03\xD0\x19\x81\x10\x15aS\xBFV[`@Q\x91` \x83\x01\x91\x82R`@\x83\x01R`@\x82RaT?``\x83a\x1B\xDEV[\x90Q\x90 `\x01`\x01`\xA0\x1B\x03\x16\x90V[\x92\x90\x91\x80\x84\x03aT\x98WPd\x01\0\0\x03\xD0\x19\x90\x82\x08aTrWPP`\0\x90`\0\x90V[aP\x8A\x91`\0aT\x89\x92d\x01\0\0\x03\xD0\x19\x92aZ\xA8V[\x90[d\x01\0\0\x03\xD0\x19\x92aV\x9CV[aP\x8A\x93aT\xAF\x93d\x01\0\0\x03\xD0\x19\x93\x92\x91aW~V[\x90aT\x8BV[\x93\x94\x93\x90\x92\x90\x91\x80\x83\x03aT\xF8WP\x83\x15aT\xF3W\x83\x90\x83\x08aT\xDEWPPPP`\0\x90`\0\x90V[aP\x8A\x93aT\xED\x92\x84\x92aZ\xA8V[\x91aV\x9CV[a2\xEBV[aP\x8A\x95PaT\xED\x93\x85\x93aW~V[\x81\x15aT\xF3W\x04\x90V[\x92\x90\x91\x92`\x01\x90\x80\x15aU\x8FW`\0\x94`\x01\x94\x86\x93\x92\x80[aU7WPPPP\x92\x91\x90V[`\x01\x81\x16aUcW[\x90`\0aUZ\x92`\x01\x1C\x94\x85\x94d\x01\0\0\x03\xD0\x19\x93a[\x1EV[\x92\x90\x92\x93aU*V[\x93aU\x80\x90\x84\x84\x84`\0\x9AaUZ\x96\x9Cd\x01\0\0\x03\xD0\x19\x95aY\x14V[\x90\x98\x90\x97P\x90\x94\x90\x91PaU@V[PP\x90\x91\x90`\x01\x90V[\x91\x92\x91\x90`\0\x84\x15\x15\x85\x81aV\x8BW[P\x80aV\x83W[\x15aVMW`\0\x94\x90\x85d\x01\0\0\x03\xD0\x19`\x01\x84[aU\xF4WPPPPPd\x01\0\0\x03\xD0\x19\x84\x80\t\x91\x82d\x01\0\0\x03\xD0\x19\x91\t\x93d\x01\0\0\x03\xD0\x19\x92\x83\x91\t\x90\t\x90V[aV\x02\x85\x83\x9A\x95\x96\x9AaU\x08V[\x91\x81\x93aT\xF3WaV>aV)aVD\x93d\x01\0\0\x03\xD0\x19\x90\x86\td\x01\0\0\x03\xD0\x19a;fV[\x87\x96d\x01\0\0\x03\xD0\x19\x91\x90\x08\x94\x9A\x80\x94a3VV[\x90a;fV[\x93\x92\x91\x84aU\xC5V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm$\xB7;0\xB64\xB2\x107:\xB6\xB12\xB9`\x91\x1B`D\x82\x01R`d\x90\xFD[P`\x01aU\xB0V[d\x01\0\0\x03\xD0\x19\x14\x15\x90P8aU\xA9V[\x91\x93\x92\x91\x84\x15\x15\x83\x86\x82aW'W[PP\x80aW\x1EW[\x15aVMW`\0\x94\x83\x15\x90\x81\x85`\x01\x83[aV\xE1WPPPPaT\xF3W\x82\x90\x81\x80\x87\x80\t\x80\x92\t\x95\t\x90\t\x90V[aV\xEE\x84\x83\x9B\x95\x9BaU\x08V[\x91\x81\x93aT\xF3WaV>\x89aW\t\x81aW\x16\x95\x87\t\x82a;fV[`\0\x97\x08\x94\x9B\x80\x94a3VV[\x92\x91\x83aV\xC4V[P\x82\x15\x15aV\xB3V[\x14\x15\x90P\x838aV\xABV[\x15aW9WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FUse jacDouble function instead\0\0`D\x82\x01R`d\x90\xFD[\x93\x91\x90\x94\x92\x84\x15\x80aY\x0CW[aY\0W\x81\x15\x80aX\xF8W[aX\xEDWaW\xA3a<\x18V[\x95\x83\x15aT\xF3W\x83\x80\x93\x81`\x01\x80\t\x80\x8AR\x98\x82\x80\x8B`\x01\t\x94` \x83\x01\x95\x86R`@\x83\x01\x8C\x81R\x9A\x82\x80\x8E`\x01\t\x91``\x86\x01\x92\x83RaW\xE4`\x80a\x1C/V[\x9DQ\x90\t\x8CRQ\x90\t` \x8A\x01RQ\x90\t`@\x87\x01RQ\x90\t``\x84\x01R\x82Q\x93`@\x84\x01\x94\x85Q\x14\x80\x15\x90aX\xDBW[aX\x1E\x90aW2V[\x81aX'a<\x18V[\x95QaX4\x86Q\x83a;fV[\x90\x08\x85R\x81``\x85\x01QaX\xD0\x82\x88\x81\x80` \x8B\x01\x95aXU\x87Q\x83a;fV[\x90\x08\x99` \x83\x01\x9A\x8BR\x81\x80\x8C\x81\x80\x80\x80\x89Q\x8AQ\x90\t\x93`@\x8A\x01\x94\x85RaX\x85\x82\x86Q\x8CQ\x90\t\x9A``\x01\x90V[\x99\x8ARQ\x80\taX\x96\x89Q\x83a;fV[\x90\x08aX\xAC\x82\x80\x88Q\x86Q\x90\t`\x02\t\x83a;fV[\x90\x08\x9DQ\x93Q\x90Q\x90\taX\xC0\x8D\x83a;fV[\x90\x08\x90\t\x93Q\x90Q\x90\t\x83a;fV[\x90\x08\x94Q\t\x91\x92\x91\x90V[P` \x84\x01Q``\x85\x01Q\x14\x15aX\x15V[PPP\x90\x91\x90`\x01\x90V[P\x80\x15aW\x97V[\x90\x94P\x92P`\x01\x91\x90PV[P\x85\x15aW\x8BV[\x96\x94\x96\x95\x93\x90\x91\x95\x80\x15\x80aZ\xA0W[aZ\x94W\x83\x15\x80aZ\x8CW[aZ\x81WaY<a<\x18V[\x92\x85\x15aT\xF3W\x88\x94\x86\x94\x85\x80\x93\x81\x8C\x80\t\x83R\x81\x83Q\x8D\t\x95` \x84\x01\x96\x87R\x82\x80`@\x86\x01\x9B\x81\x81\x80\t\x80\x8ER\x90\t\x91``\x86\x01\x92\x83RaY\x7F`\x80a\x1C/V[\x9BQ\x90\t\x8ARQ\x90\t` \x88\x01RQ\x90\t`@\x85\x01RQ\x90\t``\x82\x01R\x81\x81Q\x95aY\xAB\x83`@\x01\x90V[\x96\x87Q\x14\x80\x15\x90aZoW[aY\xC0\x90aW2V[\x81aY\xC9a<\x18V[\x97QaY\xD6\x85Q\x83a;fV[\x90\x08\x87R\x81``\x84\x01QaZb\x82\x8A\x81\x80` \x8A\x01\x95aY\xF7\x87Q\x83a;fV[\x90\x08\x98` \x83\x01\x99\x8AR\x81\x80\x8B\x81\x80\x80\x80\x89Q\x8AQ\x90\t\x93`@\x8A\x01\x94\x85RaZ'\x82\x86Q\x8CQ\x90\t\x9A``\x01\x90V[\x99\x8ARQ\x80\taZ8\x89Q\x83a;fV[\x90\x08aZN\x82\x80\x88Q\x86Q\x90\t`\x02\t\x83a;fV[\x90\x08\x9CQ\x93Q\x90Q\x90\taX\xC0\x8C\x83a;fV[\x90\x08\x96Q\x92\x96\x95\t\x90\t\x90V[P` \x83\x01Q``\x84\x01Q\x14\x15aY\xB7V[\x93PP\x94PP\x92\x91\x90V[P\x81\x15aY0V[P\x95\x94PP\x90P\x92\x91\x90V[P\x82\x15aY$V[\x93\x91\x93\x92\x90\x92\x81\x15aT\xF3W\x81\x80\x85\x80\t\x91\x81\x80\x80\x80`\x01\x80\t\x99\x81\x80\x80\x89\x88\t`\x04\t\x9B\x80\t\x90\t\x92\x80\t`\x03\t\x08\x82\x86\x80\x08\x83\x03\x83\x81\x11a&\xBCW\x83\x90\x81\x83\x80\t\x08\x80\x84\x03\x92\x84\x84\x11a&\xBCW\x84\x80\x91\x80\t`\x08\t\x84\x03\x84\x81\x11a&\xBCW\x84`\x01\x93\x81\x80\x96\x81\x95\x9B\x08\x90\t\x08\x94\t`\x02\t\x90V[\x90\x93\x91\x94\x92\x94\x80\x15a[\x9BW\x82\x15aT\xF3W\x82\x80\x86\x80\t\x92\x81\x80\x80\x80\x86\x80\t\x9A\x81\x80\x80\x8A\x88\t`\x04\t\x9C\x80\t\x90\t\x92\x80\t`\x03\t\x08\x91\x83\x87\x80\x08\x84\x03\x84\x81\x11a&\xBCW\x84\x90\x81\x85\x80\t\x08\x90\x81\x85\x03\x90\x85\x82\x11a&\xBCW\x85\x80\x91\x80\t`\x08\t\x85\x03\x90\x85\x82\x11a&\xBCW\x85\x94\x85\x80\x94\x92\x81\x93\x9B\x08\x90\t\x08\x94\t`\x02\t\x90V[\x90\x94P\x91\x90PV[\x15a[\xAAWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FEllipticCurve: modulus is zero\0\0`D\x82\x01R`d\x90\xFD[a[\xF9`\x01a[\xA3V[\x80\x15aN\xD0W\x81\x15a\\\x90W`\x01\x91`\x01`\xFF\x1B\x91\x90\x82[a\\\x1BWPPP\x90V[\x90\x91\x92d\x01\0\0\x03\xD0\x19\x90\x84\x83\x16\x15\x15\x84\n\x90d\x01\0\0\x03\xD0\x19\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x01\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x02\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\td\x01\0\0\x03\xD0\x19\x90`\x03\x85\x90\x1C\x83\x16\x15\x15\x84\n\x90\x82\x90\x80\t\t\x92`\x04\x1C\x91\x90\x82a\\\x11V[PP`\x01\x90V\xFE\xA2dipfsX\"\x12 \x8BNh\xC1\xC7w\xD9U3k\xE7\x8B\x0E$\x97!\xA2\x06f\x14/\xDE\xD4\xCA(`$\xA6?\x85\xFCOdsolcC\0\x08\x1C\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<GameStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl GameStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct GameData { Player[2] players; Speculation[] speculations; uint256 amount; GameStatus status; RoundResult[] rounds; uint8 p1_wins; uint8 p2_wins; uint256 bet_pool; bytes32 alpha_prefix; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameData {
        #[allow(missing_docs)]
        pub players: [<Player as alloy::sol_types::SolType>::RustType; 2usize],
        #[allow(missing_docs)]
        pub speculations: alloy::sol_types::private::Vec<
            <Speculation as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub status: <GameStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub rounds: alloy::sol_types::private::Vec<
            <RoundResult as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub p1_wins: u8,
        #[allow(missing_docs)]
        pub p2_wins: u8,
        #[allow(missing_docs)]
        pub bet_pool: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub alpha_prefix: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<Player, 2usize>,
            alloy::sol_types::sol_data::Array<Speculation>,
            alloy::sol_types::sol_data::Uint<256>,
            GameStatus,
            alloy::sol_types::sol_data::Array<RoundResult>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [<Player as alloy::sol_types::SolType>::RustType; 2usize],
            alloy::sol_types::private::Vec<
                <Speculation as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::primitives::aliases::U256,
            <GameStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Vec<
                <RoundResult as alloy::sol_types::SolType>::RustType,
            >,
            u8,
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameData> for UnderlyingRustTuple<'_> {
            fn from(value: GameData) -> Self {
                (
                    value.players,
                    value.speculations,
                    value.amount,
                    value.status,
                    value.rounds,
                    value.p1_wins,
                    value.p2_wins,
                    value.bet_pool,
                    value.alpha_prefix,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    players: tuple.0,
                    speculations: tuple.1,
                    amount: tuple.2,
                    status: tuple.3,
                    rounds: tuple.4,
                    p1_wins: tuple.5,
                    p2_wins: tuple.6,
                    bet_pool: tuple.7,
                    alpha_prefix: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GameData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GameData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        Player,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.players),
                    <alloy::sol_types::sol_data::Array<
                        Speculation,
                    > as alloy_sol_types::SolType>::tokenize(&self.speculations),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <GameStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::Array<
                        RoundResult,
                    > as alloy_sol_types::SolType>::tokenize(&self.rounds),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.p1_wins),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.p2_wins),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bet_pool),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.alpha_prefix),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GameData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GameData {
            const NAME: &'static str = "GameData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GameData(Player[2] players,Speculation[] speculations,uint256 amount,uint8 status,RoundResult[] rounds,uint8 p1_wins,uint8 p2_wins,uint256 bet_pool,bytes32 alpha_prefix)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(3);
                components
                    .push(<Player as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Player as alloy_sol_types::SolStruct>::eip712_components());
                components
                    .push(
                        <Speculation as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <Speculation as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <RoundResult as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <RoundResult as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        Player,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.players)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        Speculation,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.speculations)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <GameStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        RoundResult,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.rounds)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.p1_wins)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.p2_wins)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bet_pool)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.alpha_prefix)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GameData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        Player,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.players,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        Speculation,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.speculations,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <GameStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        RoundResult,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rounds,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.p1_wins,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.p2_wins,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bet_pool,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.alpha_prefix,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    Player,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.players,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    Speculation,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.speculations,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <GameStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    RoundResult,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rounds,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.p1_wins,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.p2_wins,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bet_pool,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.alpha_prefix,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct OnkaStats { uint256 plays; uint256 wins; uint256 losses; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnkaStats {
        #[allow(missing_docs)]
        pub plays: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub wins: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub losses: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnkaStats> for UnderlyingRustTuple<'_> {
            fn from(value: OnkaStats) -> Self {
                (value.plays, value.wins, value.losses)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OnkaStats {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    plays: tuple.0,
                    wins: tuple.1,
                    losses: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OnkaStats {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OnkaStats {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.plays),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.wins),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.losses),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OnkaStats {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OnkaStats {
            const NAME: &'static str = "OnkaStats";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OnkaStats(uint256 plays,uint256 wins,uint256 losses)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.plays)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.wins)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.losses)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OnkaStats {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.plays)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.wins)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.losses,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.plays,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.wins,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.losses,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Player { address addr; uint256 nft_id; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Player {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nft_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Player> for UnderlyingRustTuple<'_> {
            fn from(value: Player) -> Self {
                (value.addr, value.nft_id)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Player {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    nft_id: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Player {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Player {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nft_id),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Player {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Player {
            const NAME: &'static str = "Player";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Player(address addr,uint256 nft_id)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nft_id)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Player {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nft_id,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nft_id,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct RoundResult { uint8 roll_p1; uint8 roll_p2; bool p1_won; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundResult {
        #[allow(missing_docs)]
        pub roll_p1: u8,
        #[allow(missing_docs)]
        pub roll_p2: u8,
        #[allow(missing_docs)]
        pub p1_won: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8, bool);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundResult> for UnderlyingRustTuple<'_> {
            fn from(value: RoundResult) -> Self {
                (value.roll_p1, value.roll_p2, value.p1_won)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundResult {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    roll_p1: tuple.0,
                    roll_p2: tuple.1,
                    p1_won: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for RoundResult {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for RoundResult {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.roll_p1),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.roll_p2),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.p1_won,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for RoundResult {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for RoundResult {
            const NAME: &'static str = "RoundResult";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "RoundResult(uint8 roll_p1,uint8 roll_p2,bool p1_won)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.roll_p1)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.roll_p2)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.p1_won,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for RoundResult {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.roll_p1,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.roll_p2,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.p1_won,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.roll_p1,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.roll_p2,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.p1_won,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Speculation { address speculator; bool prediction; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Speculation {
        #[allow(missing_docs)]
        pub speculator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub prediction: bool,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Speculation> for UnderlyingRustTuple<'_> {
            fn from(value: Speculation) -> Self {
                (value.speculator, value.prediction, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Speculation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    speculator: tuple.0,
                    prediction: tuple.1,
                    amount: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Speculation {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Speculation {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.speculator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.prediction,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Speculation {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Speculation {
            const NAME: &'static str = "Speculation";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Speculation(address speculator,bool prediction,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.speculator,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prediction,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Speculation {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.speculator,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prediction,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.speculator,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prediction,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `GameExecNotReady()` and selector `0x32926edd`.
```solidity
error GameExecNotReady();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GameExecNotReady {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GameExecNotReady> for UnderlyingRustTuple<'_> {
            fn from(value: GameExecNotReady) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GameExecNotReady {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GameExecNotReady {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GameExecNotReady()";
            const SELECTOR: [u8; 4] = [50u8, 146u8, 110u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientBalance(uint256,uint256,address)` and selector `0x832f98b5`.
```solidity
error InsufficientBalance(uint256 balance, uint256 required, address addr);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.required, value.addr)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    required: tuple.1,
                    addr: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256,address)";
            const SELECTOR: [u8; 4] = [131u8, 47u8, 152u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientFee(uint256,uint256)` and selector `0xa458261b`.
```solidity
error InsufficientFee(uint256 fee_supplied, uint256 required);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientFee {
        #[allow(missing_docs)]
        pub fee_supplied: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientFee> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientFee) -> Self {
                (value.fee_supplied, value.required)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientFee {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    fee_supplied: tuple.0,
                    required: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientFee {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientFee(uint256,uint256)";
            const SELECTOR: [u8; 4] = [164u8, 88u8, 38u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee_supplied),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                )
            }
        }
    };
    /**Custom error with signature `InvalidAmount()` and selector `0x2c5211c6`.
```solidity
error InvalidAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAmount()";
            const SELECTOR: [u8; 4] = [44u8, 82u8, 17u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidGame()` and selector `0x57e25a09`.
```solidity
error InvalidGame();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidGame {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidGame> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidGame) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidGame {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidGame {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidGame()";
            const SELECTOR: [u8; 4] = [87u8, 226u8, 90u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidGameID()` and selector `0xbbec4dc2`.
```solidity
error InvalidGameID();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidGameID {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidGameID> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidGameID) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidGameID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidGameID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidGameID()";
            const SELECTOR: [u8; 4] = [187u8, 236u8, 77u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidGameStatus(uint256,uint8,uint8)` and selector `0x7765da35`.
```solidity
error InvalidGameStatus(uint256 game_id, GameStatus current, GameStatus required);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidGameStatus {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub current: <GameStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub required: <GameStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            GameStatus,
            GameStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            <GameStatus as alloy::sol_types::SolType>::RustType,
            <GameStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidGameStatus> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidGameStatus) -> Self {
                (value.game_id, value.current, value.required)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidGameStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    game_id: tuple.0,
                    current: tuple.1,
                    required: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidGameStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidGameStatus(uint256,uint8,uint8)";
            const SELECTOR: [u8; 4] = [119u8, 101u8, 218u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                    <GameStatus as alloy_sol_types::SolType>::tokenize(&self.current),
                    <GameStatus as alloy_sol_types::SolType>::tokenize(&self.required),
                )
            }
        }
    };
    /**Custom error with signature `InvalidInput()` and selector `0xb4fa3fb3`.
```solidity
error InvalidInput();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInput {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInput> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInput) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInput {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInput {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInput()";
            const SELECTOR: [u8; 4] = [180u8, 250u8, 63u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidNFTOwnership(address,uint256)` and selector `0x12cf4fd6`.
```solidity
error InvalidNFTOwnership(address player, uint256 nft_id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNFTOwnership {
        #[allow(missing_docs)]
        pub player: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nft_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNFTOwnership> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNFTOwnership) -> Self {
                (value.player, value.nft_id)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNFTOwnership {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    player: tuple.0,
                    nft_id: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNFTOwnership {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNFTOwnership(address,uint256)";
            const SELECTOR: [u8; 4] = [18u8, 207u8, 79u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.player,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nft_id),
                )
            }
        }
    };
    /**Custom error with signature `InvalidPrediction()` and selector `0xea0599f8`.
```solidity
error InvalidPrediction();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidPrediction {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidPrediction> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidPrediction) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPrediction {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidPrediction {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidPrediction()";
            const SELECTOR: [u8; 4] = [234u8, 5u8, 153u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidRequest()` and selector `0x41abc801`.
```solidity
error InvalidRequest();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidRequest {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidRequest> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidRequest) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidRequest {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidRequest()";
            const SELECTOR: [u8; 4] = [65u8, 171u8, 200u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidVRFProof(string)` and selector `0xfbda4f68`.
```solidity
error InvalidVRFProof(string);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidVRFProof {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidVRFProof> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidVRFProof) -> Self {
                (value._0,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidVRFProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { _0: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidVRFProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidVRFProof(string)";
            const SELECTOR: [u8; 4] = [251u8, 218u8, 79u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NewOwnerIsZeroAddress()` and selector `0x7448fbae`.
```solidity
error NewOwnerIsZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewOwnerIsZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewOwnerIsZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: NewOwnerIsZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewOwnerIsZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewOwnerIsZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewOwnerIsZeroAddress()";
            const SELECTOR: [u8; 4] = [116u8, 72u8, 251u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NoHandoverRequest()` and selector `0x6f5e8818`.
```solidity
error NoHandoverRequest();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoHandoverRequest {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoHandoverRequest> for UnderlyingRustTuple<'_> {
            fn from(value: NoHandoverRequest) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoHandoverRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoHandoverRequest {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoHandoverRequest()";
            const SELECTOR: [u8; 4] = [111u8, 94u8, 136u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `RegistrationFailed(string)` and selector `0x43417c44`.
```solidity
error RegistrationFailed(string reason);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RegistrationFailed {
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RegistrationFailed> for UnderlyingRustTuple<'_> {
            fn from(value: RegistrationFailed) -> Self {
                (value.reason,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RegistrationFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { reason: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RegistrationFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RegistrationFailed(string)";
            const SELECTOR: [u8; 4] = [67u8, 65u8, 124u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `RequestCollision(uint256)` and selector `0x6ae00967`.
```solidity
error RequestCollision(uint256 req_id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RequestCollision {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RequestCollision> for UnderlyingRustTuple<'_> {
            fn from(value: RequestCollision) -> Self {
                (value.req_id,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RequestCollision {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { req_id: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RequestCollision {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RequestCollision(uint256)";
            const SELECTOR: [u8; 4] = [106u8, 224u8, 9u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.req_id),
                )
            }
        }
    };
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnauthorizedCaller()` and selector `0x5c427cd9`.
```solidity
error UnauthorizedCaller();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedCaller {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedCaller> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedCaller()";
            const SELECTOR: [u8; 4] = [92u8, 66u8, 124u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `BetPlaced(uint256,address,bool,uint256)` and selector `0x4af71b021e799c62c158bd54636ca8da2fa26115a21a2dc6efe486ec104fd15f`.
```solidity
event BetPlaced(uint256 indexed game_id, address indexed addr, bool indexed prediction, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BetPlaced {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub prediction: bool,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BetPlaced {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            const SIGNATURE: &'static str = "BetPlaced(uint256,address,bool,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                247u8,
                27u8,
                2u8,
                30u8,
                121u8,
                156u8,
                98u8,
                193u8,
                88u8,
                189u8,
                84u8,
                99u8,
                108u8,
                168u8,
                218u8,
                47u8,
                162u8,
                97u8,
                21u8,
                162u8,
                26u8,
                45u8,
                198u8,
                239u8,
                228u8,
                134u8,
                236u8,
                16u8,
                79u8,
                209u8,
                95u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    game_id: topics.1,
                    addr: topics.2,
                    prediction: topics.3,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.game_id.clone(),
                    self.addr.clone(),
                    self.prediction.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.addr,
                );
                out[3usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.prediction,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BetPlaced {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BetPlaced> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BetPlaced) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CallbackOnInactiveGame(uint256,uint8)` and selector `0x18fb44cbce383d1bc9624794b0924ab477b95be59adbb384c75e4405e474d48d`.
```solidity
event CallbackOnInactiveGame(uint256 indexed game_id, GameStatus indexed status);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CallbackOnInactiveGame {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub status: <GameStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CallbackOnInactiveGame {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                GameStatus,
            );
            const SIGNATURE: &'static str = "CallbackOnInactiveGame(uint256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                24u8,
                251u8,
                68u8,
                203u8,
                206u8,
                56u8,
                61u8,
                27u8,
                201u8,
                98u8,
                71u8,
                148u8,
                176u8,
                146u8,
                74u8,
                180u8,
                119u8,
                185u8,
                91u8,
                229u8,
                154u8,
                219u8,
                179u8,
                132u8,
                199u8,
                94u8,
                68u8,
                5u8,
                228u8,
                116u8,
                212u8,
                141u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    game_id: topics.1,
                    status: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone(), self.status.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                out[2usize] = <GameStatus as alloy_sol_types::EventTopic>::encode_topic(
                    &self.status,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CallbackOnInactiveGame {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CallbackOnInactiveGame> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CallbackOnInactiveGame) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CallbackOnInactiveRequest(uint256,uint8,uint256)` and selector `0x2554bd6f4babdafe40eecdc652d43011fd42039665b8421a453957e120978c00`.
```solidity
event CallbackOnInactiveRequest(uint256 indexed req_id, uint8 indexed flag, uint256 sequence_number);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CallbackOnInactiveRequest {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub flag: u8,
        #[allow(missing_docs)]
        pub sequence_number: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CallbackOnInactiveRequest {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str = "CallbackOnInactiveRequest(uint256,uint8,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                37u8,
                84u8,
                189u8,
                111u8,
                75u8,
                171u8,
                218u8,
                254u8,
                64u8,
                238u8,
                205u8,
                198u8,
                82u8,
                212u8,
                48u8,
                17u8,
                253u8,
                66u8,
                3u8,
                150u8,
                101u8,
                184u8,
                66u8,
                26u8,
                69u8,
                57u8,
                87u8,
                225u8,
                32u8,
                151u8,
                140u8,
                0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    req_id: topics.1,
                    flag: topics.2,
                    sequence_number: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequence_number),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.req_id.clone(), self.flag.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.req_id);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.flag);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CallbackOnInactiveRequest {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CallbackOnInactiveRequest> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &CallbackOnInactiveRequest,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameAborted(uint256)` and selector `0xec5ea23f72a00a2e477d714dc012986271cd3c96ad95c7fe5f629ff79847fd21`.
```solidity
event GameAborted(uint256 indexed game_id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameAborted {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameAborted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "GameAborted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                94u8,
                162u8,
                63u8,
                114u8,
                160u8,
                10u8,
                46u8,
                71u8,
                125u8,
                113u8,
                77u8,
                192u8,
                18u8,
                152u8,
                98u8,
                113u8,
                205u8,
                60u8,
                150u8,
                173u8,
                149u8,
                199u8,
                254u8,
                95u8,
                98u8,
                159u8,
                247u8,
                152u8,
                71u8,
                253u8,
                33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { game_id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameAborted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameAborted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameAborted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameCompleted(uint256,uint8,(uint8,uint8,bool)[5])` and selector `0x8ef01de748555cd1d5431d653dab86432a1d7d75096621deca7a6e4b414de636`.
```solidity
event GameCompleted(uint256 indexed game_id, uint8 indexed winner, RoundResult[5] rounds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameCompleted {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub winner: u8,
        #[allow(missing_docs)]
        pub rounds: [<RoundResult as alloy::sol_types::SolType>::RustType; 5usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<RoundResult, 5usize>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str = "GameCompleted(uint256,uint8,(uint8,uint8,bool)[5])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                142u8,
                240u8,
                29u8,
                231u8,
                72u8,
                85u8,
                92u8,
                209u8,
                213u8,
                67u8,
                29u8,
                101u8,
                61u8,
                171u8,
                134u8,
                67u8,
                42u8,
                29u8,
                125u8,
                117u8,
                9u8,
                102u8,
                33u8,
                222u8,
                202u8,
                122u8,
                110u8,
                75u8,
                65u8,
                77u8,
                230u8,
                54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    game_id: topics.1,
                    winner: topics.2,
                    rounds: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        RoundResult,
                        5usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.rounds),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone(), self.winner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.winner);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameCreated(uint256,(address,uint256)[2],uint256)` and selector `0xd478fa2472011ca0798d35115fc3caa7268c49cb7dc88a2518344fc9631bbf2c`.
```solidity
event GameCreated(uint256 indexed game_id, Player[2] players, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameCreated {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub players: [<Player as alloy::sol_types::SolType>::RustType; 2usize],
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameCreated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<Player, 2usize>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "GameCreated(uint256,(address,uint256)[2],uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                212u8,
                120u8,
                250u8,
                36u8,
                114u8,
                1u8,
                28u8,
                160u8,
                121u8,
                141u8,
                53u8,
                17u8,
                95u8,
                195u8,
                202u8,
                167u8,
                38u8,
                140u8,
                73u8,
                203u8,
                125u8,
                200u8,
                138u8,
                37u8,
                24u8,
                52u8,
                79u8,
                201u8,
                99u8,
                27u8,
                191u8,
                44u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    game_id: topics.1,
                    players: data.0,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        Player,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.players),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameExecuted(uint256)` and selector `0x31543961bad6e1b886fe4b3c060d3d97c21fbc80e63ab22e9eea65d9d2dc7c77`.
```solidity
event GameExecuted(uint256 indexed game_id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameExecuted {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameExecuted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "GameExecuted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                84u8,
                57u8,
                97u8,
                186u8,
                214u8,
                225u8,
                184u8,
                134u8,
                254u8,
                75u8,
                60u8,
                6u8,
                13u8,
                61u8,
                151u8,
                194u8,
                31u8,
                188u8,
                128u8,
                230u8,
                58u8,
                178u8,
                46u8,
                158u8,
                234u8,
                101u8,
                217u8,
                210u8,
                220u8,
                124u8,
                119u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { game_id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `GameStarted(uint256)` and selector `0x50ad08f58a27f2851d7e3a1b3a6a46b290f2ce677e99642d30ff639721e77790`.
```solidity
event GameStarted(uint256 indexed game_id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GameStarted {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GameStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "GameStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                80u8,
                173u8,
                8u8,
                245u8,
                138u8,
                39u8,
                242u8,
                133u8,
                29u8,
                126u8,
                58u8,
                27u8,
                58u8,
                106u8,
                70u8,
                178u8,
                144u8,
                242u8,
                206u8,
                103u8,
                126u8,
                153u8,
                100u8,
                45u8,
                48u8,
                255u8,
                99u8,
                151u8,
                33u8,
                231u8,
                119u8,
                144u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { game_id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.game_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.game_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GameStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GameStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &GameStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipHandoverCanceled(address)` and selector `0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92`.
```solidity
event OwnershipHandoverCanceled(address indexed pendingOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipHandoverCanceled {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipHandoverCanceled {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipHandoverCanceled(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                250u8,
                123u8,
                142u8,
                171u8,
                125u8,
                166u8,
                127u8,
                65u8,
                44u8,
                201u8,
                87u8,
                94u8,
                212u8,
                52u8,
                100u8,
                70u8,
                143u8,
                155u8,
                251u8,
                174u8,
                137u8,
                209u8,
                103u8,
                89u8,
                23u8,
                52u8,
                108u8,
                166u8,
                216u8,
                254u8,
                60u8,
                146u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { pendingOwner: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.pendingOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.pendingOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipHandoverCanceled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipHandoverCanceled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipHandoverCanceled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipHandoverRequested(address)` and selector `0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d`.
```solidity
event OwnershipHandoverRequested(address indexed pendingOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipHandoverRequested {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipHandoverRequested {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipHandoverRequested(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8,
                243u8,
                106u8,
                16u8,
                125u8,
                161u8,
                158u8,
                73u8,
                82u8,
                122u8,
                113u8,
                118u8,
                161u8,
                186u8,
                191u8,
                150u8,
                59u8,
                75u8,
                15u8,
                248u8,
                205u8,
                227u8,
                94u8,
                227u8,
                93u8,
                108u8,
                216u8,
                241u8,
                249u8,
                172u8,
                126u8,
                29u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { pendingOwner: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.pendingOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.pendingOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipHandoverRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipHandoverRequested> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipHandoverRequested,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub oldOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RandomnessGenerated(uint256,uint8)` and selector `0xc121d80dea264848831cf931fbb656d7a78f7a803617779ad4a929c097decf55`.
```solidity
event RandomnessGenerated(uint256 indexed req_id, uint8 indexed flag);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RandomnessGenerated {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub flag: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RandomnessGenerated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str = "RandomnessGenerated(uint256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8,
                33u8,
                216u8,
                13u8,
                234u8,
                38u8,
                72u8,
                72u8,
                131u8,
                28u8,
                249u8,
                49u8,
                251u8,
                182u8,
                86u8,
                215u8,
                167u8,
                143u8,
                122u8,
                128u8,
                54u8,
                23u8,
                119u8,
                154u8,
                212u8,
                169u8,
                41u8,
                192u8,
                151u8,
                222u8,
                207u8,
                85u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    req_id: topics.1,
                    flag: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.req_id.clone(), self.flag.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.req_id);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.flag);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RandomnessGenerated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RandomnessGenerated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RandomnessGenerated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RandomnessRequested(uint256,uint8)` and selector `0x3ec8642f8b768499115ea187dc689a6b03e502d08109c78b846de20202f6f910`.
```solidity
event RandomnessRequested(uint256 indexed req_id, uint8 indexed flag);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RandomnessRequested {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub flag: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RandomnessRequested {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str = "RandomnessRequested(uint256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                62u8,
                200u8,
                100u8,
                47u8,
                139u8,
                118u8,
                132u8,
                153u8,
                17u8,
                94u8,
                161u8,
                135u8,
                220u8,
                104u8,
                154u8,
                107u8,
                3u8,
                229u8,
                2u8,
                208u8,
                129u8,
                9u8,
                199u8,
                139u8,
                132u8,
                109u8,
                226u8,
                2u8,
                2u8,
                246u8,
                249u8,
                16u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    req_id: topics.1,
                    flag: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.req_id.clone(), self.flag.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.req_id);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.flag);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RandomnessRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RandomnessRequested> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RandomnessRequested) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RandomnessSourcesUpdated(uint8,uint8)` and selector `0xa18893a16b818f3e8c53189231250cb02bb55cb32802a6d5c2b5eb856cdb7f1e`.
```solidity
event RandomnessSourcesUpdated(uint8 old_sources, uint8 new_sources);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RandomnessSourcesUpdated {
        #[allow(missing_docs)]
        pub old_sources: u8,
        #[allow(missing_docs)]
        pub new_sources: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RandomnessSourcesUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RandomnessSourcesUpdated(uint8,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                161u8,
                136u8,
                147u8,
                161u8,
                107u8,
                129u8,
                143u8,
                62u8,
                140u8,
                83u8,
                24u8,
                146u8,
                49u8,
                37u8,
                12u8,
                176u8,
                43u8,
                181u8,
                92u8,
                179u8,
                40u8,
                2u8,
                166u8,
                213u8,
                194u8,
                181u8,
                235u8,
                133u8,
                108u8,
                219u8,
                127u8,
                30u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    old_sources: data.0,
                    new_sources: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.old_sources),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.new_sources),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RandomnessSourcesUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RandomnessSourcesUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &RandomnessSourcesUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RequestAborted(uint256)` and selector `0x6248d5a209702db872b83045d56e4baf48362ce7a7cda285a671e7c1e63f44b9`.
```solidity
event RequestAborted(uint256 indexed req_id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RequestAborted {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RequestAborted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "RequestAborted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                72u8,
                213u8,
                162u8,
                9u8,
                112u8,
                45u8,
                184u8,
                114u8,
                184u8,
                48u8,
                69u8,
                213u8,
                110u8,
                75u8,
                175u8,
                72u8,
                54u8,
                44u8,
                231u8,
                167u8,
                205u8,
                162u8,
                133u8,
                166u8,
                113u8,
                231u8,
                193u8,
                230u8,
                63u8,
                68u8,
                185u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { req_id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.req_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.req_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RequestAborted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RequestAborted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RequestAborted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RequestCompleted(uint256)` and selector `0xb26fe08e4e51c01e5cffff5f4887249599779aa0d4f8636ff4e7cd4831b495ed`.
```solidity
event RequestCompleted(uint256 indexed req_id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RequestCompleted {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RequestCompleted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "RequestCompleted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                178u8,
                111u8,
                224u8,
                142u8,
                78u8,
                81u8,
                192u8,
                30u8,
                92u8,
                255u8,
                255u8,
                95u8,
                72u8,
                135u8,
                36u8,
                149u8,
                153u8,
                119u8,
                154u8,
                160u8,
                212u8,
                248u8,
                99u8,
                111u8,
                244u8,
                231u8,
                205u8,
                72u8,
                49u8,
                180u8,
                149u8,
                237u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { req_id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.req_id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.req_id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RequestCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RequestCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RequestCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RevenueSet(uint256)` and selector `0x9b2ed94f91322bd8b33d1f43a7537d8fb0b7966288d8f03f17bf83a7c3a68b4d`.
```solidity
event RevenueSet(uint256 indexed bps);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RevenueSet {
        #[allow(missing_docs)]
        pub bps: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RevenueSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "RevenueSet(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                155u8,
                46u8,
                217u8,
                79u8,
                145u8,
                50u8,
                43u8,
                216u8,
                179u8,
                61u8,
                31u8,
                67u8,
                167u8,
                83u8,
                125u8,
                143u8,
                176u8,
                183u8,
                150u8,
                98u8,
                136u8,
                216u8,
                240u8,
                63u8,
                23u8,
                191u8,
                131u8,
                167u8,
                195u8,
                166u8,
                139u8,
                77u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bps: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bps.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.bps);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RevenueSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RevenueSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RevenueSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RolesUpdated(address,uint256)` and selector `0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26`.
```solidity
event RolesUpdated(address indexed user, uint256 indexed roles);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RolesUpdated {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RolesUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "RolesUpdated(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                113u8,
                90u8,
                213u8,
                206u8,
                97u8,
                252u8,
                149u8,
                149u8,
                199u8,
                180u8,
                21u8,
                40u8,
                157u8,
                89u8,
                207u8,
                32u8,
                63u8,
                35u8,
                169u8,
                79u8,
                160u8,
                111u8,
                4u8,
                175u8,
                126u8,
                72u8,
                154u8,
                10u8,
                118u8,
                225u8,
                254u8,
                38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    roles: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.user.clone(), self.roles.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.roles);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RolesUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RolesUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RolesUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SAVPublicKeyUpdated(uint256[2])` and selector `0xc6a468b84385cd4dfc440db21d0df6f03612ba43b35efe190dee993b466a5198`.
```solidity
event SAVPublicKeyUpdated(uint256[2] newPublicKey);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SAVPublicKeyUpdated {
        #[allow(missing_docs)]
        pub newPublicKey: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SAVPublicKeyUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SAVPublicKeyUpdated(uint256[2])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                198u8,
                164u8,
                104u8,
                184u8,
                67u8,
                133u8,
                205u8,
                77u8,
                252u8,
                68u8,
                13u8,
                178u8,
                29u8,
                13u8,
                246u8,
                240u8,
                54u8,
                18u8,
                186u8,
                67u8,
                179u8,
                94u8,
                254u8,
                25u8,
                13u8,
                238u8,
                153u8,
                59u8,
                70u8,
                106u8,
                81u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newPublicKey: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.newPublicKey),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SAVPublicKeyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SAVPublicKeyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SAVPublicKeyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TokenNotSupported(address,string)` and selector `0xb398ca235b3eff2f67e7270724650d13e47cd5f9dac13b9187ed81b127ce24c7`.
```solidity
event TokenNotSupported(address indexed token, string reason);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TokenNotSupported {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TokenNotSupported {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TokenNotSupported(address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8,
                152u8,
                202u8,
                35u8,
                91u8,
                62u8,
                255u8,
                47u8,
                103u8,
                231u8,
                39u8,
                7u8,
                36u8,
                101u8,
                13u8,
                19u8,
                228u8,
                124u8,
                213u8,
                249u8,
                218u8,
                193u8,
                59u8,
                145u8,
                135u8,
                237u8,
                129u8,
                177u8,
                39u8,
                206u8,
                36u8,
                199u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: topics.1,
                    reason: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TokenNotSupported {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TokenNotSupported> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TokenNotSupported) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UserRegistered(bytes32,address)` and selector `0xf62ba47fe3ff610889160f02571396e86e21b7aadcbde2719192e206853b331f`.
```solidity
event UserRegistered(bytes32 indexed secret, address indexed addr);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UserRegistered {
        #[allow(missing_docs)]
        pub secret: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UserRegistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "UserRegistered(bytes32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                43u8,
                164u8,
                127u8,
                227u8,
                255u8,
                97u8,
                8u8,
                137u8,
                22u8,
                15u8,
                2u8,
                87u8,
                19u8,
                150u8,
                232u8,
                110u8,
                33u8,
                183u8,
                170u8,
                220u8,
                189u8,
                226u8,
                113u8,
                145u8,
                146u8,
                226u8,
                6u8,
                133u8,
                59u8,
                51u8,
                31u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    secret: topics.1,
                    addr: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.secret.clone(), self.addr.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.secret);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.addr,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UserRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UserRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UserRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _nft_contract, address _token_contract, address _pyth_entropy, address _pyth_provider, address _randomizer, uint256[2] _sav_pk, address _revenue_wallet);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _nft_contract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _token_contract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _pyth_entropy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _pyth_provider: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _randomizer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _sav_pk: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub _revenue_wallet: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._nft_contract,
                        value._token_contract,
                        value._pyth_entropy,
                        value._pyth_provider,
                        value._randomizer,
                        value._sav_pk,
                        value._revenue_wallet,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _nft_contract: tuple.0,
                        _token_contract: tuple.1,
                        _pyth_entropy: tuple.2,
                        _pyth_provider: tuple.3,
                        _randomizer: tuple.4,
                        _sav_pk: tuple.5,
                        _revenue_wallet: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._nft_contract,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._token_contract,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._pyth_entropy,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._pyth_provider,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._randomizer,
                    ),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._sav_pk),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._revenue_wallet,
                    ),
                )
            }
        }
    };
    /**Function with signature `BATTLE_ROUNDS()` and selector `0xe243adbf`.
```solidity
function BATTLE_ROUNDS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BATTLE_ROUNDSCall {}
    ///Container type for the return parameters of the [`BATTLE_ROUNDS()`](BATTLE_ROUNDSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BATTLE_ROUNDSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BATTLE_ROUNDSCall> for UnderlyingRustTuple<'_> {
                fn from(value: BATTLE_ROUNDSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BATTLE_ROUNDSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BATTLE_ROUNDSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: BATTLE_ROUNDSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BATTLE_ROUNDSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BATTLE_ROUNDSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BATTLE_ROUNDSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BATTLE_ROUNDS()";
            const SELECTOR: [u8; 4] = [226u8, 67u8, 173u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `HEALTH_PER_LIFE()` and selector `0x193ccb61`.
```solidity
function HEALTH_PER_LIFE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HEALTH_PER_LIFECall {}
    ///Container type for the return parameters of the [`HEALTH_PER_LIFE()`](HEALTH_PER_LIFECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HEALTH_PER_LIFEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<HEALTH_PER_LIFECall> for UnderlyingRustTuple<'_> {
                fn from(value: HEALTH_PER_LIFECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for HEALTH_PER_LIFECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<HEALTH_PER_LIFEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: HEALTH_PER_LIFEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for HEALTH_PER_LIFEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for HEALTH_PER_LIFECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = HEALTH_PER_LIFEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HEALTH_PER_LIFE()";
            const SELECTOR: [u8; 4] = [25u8, 60u8, 203u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_HEALTH()` and selector `0x94e7ecfb`.
```solidity
function INITIAL_HEALTH() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_HEALTHCall {}
    ///Container type for the return parameters of the [`INITIAL_HEALTH()`](INITIAL_HEALTHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_HEALTHReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_HEALTHCall> for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_HEALTHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INITIAL_HEALTHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_HEALTHReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_HEALTHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_HEALTHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_HEALTHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_HEALTHReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_HEALTH()";
            const SELECTOR: [u8; 4] = [148u8, 231u8, 236u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NFT_CONTRACT()` and selector `0x1fda9a02`.
```solidity
function NFT_CONTRACT() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NFT_CONTRACTCall {}
    ///Container type for the return parameters of the [`NFT_CONTRACT()`](NFT_CONTRACTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NFT_CONTRACTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NFT_CONTRACTCall> for UnderlyingRustTuple<'_> {
                fn from(value: NFT_CONTRACTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for NFT_CONTRACTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NFT_CONTRACTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: NFT_CONTRACTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for NFT_CONTRACTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NFT_CONTRACTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NFT_CONTRACTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NFT_CONTRACT()";
            const SELECTOR: [u8; 4] = [31u8, 218u8, 154u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PYTH_ENTROPY()` and selector `0xafb218f5`.
```solidity
function PYTH_ENTROPY() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PYTH_ENTROPYCall {}
    ///Container type for the return parameters of the [`PYTH_ENTROPY()`](PYTH_ENTROPYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PYTH_ENTROPYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PYTH_ENTROPYCall> for UnderlyingRustTuple<'_> {
                fn from(value: PYTH_ENTROPYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PYTH_ENTROPYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PYTH_ENTROPYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PYTH_ENTROPYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PYTH_ENTROPYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PYTH_ENTROPYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PYTH_ENTROPYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PYTH_ENTROPY()";
            const SELECTOR: [u8; 4] = [175u8, 178u8, 24u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PYTH_PROVIDER()` and selector `0x33e7977a`.
```solidity
function PYTH_PROVIDER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PYTH_PROVIDERCall {}
    ///Container type for the return parameters of the [`PYTH_PROVIDER()`](PYTH_PROVIDERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PYTH_PROVIDERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PYTH_PROVIDERCall> for UnderlyingRustTuple<'_> {
                fn from(value: PYTH_PROVIDERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PYTH_PROVIDERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PYTH_PROVIDERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PYTH_PROVIDERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PYTH_PROVIDERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PYTH_PROVIDERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PYTH_PROVIDERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PYTH_PROVIDER()";
            const SELECTOR: [u8; 4] = [51u8, 231u8, 151u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `RANDOMIZER()` and selector `0xbad01899`.
```solidity
function RANDOMIZER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RANDOMIZERCall {}
    ///Container type for the return parameters of the [`RANDOMIZER()`](RANDOMIZERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RANDOMIZERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RANDOMIZERCall> for UnderlyingRustTuple<'_> {
                fn from(value: RANDOMIZERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for RANDOMIZERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RANDOMIZERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: RANDOMIZERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for RANDOMIZERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RANDOMIZERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = RANDOMIZERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RANDOMIZER()";
            const SELECTOR: [u8; 4] = [186u8, 208u8, 24u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SAV_PUB_KEY(uint256)` and selector `0xf98118d5`.
```solidity
function SAV_PUB_KEY(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SAV_PUB_KEYCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`SAV_PUB_KEY(uint256)`](SAV_PUB_KEYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SAV_PUB_KEYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAV_PUB_KEYCall> for UnderlyingRustTuple<'_> {
                fn from(value: SAV_PUB_KEYCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAV_PUB_KEYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAV_PUB_KEYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SAV_PUB_KEYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAV_PUB_KEYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SAV_PUB_KEYCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SAV_PUB_KEYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SAV_PUB_KEY(uint256)";
            const SELECTOR: [u8; 4] = [249u8, 129u8, 24u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOKEN_CONTRACT()` and selector `0x36339388`.
```solidity
function TOKEN_CONTRACT() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKEN_CONTRACTCall {}
    ///Container type for the return parameters of the [`TOKEN_CONTRACT()`](TOKEN_CONTRACTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKEN_CONTRACTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKEN_CONTRACTCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOKEN_CONTRACTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOKEN_CONTRACTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKEN_CONTRACTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: TOKEN_CONTRACTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for TOKEN_CONTRACTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOKEN_CONTRACTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOKEN_CONTRACTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOKEN_CONTRACT()";
            const SELECTOR: [u8; 4] = [54u8, 51u8, 147u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `WINS_REQUIRED()` and selector `0x4419df3a`.
```solidity
function WINS_REQUIRED() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WINS_REQUIREDCall {}
    ///Container type for the return parameters of the [`WINS_REQUIRED()`](WINS_REQUIREDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WINS_REQUIREDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WINS_REQUIREDCall> for UnderlyingRustTuple<'_> {
                fn from(value: WINS_REQUIREDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WINS_REQUIREDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WINS_REQUIREDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: WINS_REQUIREDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WINS_REQUIREDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for WINS_REQUIREDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = WINS_REQUIREDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WINS_REQUIRED()";
            const SELECTOR: [u8; 4] = [68u8, 25u8, 223u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_entropyCallback(uint64,address,bytes32)` and selector `0x52a5f1f8`.
```solidity
function _entropyCallback(uint64 sequence, address provider, bytes32 randomNumber) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _entropyCallbackCall {
        #[allow(missing_docs)]
        pub sequence: u64,
        #[allow(missing_docs)]
        pub provider: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub randomNumber: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`_entropyCallback(uint64,address,bytes32)`](_entropyCallbackCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct _entropyCallbackReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_entropyCallbackCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: _entropyCallbackCall) -> Self {
                    (value.sequence, value.provider, value.randomNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _entropyCallbackCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequence: tuple.0,
                        provider: tuple.1,
                        randomNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_entropyCallbackReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: _entropyCallbackReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _entropyCallbackReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _entropyCallbackCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _entropyCallbackReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_entropyCallback(uint64,address,bytes32)";
            const SELECTOR: [u8; 4] = [82u8, 165u8, 241u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequence),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.provider,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.randomNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `abort_game(uint256)` and selector `0xa1bdc608`.
```solidity
function abort_game(uint256 game_id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abort_gameCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`abort_game(uint256)`](abort_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abort_gameReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abort_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: abort_gameCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for abort_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abort_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: abort_gameReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for abort_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for abort_gameCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = abort_gameReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "abort_game(uint256)";
            const SELECTOR: [u8; 4] = [161u8, 189u8, 198u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `abort_request(uint256)` and selector `0x8228b1e2`.
```solidity
function abort_request(uint256 req_id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abort_requestCall {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`abort_request(uint256)`](abort_requestCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abort_requestReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abort_requestCall> for UnderlyingRustTuple<'_> {
                fn from(value: abort_requestCall) -> Self {
                    (value.req_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for abort_requestCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { req_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abort_requestReturn> for UnderlyingRustTuple<'_> {
                fn from(value: abort_requestReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for abort_requestReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for abort_requestCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = abort_requestReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "abort_request(uint256)";
            const SELECTOR: [u8; 4] = [130u8, 40u8, 177u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.req_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calc_book(uint256)` and selector `0x23a8c4ba`.
```solidity
function calc_book(uint256 game_id) external view returns (uint256 p1_odds, uint256 p2_odds, uint256 p1_depth, uint256 p2_depth);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calc_bookCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calc_book(uint256)`](calc_bookCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calc_bookReturn {
        #[allow(missing_docs)]
        pub p1_odds: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub p2_odds: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub p1_depth: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub p2_depth: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calc_bookCall> for UnderlyingRustTuple<'_> {
                fn from(value: calc_bookCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calc_bookCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calc_bookReturn> for UnderlyingRustTuple<'_> {
                fn from(value: calc_bookReturn) -> Self {
                    (value.p1_odds, value.p2_odds, value.p1_depth, value.p2_depth)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calc_bookReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        p1_odds: tuple.0,
                        p2_odds: tuple.1,
                        p1_depth: tuple.2,
                        p2_depth: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calc_bookCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calc_bookReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calc_book(uint256)";
            const SELECTOR: [u8; 4] = [35u8, 168u8, 196u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calc_fee()` and selector `0x435c0298`.
```solidity
function calc_fee() external view returns (uint256 total, uint128 fee_pyth, uint256 fee_randomizer);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calc_feeCall {}
    ///Container type for the return parameters of the [`calc_fee()`](calc_feeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calc_feeReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub fee_pyth: u128,
        #[allow(missing_docs)]
        pub fee_randomizer: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calc_feeCall> for UnderlyingRustTuple<'_> {
                fn from(value: calc_feeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calc_feeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<128>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                u128,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calc_feeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: calc_feeReturn) -> Self {
                    (value.total, value.fee_pyth, value.fee_randomizer)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calc_feeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        total: tuple.0,
                        fee_pyth: tuple.1,
                        fee_randomizer: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calc_feeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calc_feeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<128>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calc_fee()";
            const SELECTOR: [u8; 4] = [67u8, 92u8, 2u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `cancelOwnershipHandover()` and selector `0x54d1f13d`.
```solidity
function cancelOwnershipHandover() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelOwnershipHandoverCall {}
    ///Container type for the return parameters of the [`cancelOwnershipHandover()`](cancelOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelOwnershipHandoverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cancelOwnershipHandoverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cancelOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cancelOwnershipHandover()";
            const SELECTOR: [u8; 4] = [84u8, 209u8, 241u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `completeOwnershipHandover(address)` and selector `0xf04e283e`.
```solidity
function completeOwnershipHandover(address pendingOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeOwnershipHandoverCall {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`completeOwnershipHandover(address)`](completeOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeOwnershipHandoverCall) -> Self {
                    (value.pendingOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pendingOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for completeOwnershipHandoverCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = completeOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "completeOwnershipHandover(address)";
            const SELECTOR: [u8; 4] = [240u8, 78u8, 40u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pendingOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `compute_alpha(uint256)` and selector `0x3b66f1c0`.
```solidity
function compute_alpha(uint256 game_id) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compute_alphaCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`compute_alpha(uint256)`](compute_alphaCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compute_alphaReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compute_alphaCall> for UnderlyingRustTuple<'_> {
                fn from(value: compute_alphaCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for compute_alphaCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compute_alphaReturn> for UnderlyingRustTuple<'_> {
                fn from(value: compute_alphaReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for compute_alphaReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for compute_alphaCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = compute_alphaReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "compute_alpha(uint256)";
            const SELECTOR: [u8; 4] = [59u8, 102u8, 241u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `compute_fast_verify_params(uint256[4],bytes)` and selector `0x67f188b7`.
```solidity
function compute_fast_verify_params(uint256[4] memory _proof, bytes memory _alpha) external view returns (uint256[2] memory U, uint256[4] memory V);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compute_fast_verify_paramsCall {
        #[allow(missing_docs)]
        pub _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        #[allow(missing_docs)]
        pub _alpha: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`compute_fast_verify_params(uint256[4],bytes)`](compute_fast_verify_paramsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compute_fast_verify_paramsReturn {
        #[allow(missing_docs)]
        pub U: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub V: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compute_fast_verify_paramsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: compute_fast_verify_paramsCall) -> Self {
                    (value._proof, value._alpha)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compute_fast_verify_paramsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _proof: tuple.0,
                        _alpha: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compute_fast_verify_paramsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: compute_fast_verify_paramsReturn) -> Self {
                    (value.U, value.V)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compute_fast_verify_paramsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { U: tuple.0, V: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for compute_fast_verify_paramsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = compute_fast_verify_paramsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "compute_fast_verify_params(uint256[4],bytes)";
            const SELECTOR: [u8; 4] = [103u8, 241u8, 136u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._proof),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._alpha,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decoded_proof_to_hash(uint256[4])` and selector `0xb6f90054`.
```solidity
function decoded_proof_to_hash(uint256[4] memory pi) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decoded_proof_to_hashCall {
        #[allow(missing_docs)]
        pub pi: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
    }
    ///Container type for the return parameters of the [`decoded_proof_to_hash(uint256[4])`](decoded_proof_to_hashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decoded_proof_to_hashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decoded_proof_to_hashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: decoded_proof_to_hashCall) -> Self {
                    (value.pi,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for decoded_proof_to_hashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pi: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decoded_proof_to_hashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: decoded_proof_to_hashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for decoded_proof_to_hashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decoded_proof_to_hashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decoded_proof_to_hashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decoded_proof_to_hash(uint256[4])";
            const SELECTOR: [u8; 4] = [182u8, 249u8, 0u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.pi),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `end_game(uint256)` and selector `0x65835e5a`.
```solidity
function end_game(uint256 game_id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct end_gameCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`end_game(uint256)`](end_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct end_gameReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<end_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: end_gameCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for end_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<end_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: end_gameReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for end_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for end_gameCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = end_gameReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "end_game(uint256)";
            const SELECTOR: [u8; 4] = [101u8, 131u8, 94u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exec_game(uint256)` and selector `0x05a835bf`.
```solidity
function exec_game(uint256 game_id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exec_gameCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`exec_game(uint256)`](exec_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exec_gameReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exec_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: exec_gameCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exec_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exec_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: exec_gameReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exec_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exec_gameCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exec_gameReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exec_game(uint256)";
            const SELECTOR: [u8; 4] = [5u8, 168u8, 53u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_active_game_ids()` and selector `0x8d3e445a`.
```solidity
function get_active_game_ids() external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_active_game_idsCall {}
    ///Container type for the return parameters of the [`get_active_game_ids()`](get_active_game_idsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_active_game_idsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_active_game_idsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_active_game_idsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_active_game_idsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_active_game_idsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_active_game_idsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_active_game_idsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_active_game_idsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_active_game_idsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_active_game_ids()";
            const SELECTOR: [u8; 4] = [141u8, 62u8, 68u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_active_sources()` and selector `0x028995cd`.
```solidity
function get_active_sources() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_active_sourcesCall {}
    ///Container type for the return parameters of the [`get_active_sources()`](get_active_sourcesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_active_sourcesReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_active_sourcesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_active_sourcesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_active_sourcesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_active_sourcesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_active_sourcesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_active_sourcesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_active_sourcesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_active_sourcesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_active_sources()";
            const SELECTOR: [u8; 4] = [2u8, 137u8, 149u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_alpha(uint256)` and selector `0x2c2aab41`.
```solidity
function get_alpha(uint256 game_id) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_alphaCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_alpha(uint256)`](get_alphaCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_alphaReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_alphaCall> for UnderlyingRustTuple<'_> {
                fn from(value: get_alphaCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_alphaCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_alphaReturn> for UnderlyingRustTuple<'_> {
                fn from(value: get_alphaReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_alphaReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_alphaCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_alphaReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_alpha(uint256)";
            const SELECTOR: [u8; 4] = [44u8, 42u8, 171u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_current_game_id()` and selector `0x9171e558`.
```solidity
function get_current_game_id() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_current_game_idCall {}
    ///Container type for the return parameters of the [`get_current_game_id()`](get_current_game_idCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_current_game_idReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_current_game_idCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_current_game_idCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_current_game_idCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_current_game_idReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_current_game_idReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_current_game_idReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_current_game_idCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_current_game_idReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_current_game_id()";
            const SELECTOR: [u8; 4] = [145u8, 113u8, 229u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_game(uint256)` and selector `0xd9fb3aba`.
```solidity
function get_game(uint256 game_id) external view returns (GameData memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_gameCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_game(uint256)`](get_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_gameReturn {
        #[allow(missing_docs)]
        pub _0: <GameData as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: get_gameCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (GameData,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <GameData as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: get_gameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_gameCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_gameReturn;
            type ReturnTuple<'a> = (GameData,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_game(uint256)";
            const SELECTOR: [u8; 4] = [217u8, 251u8, 58u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_onka_stats(uint256)` and selector `0x397606c0`.
```solidity
function get_onka_stats(uint256 nft_id) external view returns (OnkaStats memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_onka_statsCall {
        #[allow(missing_docs)]
        pub nft_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_onka_stats(uint256)`](get_onka_statsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_onka_statsReturn {
        #[allow(missing_docs)]
        pub _0: <OnkaStats as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_onka_statsCall> for UnderlyingRustTuple<'_> {
                fn from(value: get_onka_statsCall) -> Self {
                    (value.nft_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_onka_statsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nft_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (OnkaStats,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <OnkaStats as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_onka_statsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_onka_statsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_onka_statsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_onka_statsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_onka_statsReturn;
            type ReturnTuple<'a> = (OnkaStats,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_onka_stats(uint256)";
            const SELECTOR: [u8; 4] = [57u8, 118u8, 6u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nft_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_pyth_fee()` and selector `0x0b12e4ba`.
```solidity
function get_pyth_fee() external view returns (uint128);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_pyth_feeCall {}
    ///Container type for the return parameters of the [`get_pyth_fee()`](get_pyth_feeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_pyth_feeReturn {
        #[allow(missing_docs)]
        pub _0: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_pyth_feeCall> for UnderlyingRustTuple<'_> {
                fn from(value: get_pyth_feeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_pyth_feeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<128>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u128,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_pyth_feeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: get_pyth_feeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_pyth_feeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_pyth_feeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_pyth_feeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<128>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_pyth_fee()";
            const SELECTOR: [u8; 4] = [11u8, 18u8, 228u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_pyth_request(uint64)` and selector `0x94c59314`.
```solidity
function get_pyth_request(uint64 src_id) external view returns (EntropyStructs.Request memory req);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_pyth_requestCall {
        #[allow(missing_docs)]
        pub src_id: u64,
    }
    ///Container type for the return parameters of the [`get_pyth_request(uint64)`](get_pyth_requestCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_pyth_requestReturn {
        #[allow(missing_docs)]
        pub req: <EntropyStructs::Request as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_pyth_requestCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_pyth_requestCall) -> Self {
                    (value.src_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_pyth_requestCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { src_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (EntropyStructs::Request,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <EntropyStructs::Request as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_pyth_requestReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_pyth_requestReturn) -> Self {
                    (value.req,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_pyth_requestReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { req: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_pyth_requestCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_pyth_requestReturn;
            type ReturnTuple<'a> = (EntropyStructs::Request,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_pyth_request(uint64)";
            const SELECTOR: [u8; 4] = [148u8, 197u8, 147u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.src_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_random_value(uint256)` and selector `0xde858437`.
```solidity
function get_random_value(uint256 req_id) external view returns (bytes32 rand, bool completed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_random_valueCall {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_random_value(uint256)`](get_random_valueCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_random_valueReturn {
        #[allow(missing_docs)]
        pub rand: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub completed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_random_valueCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_random_valueCall) -> Self {
                    (value.req_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_random_valueCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { req_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_random_valueReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_random_valueReturn) -> Self {
                    (value.rand, value.completed)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_random_valueReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rand: tuple.0,
                        completed: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_random_valueCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_random_valueReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_random_value(uint256)";
            const SELECTOR: [u8; 4] = [222u8, 133u8, 132u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.req_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_randomizer_balance(bool)` and selector `0x98e5030a`.
```solidity
function get_randomizer_balance(bool liquid) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_randomizer_balanceCall {
        #[allow(missing_docs)]
        pub liquid: bool,
    }
    ///Container type for the return parameters of the [`get_randomizer_balance(bool)`](get_randomizer_balanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_randomizer_balanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_randomizer_balanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_randomizer_balanceCall) -> Self {
                    (value.liquid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_randomizer_balanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { liquid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_randomizer_balanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_randomizer_balanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_randomizer_balanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_randomizer_balanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_randomizer_balanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_randomizer_balance(bool)";
            const SELECTOR: [u8; 4] = [152u8, 229u8, 3u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.liquid,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_randomizer_fee(bool)` and selector `0xecc04485`.
```solidity
function get_randomizer_fee(bool atomic) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_randomizer_feeCall {
        #[allow(missing_docs)]
        pub atomic: bool,
    }
    ///Container type for the return parameters of the [`get_randomizer_fee(bool)`](get_randomizer_feeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_randomizer_feeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_randomizer_feeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_randomizer_feeCall) -> Self {
                    (value.atomic,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_randomizer_feeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { atomic: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_randomizer_feeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_randomizer_feeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_randomizer_feeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_randomizer_feeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_randomizer_feeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_randomizer_fee(bool)";
            const SELECTOR: [u8; 4] = [236u8, 192u8, 68u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.atomic,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_request_status(uint256)` and selector `0xd0be0b9c`.
```solidity
function get_request_status(uint256 req_id) external view returns (bool active, uint8 remaining_sources);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_request_statusCall {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_request_status(uint256)`](get_request_statusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_request_statusReturn {
        #[allow(missing_docs)]
        pub active: bool,
        #[allow(missing_docs)]
        pub remaining_sources: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_request_statusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_request_statusCall) -> Self {
                    (value.req_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_request_statusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { req_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, u8);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_request_statusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_request_statusReturn) -> Self {
                    (value.active, value.remaining_sources)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_request_statusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        active: tuple.0,
                        remaining_sources: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_request_statusCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_request_statusReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_request_status(uint256)";
            const SELECTOR: [u8; 4] = [208u8, 190u8, 11u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.req_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_revenue_bps()` and selector `0x254a39fe`.
```solidity
function get_revenue_bps() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_revenue_bpsCall {}
    ///Container type for the return parameters of the [`get_revenue_bps()`](get_revenue_bpsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_revenue_bpsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_revenue_bpsCall> for UnderlyingRustTuple<'_> {
                fn from(value: get_revenue_bpsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for get_revenue_bpsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_revenue_bpsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_revenue_bpsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_revenue_bpsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_revenue_bpsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_revenue_bpsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_revenue_bps()";
            const SELECTOR: [u8; 4] = [37u8, 74u8, 57u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `get_speculations(uint256)` and selector `0x31052c30`.
```solidity
function get_speculations(uint256 game_id) external view returns (Speculation[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_speculationsCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`get_speculations(uint256)`](get_speculationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct get_speculationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Speculation as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_speculationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_speculationsCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_speculationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Speculation>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Speculation as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<get_speculationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: get_speculationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for get_speculationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for get_speculationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = get_speculationsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<Speculation>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "get_speculations(uint256)";
            const SELECTOR: [u8; 4] = [49u8, 5u8, 44u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRoles(address,uint256)` and selector `0x1c10893f`.
```solidity
function grantRoles(address user, uint256 roles) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRolesCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`grantRoles(address,uint256)`](grantRolesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRolesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRolesCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRolesCall) -> Self {
                    (value.user, value.roles)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRolesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        roles: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRolesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRolesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRolesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRolesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRolesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRoles(address,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 16u8, 137u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roles),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasAllRoles(address,uint256)` and selector `0x1cd64df4`.
```solidity
function hasAllRoles(address user, uint256 roles) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasAllRolesCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`hasAllRoles(address,uint256)`](hasAllRolesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasAllRolesReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasAllRolesCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasAllRolesCall) -> Self {
                    (value.user, value.roles)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasAllRolesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        roles: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasAllRolesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasAllRolesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasAllRolesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasAllRolesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasAllRolesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasAllRoles(address,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 214u8, 77u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roles),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasAnyRole(address,uint256)` and selector `0x514e62fc`.
```solidity
function hasAnyRole(address user, uint256 roles) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasAnyRoleCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`hasAnyRole(address,uint256)`](hasAnyRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasAnyRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasAnyRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasAnyRoleCall) -> Self {
                    (value.user, value.roles)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasAnyRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        roles: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasAnyRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasAnyRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasAnyRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasAnyRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasAnyRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasAnyRole(address,uint256)";
            const SELECTOR: [u8; 4] = [81u8, 78u8, 98u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roles),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `new_game((address,uint256)[2],uint256,bytes32)` and selector `0x6f59232f`.
```solidity
function new_game(Player[2] memory players, uint256 amount, bytes32 alpha_prefix) external payable returns (uint256 game_id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct new_gameCall {
        #[allow(missing_docs)]
        pub players: [<Player as alloy::sol_types::SolType>::RustType; 2usize],
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub alpha_prefix: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`new_game((address,uint256)[2],uint256,bytes32)`](new_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct new_gameReturn {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<Player, 2usize>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [<Player as alloy::sol_types::SolType>::RustType; 2usize],
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<new_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: new_gameCall) -> Self {
                    (value.players, value.amount, value.alpha_prefix)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for new_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        players: tuple.0,
                        amount: tuple.1,
                        alpha_prefix: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<new_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: new_gameReturn) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for new_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for new_gameCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<Player, 2usize>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = new_gameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "new_game((address,uint256)[2],uint256,bytes32)";
            const SELECTOR: [u8; 4] = [111u8, 89u8, 35u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        Player,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.players),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.alpha_prefix),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ownershipHandoverExpiresAt(address)` and selector `0xfee81cf4`.
```solidity
function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownershipHandoverExpiresAtCall {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`ownershipHandoverExpiresAt(address)`](ownershipHandoverExpiresAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownershipHandoverExpiresAtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownershipHandoverExpiresAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownershipHandoverExpiresAtCall) -> Self {
                    (value.pendingOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownershipHandoverExpiresAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pendingOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownershipHandoverExpiresAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownershipHandoverExpiresAtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownershipHandoverExpiresAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownershipHandoverExpiresAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownershipHandoverExpiresAtReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ownershipHandoverExpiresAt(address)";
            const SELECTOR: [u8; 4] = [254u8, 232u8, 28u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pendingOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `place_bet(uint256,address,bool,uint256)` and selector `0x5bbe0694`.
```solidity
function place_bet(uint256 game_id, address speculator, bool prediction, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct place_betCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub speculator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub prediction: bool,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`place_bet(uint256,address,bool,uint256)`](place_betCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct place_betReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<place_betCall> for UnderlyingRustTuple<'_> {
                fn from(value: place_betCall) -> Self {
                    (value.game_id, value.speculator, value.prediction, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for place_betCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        game_id: tuple.0,
                        speculator: tuple.1,
                        prediction: tuple.2,
                        amount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<place_betReturn> for UnderlyingRustTuple<'_> {
                fn from(value: place_betReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for place_betReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for place_betCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = place_betReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "place_bet(uint256,address,bool,uint256)";
            const SELECTOR: [u8; 4] = [91u8, 190u8, 6u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.speculator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.prediction,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pyth_enabled()` and selector `0x8a95e6df`.
```solidity
function pyth_enabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pyth_enabledCall {}
    ///Container type for the return parameters of the [`pyth_enabled()`](pyth_enabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pyth_enabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pyth_enabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: pyth_enabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pyth_enabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pyth_enabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pyth_enabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pyth_enabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pyth_enabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pyth_enabledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pyth_enabled()";
            const SELECTOR: [u8; 4] = [138u8, 149u8, 230u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `randomizerCallback(uint256,bytes32)` and selector `0xebe93caf`.
```solidity
function randomizerCallback(uint256 _id, bytes32 _beta) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizerCallbackCall {
        #[allow(missing_docs)]
        pub _id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _beta: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`randomizerCallback(uint256,bytes32)`](randomizerCallbackCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizerCallbackReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizerCallbackCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizerCallbackCall) -> Self {
                    (value._id, value._beta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizerCallbackCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _id: tuple.0,
                        _beta: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizerCallbackReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizerCallbackReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizerCallbackReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomizerCallbackCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomizerCallbackReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomizerCallback(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [235u8, 233u8, 60u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._id),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._beta),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `randomizer_deposit(uint256)` and selector `0x162fc301`.
```solidity
function randomizer_deposit(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_depositCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomizer_deposit(uint256)`](randomizer_depositCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_depositReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_depositCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_depositCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_depositCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_depositReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_depositReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_depositReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomizer_depositCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomizer_depositReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomizer_deposit(uint256)";
            const SELECTOR: [u8; 4] = [22u8, 47u8, 195u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `randomizer_enabled()` and selector `0x436cfb9b`.
```solidity
function randomizer_enabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_enabledCall {}
    ///Container type for the return parameters of the [`randomizer_enabled()`](randomizer_enabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_enabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_enabledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_enabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_enabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_enabledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_enabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_enabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomizer_enabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomizer_enabledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomizer_enabled()";
            const SELECTOR: [u8; 4] = [67u8, 108u8, 251u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `randomizer_withdraw(uint256)` and selector `0x21dd9576`.
```solidity
function randomizer_withdraw(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_withdrawCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomizer_withdraw(uint256)`](randomizer_withdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomizer_withdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_withdrawCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_withdrawCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_withdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomizer_withdrawReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: randomizer_withdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for randomizer_withdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomizer_withdrawCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomizer_withdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomizer_withdraw(uint256)";
            const SELECTOR: [u8; 4] = [33u8, 221u8, 149u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `recover_erc20(address)` and selector `0x9dcc21bd`.
```solidity
function recover_erc20(address token) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_erc20Call {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`recover_erc20(address)`](recover_erc20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_erc20Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_erc20Call> for UnderlyingRustTuple<'_> {
                fn from(value: recover_erc20Call) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recover_erc20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_erc20Return> for UnderlyingRustTuple<'_> {
                fn from(value: recover_erc20Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recover_erc20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recover_erc20Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = recover_erc20Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recover_erc20(address)";
            const SELECTOR: [u8; 4] = [157u8, 204u8, 33u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `recover_erc721(address,uint256)` and selector `0x50f1c55a`.
```solidity
function recover_erc721(address token, uint256 token_id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_erc721Call {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`recover_erc721(address,uint256)`](recover_erc721Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_erc721Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_erc721Call> for UnderlyingRustTuple<'_> {
                fn from(value: recover_erc721Call) -> Self {
                    (value.token, value.token_id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recover_erc721Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        token_id: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_erc721Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: recover_erc721Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recover_erc721Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recover_erc721Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = recover_erc721Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recover_erc721(address,uint256)";
            const SELECTOR: [u8; 4] = [80u8, 241u8, 197u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.token_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `recover_eth()` and selector `0x3db132b1`.
```solidity
function recover_eth() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_ethCall {}
    ///Container type for the return parameters of the [`recover_eth()`](recover_ethCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recover_ethReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_ethCall> for UnderlyingRustTuple<'_> {
                fn from(value: recover_ethCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recover_ethCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recover_ethReturn> for UnderlyingRustTuple<'_> {
                fn from(value: recover_ethReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recover_ethReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recover_ethCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = recover_ethReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recover_eth()";
            const SELECTOR: [u8; 4] = [61u8, 177u8, 50u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `register(bytes32)` and selector `0xe1fa8e84`.
```solidity
function register(bytes32 secret) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerCall {
        #[allow(missing_docs)]
        pub secret: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`register(bytes32)`](registerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerCall) -> Self {
                    (value.secret,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { secret: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "register(bytes32)";
            const SELECTOR: [u8; 4] = [225u8, 250u8, 142u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.secret),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRoles(uint256)` and selector `0x183a4f6e`.
```solidity
function renounceRoles(uint256 roles) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRolesCall {
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`renounceRoles(uint256)`](renounceRolesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRolesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRolesCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRolesCall) -> Self {
                    (value.roles,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRolesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { roles: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRolesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRolesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRolesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRolesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRolesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRoles(uint256)";
            const SELECTOR: [u8; 4] = [24u8, 58u8, 79u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roles),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `requestOwnershipHandover()` and selector `0x25692962`.
```solidity
function requestOwnershipHandover() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestOwnershipHandoverCall {}
    ///Container type for the return parameters of the [`requestOwnershipHandover()`](requestOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestOwnershipHandoverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestOwnershipHandoverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestOwnershipHandover()";
            const SELECTOR: [u8; 4] = [37u8, 105u8, 41u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revenue_wallet()` and selector `0x6a411b0c`.
```solidity
function revenue_wallet() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revenue_walletCall {}
    ///Container type for the return parameters of the [`revenue_wallet()`](revenue_walletCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revenue_walletReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revenue_walletCall> for UnderlyingRustTuple<'_> {
                fn from(value: revenue_walletCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revenue_walletCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revenue_walletReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revenue_walletReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revenue_walletReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revenue_walletCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revenue_walletReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revenue_wallet()";
            const SELECTOR: [u8; 4] = [106u8, 65u8, 27u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRoles(address,uint256)` and selector `0x4a4ee7b1`.
```solidity
function revokeRoles(address user, uint256 roles) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRolesCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`revokeRoles(address,uint256)`](revokeRolesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRolesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRolesCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRolesCall) -> Self {
                    (value.user, value.roles)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRolesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        roles: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRolesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRolesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRolesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRolesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRolesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRoles(address,uint256)";
            const SELECTOR: [u8; 4] = [74u8, 78u8, 231u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roles),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `rolesOf(address)` and selector `0x2de94807`.
```solidity
function rolesOf(address user) external view returns (uint256 roles);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rolesOfCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`rolesOf(address)`](rolesOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rolesOfReturn {
        #[allow(missing_docs)]
        pub roles: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rolesOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: rolesOfCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rolesOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rolesOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rolesOfReturn) -> Self {
                    (value.roles,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rolesOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { roles: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rolesOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rolesOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rolesOf(address)";
            const SELECTOR: [u8; 4] = [45u8, 233u8, 72u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sav_callback(uint256,bytes,bytes32,uint256[4],uint256[2],uint256[4])` and selector `0xbc3f1f0a`.
```solidity
function sav_callback(uint256 req_id, bytes memory _alpha, bytes32 beta, uint256[4] memory _proof, uint256[2] memory _U, uint256[4] memory _V) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_callbackCall {
        #[allow(missing_docs)]
        pub req_id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _alpha: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub beta: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        #[allow(missing_docs)]
        pub _U: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub _V: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
    }
    ///Container type for the return parameters of the [`sav_callback(uint256,bytes,bytes32,uint256[4],uint256[2],uint256[4])`](sav_callbackCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_callbackReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::FixedBytes<32>,
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_callbackCall> for UnderlyingRustTuple<'_> {
                fn from(value: sav_callbackCall) -> Self {
                    (
                        value.req_id,
                        value._alpha,
                        value.beta,
                        value._proof,
                        value._U,
                        value._V,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sav_callbackCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        req_id: tuple.0,
                        _alpha: tuple.1,
                        beta: tuple.2,
                        _proof: tuple.3,
                        _U: tuple.4,
                        _V: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_callbackReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sav_callbackReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sav_callbackReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sav_callbackCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sav_callbackReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sav_callback(uint256,bytes,bytes32,uint256[4],uint256[2],uint256[4])";
            const SELECTOR: [u8; 4] = [188u8, 63u8, 31u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.req_id),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._alpha,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.beta),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._proof),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._U),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._V),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sav_enabled()` and selector `0x8eaa495d`.
```solidity
function sav_enabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_enabledCall {}
    ///Container type for the return parameters of the [`sav_enabled()`](sav_enabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_enabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_enabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: sav_enabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sav_enabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_enabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sav_enabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sav_enabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sav_enabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sav_enabledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sav_enabled()";
            const SELECTOR: [u8; 4] = [142u8, 170u8, 73u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sav_last_key_update_timestamp()` and selector `0x1e464309`.
```solidity
function sav_last_key_update_timestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_last_key_update_timestampCall {}
    ///Container type for the return parameters of the [`sav_last_key_update_timestamp()`](sav_last_key_update_timestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sav_last_key_update_timestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_last_key_update_timestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sav_last_key_update_timestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sav_last_key_update_timestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sav_last_key_update_timestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sav_last_key_update_timestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sav_last_key_update_timestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sav_last_key_update_timestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sav_last_key_update_timestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sav_last_key_update_timestamp()";
            const SELECTOR: [u8; 4] = [30u8, 70u8, 67u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `set_revenue(uint256)` and selector `0xc0a77952`.
```solidity
function set_revenue(uint256 bps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_revenueCall {
        #[allow(missing_docs)]
        pub bps: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`set_revenue(uint256)`](set_revenueCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_revenueReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_revenueCall> for UnderlyingRustTuple<'_> {
                fn from(value: set_revenueCall) -> Self {
                    (value.bps,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for set_revenueCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bps: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_revenueReturn> for UnderlyingRustTuple<'_> {
                fn from(value: set_revenueReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for set_revenueReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for set_revenueCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = set_revenueReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "set_revenue(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 167u8, 121u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bps),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `set_revenue_address(address)` and selector `0xf7d24673`.
```solidity
function set_revenue_address(address addr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_revenue_addressCall {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`set_revenue_address(address)`](set_revenue_addressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_revenue_addressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_revenue_addressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: set_revenue_addressCall) -> Self {
                    (value.addr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for set_revenue_addressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { addr: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_revenue_addressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: set_revenue_addressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for set_revenue_addressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for set_revenue_addressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = set_revenue_addressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "set_revenue_address(address)";
            const SELECTOR: [u8; 4] = [247u8, 210u8, 70u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `set_sav_public_key(uint256[2])` and selector `0xaab586c2`.
```solidity
function set_sav_public_key(uint256[2] memory _publicKey) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_sav_public_keyCall {
        #[allow(missing_docs)]
        pub _publicKey: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
    }
    ///Container type for the return parameters of the [`set_sav_public_key(uint256[2])`](set_sav_public_keyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_sav_public_keyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_sav_public_keyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: set_sav_public_keyCall) -> Self {
                    (value._publicKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for set_sav_public_keyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _publicKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_sav_public_keyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: set_sav_public_keyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for set_sav_public_keyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for set_sav_public_keyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = set_sav_public_keyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "set_sav_public_key(uint256[2])";
            const SELECTOR: [u8; 4] = [170u8, 181u8, 134u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._publicKey),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `set_sources(uint8)` and selector `0xace3a153`.
```solidity
function set_sources(uint8 sources) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_sourcesCall {
        #[allow(missing_docs)]
        pub sources: u8,
    }
    ///Container type for the return parameters of the [`set_sources(uint8)`](set_sourcesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct set_sourcesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_sourcesCall> for UnderlyingRustTuple<'_> {
                fn from(value: set_sourcesCall) -> Self {
                    (value.sources,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for set_sourcesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { sources: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<set_sourcesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: set_sourcesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for set_sourcesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for set_sourcesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = set_sourcesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "set_sources(uint8)";
            const SELECTOR: [u8; 4] = [172u8, 227u8, 161u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.sources),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `start_game(uint256)` and selector `0x0ebbcfb5`.
```solidity
function start_game(uint256 game_id) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct start_gameCall {
        #[allow(missing_docs)]
        pub game_id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`start_game(uint256)`](start_gameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct start_gameReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<start_gameCall> for UnderlyingRustTuple<'_> {
                fn from(value: start_gameCall) -> Self {
                    (value.game_id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for start_gameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { game_id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<start_gameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: start_gameReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for start_gameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for start_gameCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = start_gameReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "start_game(uint256)";
            const SELECTOR: [u8; 4] = [14u8, 187u8, 207u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.game_id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `verify_beta(uint256[4],bytes)` and selector `0xb516105c`.
```solidity
function verify_beta(uint256[4] memory _proof, bytes memory _beta) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verify_betaCall {
        #[allow(missing_docs)]
        pub _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        #[allow(missing_docs)]
        pub _beta: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`verify_beta(uint256[4],bytes)`](verify_betaCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verify_betaReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verify_betaCall> for UnderlyingRustTuple<'_> {
                fn from(value: verify_betaCall) -> Self {
                    (value._proof, value._beta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verify_betaCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _proof: tuple.0,
                        _beta: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verify_betaReturn> for UnderlyingRustTuple<'_> {
                fn from(value: verify_betaReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verify_betaReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verify_betaCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = verify_betaReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verify_beta(uint256[4],bytes)";
            const SELECTOR: [u8; 4] = [181u8, 22u8, 16u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._proof),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._beta,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`OnkasOujiGame`](self) function calls.
    pub enum OnkasOujiGameCalls {
        #[allow(missing_docs)]
        BATTLE_ROUNDS(BATTLE_ROUNDSCall),
        #[allow(missing_docs)]
        HEALTH_PER_LIFE(HEALTH_PER_LIFECall),
        #[allow(missing_docs)]
        INITIAL_HEALTH(INITIAL_HEALTHCall),
        #[allow(missing_docs)]
        NFT_CONTRACT(NFT_CONTRACTCall),
        #[allow(missing_docs)]
        PYTH_ENTROPY(PYTH_ENTROPYCall),
        #[allow(missing_docs)]
        PYTH_PROVIDER(PYTH_PROVIDERCall),
        #[allow(missing_docs)]
        RANDOMIZER(RANDOMIZERCall),
        #[allow(missing_docs)]
        SAV_PUB_KEY(SAV_PUB_KEYCall),
        #[allow(missing_docs)]
        TOKEN_CONTRACT(TOKEN_CONTRACTCall),
        #[allow(missing_docs)]
        WINS_REQUIRED(WINS_REQUIREDCall),
        #[allow(missing_docs)]
        _entropyCallback(_entropyCallbackCall),
        #[allow(missing_docs)]
        abort_game(abort_gameCall),
        #[allow(missing_docs)]
        abort_request(abort_requestCall),
        #[allow(missing_docs)]
        calc_book(calc_bookCall),
        #[allow(missing_docs)]
        calc_fee(calc_feeCall),
        #[allow(missing_docs)]
        cancelOwnershipHandover(cancelOwnershipHandoverCall),
        #[allow(missing_docs)]
        completeOwnershipHandover(completeOwnershipHandoverCall),
        #[allow(missing_docs)]
        compute_alpha(compute_alphaCall),
        #[allow(missing_docs)]
        compute_fast_verify_params(compute_fast_verify_paramsCall),
        #[allow(missing_docs)]
        decoded_proof_to_hash(decoded_proof_to_hashCall),
        #[allow(missing_docs)]
        end_game(end_gameCall),
        #[allow(missing_docs)]
        exec_game(exec_gameCall),
        #[allow(missing_docs)]
        get_active_game_ids(get_active_game_idsCall),
        #[allow(missing_docs)]
        get_active_sources(get_active_sourcesCall),
        #[allow(missing_docs)]
        get_alpha(get_alphaCall),
        #[allow(missing_docs)]
        get_current_game_id(get_current_game_idCall),
        #[allow(missing_docs)]
        get_game(get_gameCall),
        #[allow(missing_docs)]
        get_onka_stats(get_onka_statsCall),
        #[allow(missing_docs)]
        get_pyth_fee(get_pyth_feeCall),
        #[allow(missing_docs)]
        get_pyth_request(get_pyth_requestCall),
        #[allow(missing_docs)]
        get_random_value(get_random_valueCall),
        #[allow(missing_docs)]
        get_randomizer_balance(get_randomizer_balanceCall),
        #[allow(missing_docs)]
        get_randomizer_fee(get_randomizer_feeCall),
        #[allow(missing_docs)]
        get_request_status(get_request_statusCall),
        #[allow(missing_docs)]
        get_revenue_bps(get_revenue_bpsCall),
        #[allow(missing_docs)]
        get_speculations(get_speculationsCall),
        #[allow(missing_docs)]
        grantRoles(grantRolesCall),
        #[allow(missing_docs)]
        hasAllRoles(hasAllRolesCall),
        #[allow(missing_docs)]
        hasAnyRole(hasAnyRoleCall),
        #[allow(missing_docs)]
        new_game(new_gameCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        ownershipHandoverExpiresAt(ownershipHandoverExpiresAtCall),
        #[allow(missing_docs)]
        place_bet(place_betCall),
        #[allow(missing_docs)]
        pyth_enabled(pyth_enabledCall),
        #[allow(missing_docs)]
        randomizerCallback(randomizerCallbackCall),
        #[allow(missing_docs)]
        randomizer_deposit(randomizer_depositCall),
        #[allow(missing_docs)]
        randomizer_enabled(randomizer_enabledCall),
        #[allow(missing_docs)]
        randomizer_withdraw(randomizer_withdrawCall),
        #[allow(missing_docs)]
        recover_erc20(recover_erc20Call),
        #[allow(missing_docs)]
        recover_erc721(recover_erc721Call),
        #[allow(missing_docs)]
        recover_eth(recover_ethCall),
        #[allow(missing_docs)]
        register(registerCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        renounceRoles(renounceRolesCall),
        #[allow(missing_docs)]
        requestOwnershipHandover(requestOwnershipHandoverCall),
        #[allow(missing_docs)]
        revenue_wallet(revenue_walletCall),
        #[allow(missing_docs)]
        revokeRoles(revokeRolesCall),
        #[allow(missing_docs)]
        rolesOf(rolesOfCall),
        #[allow(missing_docs)]
        sav_callback(sav_callbackCall),
        #[allow(missing_docs)]
        sav_enabled(sav_enabledCall),
        #[allow(missing_docs)]
        sav_last_key_update_timestamp(sav_last_key_update_timestampCall),
        #[allow(missing_docs)]
        set_revenue(set_revenueCall),
        #[allow(missing_docs)]
        set_revenue_address(set_revenue_addressCall),
        #[allow(missing_docs)]
        set_sav_public_key(set_sav_public_keyCall),
        #[allow(missing_docs)]
        set_sources(set_sourcesCall),
        #[allow(missing_docs)]
        start_game(start_gameCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        verify_beta(verify_betaCall),
    }
    #[automatically_derived]
    impl OnkasOujiGameCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 137u8, 149u8, 205u8],
            [5u8, 168u8, 53u8, 191u8],
            [11u8, 18u8, 228u8, 186u8],
            [14u8, 187u8, 207u8, 181u8],
            [22u8, 47u8, 195u8, 1u8],
            [24u8, 58u8, 79u8, 110u8],
            [25u8, 60u8, 203u8, 97u8],
            [28u8, 16u8, 137u8, 63u8],
            [28u8, 214u8, 77u8, 244u8],
            [30u8, 70u8, 67u8, 9u8],
            [31u8, 218u8, 154u8, 2u8],
            [33u8, 221u8, 149u8, 118u8],
            [35u8, 168u8, 196u8, 186u8],
            [37u8, 74u8, 57u8, 254u8],
            [37u8, 105u8, 41u8, 98u8],
            [44u8, 42u8, 171u8, 65u8],
            [45u8, 233u8, 72u8, 7u8],
            [49u8, 5u8, 44u8, 48u8],
            [51u8, 231u8, 151u8, 122u8],
            [54u8, 51u8, 147u8, 136u8],
            [57u8, 118u8, 6u8, 192u8],
            [59u8, 102u8, 241u8, 192u8],
            [61u8, 177u8, 50u8, 177u8],
            [67u8, 92u8, 2u8, 152u8],
            [67u8, 108u8, 251u8, 155u8],
            [68u8, 25u8, 223u8, 58u8],
            [74u8, 78u8, 231u8, 177u8],
            [80u8, 241u8, 197u8, 90u8],
            [81u8, 78u8, 98u8, 252u8],
            [82u8, 165u8, 241u8, 248u8],
            [84u8, 209u8, 241u8, 61u8],
            [91u8, 190u8, 6u8, 148u8],
            [101u8, 131u8, 94u8, 90u8],
            [103u8, 241u8, 136u8, 183u8],
            [106u8, 65u8, 27u8, 12u8],
            [111u8, 89u8, 35u8, 47u8],
            [113u8, 80u8, 24u8, 166u8],
            [130u8, 40u8, 177u8, 226u8],
            [138u8, 149u8, 230u8, 223u8],
            [141u8, 62u8, 68u8, 90u8],
            [141u8, 165u8, 203u8, 91u8],
            [142u8, 170u8, 73u8, 93u8],
            [145u8, 113u8, 229u8, 88u8],
            [148u8, 197u8, 147u8, 20u8],
            [148u8, 231u8, 236u8, 251u8],
            [152u8, 229u8, 3u8, 10u8],
            [157u8, 204u8, 33u8, 189u8],
            [161u8, 189u8, 198u8, 8u8],
            [170u8, 181u8, 134u8, 194u8],
            [172u8, 227u8, 161u8, 83u8],
            [175u8, 178u8, 24u8, 245u8],
            [181u8, 22u8, 16u8, 92u8],
            [182u8, 249u8, 0u8, 84u8],
            [186u8, 208u8, 24u8, 153u8],
            [188u8, 63u8, 31u8, 10u8],
            [192u8, 167u8, 121u8, 82u8],
            [208u8, 190u8, 11u8, 156u8],
            [217u8, 251u8, 58u8, 186u8],
            [222u8, 133u8, 132u8, 55u8],
            [225u8, 250u8, 142u8, 132u8],
            [226u8, 67u8, 173u8, 191u8],
            [235u8, 233u8, 60u8, 175u8],
            [236u8, 192u8, 68u8, 133u8],
            [240u8, 78u8, 40u8, 62u8],
            [242u8, 253u8, 227u8, 139u8],
            [247u8, 210u8, 70u8, 115u8],
            [249u8, 129u8, 24u8, 213u8],
            [254u8, 232u8, 28u8, 244u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for OnkasOujiGameCalls {
        const NAME: &'static str = "OnkasOujiGameCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 68usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BATTLE_ROUNDS(_) => {
                    <BATTLE_ROUNDSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::HEALTH_PER_LIFE(_) => {
                    <HEALTH_PER_LIFECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_HEALTH(_) => {
                    <INITIAL_HEALTHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NFT_CONTRACT(_) => {
                    <NFT_CONTRACTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PYTH_ENTROPY(_) => {
                    <PYTH_ENTROPYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PYTH_PROVIDER(_) => {
                    <PYTH_PROVIDERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RANDOMIZER(_) => {
                    <RANDOMIZERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SAV_PUB_KEY(_) => {
                    <SAV_PUB_KEYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOKEN_CONTRACT(_) => {
                    <TOKEN_CONTRACTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::WINS_REQUIRED(_) => {
                    <WINS_REQUIREDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_entropyCallback(_) => {
                    <_entropyCallbackCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::abort_game(_) => {
                    <abort_gameCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::abort_request(_) => {
                    <abort_requestCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calc_book(_) => {
                    <calc_bookCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calc_fee(_) => <calc_feeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::cancelOwnershipHandover(_) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::completeOwnershipHandover(_) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::compute_alpha(_) => {
                    <compute_alphaCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::compute_fast_verify_params(_) => {
                    <compute_fast_verify_paramsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decoded_proof_to_hash(_) => {
                    <decoded_proof_to_hashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::end_game(_) => <end_gameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::exec_game(_) => {
                    <exec_gameCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_active_game_ids(_) => {
                    <get_active_game_idsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_active_sources(_) => {
                    <get_active_sourcesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_alpha(_) => {
                    <get_alphaCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_current_game_id(_) => {
                    <get_current_game_idCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_game(_) => <get_gameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::get_onka_stats(_) => {
                    <get_onka_statsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_pyth_fee(_) => {
                    <get_pyth_feeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_pyth_request(_) => {
                    <get_pyth_requestCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_random_value(_) => {
                    <get_random_valueCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_randomizer_balance(_) => {
                    <get_randomizer_balanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_randomizer_fee(_) => {
                    <get_randomizer_feeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_request_status(_) => {
                    <get_request_statusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_revenue_bps(_) => {
                    <get_revenue_bpsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::get_speculations(_) => {
                    <get_speculationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRoles(_) => {
                    <grantRolesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasAllRoles(_) => {
                    <hasAllRolesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasAnyRole(_) => {
                    <hasAnyRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::new_game(_) => <new_gameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ownershipHandoverExpiresAt(_) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::place_bet(_) => {
                    <place_betCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pyth_enabled(_) => {
                    <pyth_enabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::randomizerCallback(_) => {
                    <randomizerCallbackCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::randomizer_deposit(_) => {
                    <randomizer_depositCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::randomizer_enabled(_) => {
                    <randomizer_enabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::randomizer_withdraw(_) => {
                    <randomizer_withdrawCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recover_erc20(_) => {
                    <recover_erc20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recover_erc721(_) => {
                    <recover_erc721Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recover_eth(_) => {
                    <recover_ethCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::register(_) => <registerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRoles(_) => {
                    <renounceRolesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestOwnershipHandover(_) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revenue_wallet(_) => {
                    <revenue_walletCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRoles(_) => {
                    <revokeRolesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rolesOf(_) => <rolesOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sav_callback(_) => {
                    <sav_callbackCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sav_enabled(_) => {
                    <sav_enabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sav_last_key_update_timestamp(_) => {
                    <sav_last_key_update_timestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::set_revenue(_) => {
                    <set_revenueCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::set_revenue_address(_) => {
                    <set_revenue_addressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::set_sav_public_key(_) => {
                    <set_sav_public_keyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::set_sources(_) => {
                    <set_sourcesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::start_game(_) => {
                    <start_gameCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verify_beta(_) => {
                    <verify_betaCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<OnkasOujiGameCalls>] = &[
                {
                    fn get_active_sources(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_active_sourcesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_active_sources)
                    }
                    get_active_sources
                },
                {
                    fn exec_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <exec_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::exec_game)
                    }
                    exec_game
                },
                {
                    fn get_pyth_fee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_pyth_feeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_pyth_fee)
                    }
                    get_pyth_fee
                },
                {
                    fn start_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <start_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::start_game)
                    }
                    start_game
                },
                {
                    fn randomizer_deposit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <randomizer_depositCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::randomizer_deposit)
                    }
                    randomizer_deposit
                },
                {
                    fn renounceRoles(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <renounceRolesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::renounceRoles)
                    }
                    renounceRoles
                },
                {
                    fn HEALTH_PER_LIFE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <HEALTH_PER_LIFECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::HEALTH_PER_LIFE)
                    }
                    HEALTH_PER_LIFE
                },
                {
                    fn grantRoles(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <grantRolesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::grantRoles)
                    }
                    grantRoles
                },
                {
                    fn hasAllRoles(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <hasAllRolesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::hasAllRoles)
                    }
                    hasAllRoles
                },
                {
                    fn sav_last_key_update_timestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <sav_last_key_update_timestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::sav_last_key_update_timestamp)
                    }
                    sav_last_key_update_timestamp
                },
                {
                    fn NFT_CONTRACT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <NFT_CONTRACTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::NFT_CONTRACT)
                    }
                    NFT_CONTRACT
                },
                {
                    fn randomizer_withdraw(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <randomizer_withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::randomizer_withdraw)
                    }
                    randomizer_withdraw
                },
                {
                    fn calc_book(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <calc_bookCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::calc_book)
                    }
                    calc_book
                },
                {
                    fn get_revenue_bps(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_revenue_bpsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_revenue_bps)
                    }
                    get_revenue_bps
                },
                {
                    fn requestOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::requestOwnershipHandover)
                    }
                    requestOwnershipHandover
                },
                {
                    fn get_alpha(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_alphaCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_alpha)
                    }
                    get_alpha
                },
                {
                    fn rolesOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <rolesOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::rolesOf)
                    }
                    rolesOf
                },
                {
                    fn get_speculations(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_speculationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_speculations)
                    }
                    get_speculations
                },
                {
                    fn PYTH_PROVIDER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <PYTH_PROVIDERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::PYTH_PROVIDER)
                    }
                    PYTH_PROVIDER
                },
                {
                    fn TOKEN_CONTRACT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <TOKEN_CONTRACTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::TOKEN_CONTRACT)
                    }
                    TOKEN_CONTRACT
                },
                {
                    fn get_onka_stats(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_onka_statsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_onka_stats)
                    }
                    get_onka_stats
                },
                {
                    fn compute_alpha(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <compute_alphaCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::compute_alpha)
                    }
                    compute_alpha
                },
                {
                    fn recover_eth(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <recover_ethCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::recover_eth)
                    }
                    recover_eth
                },
                {
                    fn calc_fee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <calc_feeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::calc_fee)
                    }
                    calc_fee
                },
                {
                    fn randomizer_enabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <randomizer_enabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::randomizer_enabled)
                    }
                    randomizer_enabled
                },
                {
                    fn WINS_REQUIRED(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <WINS_REQUIREDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::WINS_REQUIRED)
                    }
                    WINS_REQUIRED
                },
                {
                    fn revokeRoles(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <revokeRolesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::revokeRoles)
                    }
                    revokeRoles
                },
                {
                    fn recover_erc721(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <recover_erc721Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::recover_erc721)
                    }
                    recover_erc721
                },
                {
                    fn hasAnyRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <hasAnyRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::hasAnyRole)
                    }
                    hasAnyRole
                },
                {
                    fn _entropyCallback(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <_entropyCallbackCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::_entropyCallback)
                    }
                    _entropyCallback
                },
                {
                    fn cancelOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::cancelOwnershipHandover)
                    }
                    cancelOwnershipHandover
                },
                {
                    fn place_bet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <place_betCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::place_bet)
                    }
                    place_bet
                },
                {
                    fn end_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <end_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::end_game)
                    }
                    end_game
                },
                {
                    fn compute_fast_verify_params(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <compute_fast_verify_paramsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::compute_fast_verify_params)
                    }
                    compute_fast_verify_params
                },
                {
                    fn revenue_wallet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <revenue_walletCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::revenue_wallet)
                    }
                    revenue_wallet
                },
                {
                    fn new_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <new_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::new_game)
                    }
                    new_game
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn abort_request(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <abort_requestCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::abort_request)
                    }
                    abort_request
                },
                {
                    fn pyth_enabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <pyth_enabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::pyth_enabled)
                    }
                    pyth_enabled
                },
                {
                    fn get_active_game_ids(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_active_game_idsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_active_game_ids)
                    }
                    get_active_game_ids
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::owner)
                    }
                    owner
                },
                {
                    fn sav_enabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <sav_enabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::sav_enabled)
                    }
                    sav_enabled
                },
                {
                    fn get_current_game_id(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_current_game_idCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_current_game_id)
                    }
                    get_current_game_id
                },
                {
                    fn get_pyth_request(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_pyth_requestCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_pyth_request)
                    }
                    get_pyth_request
                },
                {
                    fn INITIAL_HEALTH(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <INITIAL_HEALTHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::INITIAL_HEALTH)
                    }
                    INITIAL_HEALTH
                },
                {
                    fn get_randomizer_balance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_randomizer_balanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_randomizer_balance)
                    }
                    get_randomizer_balance
                },
                {
                    fn recover_erc20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <recover_erc20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::recover_erc20)
                    }
                    recover_erc20
                },
                {
                    fn abort_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <abort_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::abort_game)
                    }
                    abort_game
                },
                {
                    fn set_sav_public_key(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <set_sav_public_keyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::set_sav_public_key)
                    }
                    set_sav_public_key
                },
                {
                    fn set_sources(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <set_sourcesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::set_sources)
                    }
                    set_sources
                },
                {
                    fn PYTH_ENTROPY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <PYTH_ENTROPYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::PYTH_ENTROPY)
                    }
                    PYTH_ENTROPY
                },
                {
                    fn verify_beta(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <verify_betaCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::verify_beta)
                    }
                    verify_beta
                },
                {
                    fn decoded_proof_to_hash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <decoded_proof_to_hashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::decoded_proof_to_hash)
                    }
                    decoded_proof_to_hash
                },
                {
                    fn RANDOMIZER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <RANDOMIZERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::RANDOMIZER)
                    }
                    RANDOMIZER
                },
                {
                    fn sav_callback(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <sav_callbackCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::sav_callback)
                    }
                    sav_callback
                },
                {
                    fn set_revenue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <set_revenueCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::set_revenue)
                    }
                    set_revenue
                },
                {
                    fn get_request_status(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_request_statusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_request_status)
                    }
                    get_request_status
                },
                {
                    fn get_game(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_gameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_game)
                    }
                    get_game
                },
                {
                    fn get_random_value(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_random_valueCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_random_value)
                    }
                    get_random_value
                },
                {
                    fn register(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <registerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::register)
                    }
                    register
                },
                {
                    fn BATTLE_ROUNDS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <BATTLE_ROUNDSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::BATTLE_ROUNDS)
                    }
                    BATTLE_ROUNDS
                },
                {
                    fn randomizerCallback(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <randomizerCallbackCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::randomizerCallback)
                    }
                    randomizerCallback
                },
                {
                    fn get_randomizer_fee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <get_randomizer_feeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::get_randomizer_fee)
                    }
                    get_randomizer_fee
                },
                {
                    fn completeOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::completeOwnershipHandover)
                    }
                    completeOwnershipHandover
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn set_revenue_address(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <set_revenue_addressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::set_revenue_address)
                    }
                    set_revenue_address
                },
                {
                    fn SAV_PUB_KEY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <SAV_PUB_KEYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::SAV_PUB_KEY)
                    }
                    SAV_PUB_KEY
                },
                {
                    fn ownershipHandoverExpiresAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameCalls> {
                        <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameCalls::ownershipHandoverExpiresAt)
                    }
                    ownershipHandoverExpiresAt
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BATTLE_ROUNDS(inner) => {
                    <BATTLE_ROUNDSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HEALTH_PER_LIFE(inner) => {
                    <HEALTH_PER_LIFECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_HEALTH(inner) => {
                    <INITIAL_HEALTHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NFT_CONTRACT(inner) => {
                    <NFT_CONTRACTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PYTH_ENTROPY(inner) => {
                    <PYTH_ENTROPYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PYTH_PROVIDER(inner) => {
                    <PYTH_PROVIDERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RANDOMIZER(inner) => {
                    <RANDOMIZERCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SAV_PUB_KEY(inner) => {
                    <SAV_PUB_KEYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOKEN_CONTRACT(inner) => {
                    <TOKEN_CONTRACTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WINS_REQUIRED(inner) => {
                    <WINS_REQUIREDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_entropyCallback(inner) => {
                    <_entropyCallbackCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::abort_game(inner) => {
                    <abort_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::abort_request(inner) => {
                    <abort_requestCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calc_book(inner) => {
                    <calc_bookCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calc_fee(inner) => {
                    <calc_feeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::cancelOwnershipHandover(inner) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::completeOwnershipHandover(inner) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::compute_alpha(inner) => {
                    <compute_alphaCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::compute_fast_verify_params(inner) => {
                    <compute_fast_verify_paramsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decoded_proof_to_hash(inner) => {
                    <decoded_proof_to_hashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::end_game(inner) => {
                    <end_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exec_game(inner) => {
                    <exec_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::get_active_game_ids(inner) => {
                    <get_active_game_idsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_active_sources(inner) => {
                    <get_active_sourcesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_alpha(inner) => {
                    <get_alphaCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::get_current_game_id(inner) => {
                    <get_current_game_idCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_game(inner) => {
                    <get_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::get_onka_stats(inner) => {
                    <get_onka_statsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_pyth_fee(inner) => {
                    <get_pyth_feeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_pyth_request(inner) => {
                    <get_pyth_requestCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_random_value(inner) => {
                    <get_random_valueCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_randomizer_balance(inner) => {
                    <get_randomizer_balanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_randomizer_fee(inner) => {
                    <get_randomizer_feeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_request_status(inner) => {
                    <get_request_statusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_revenue_bps(inner) => {
                    <get_revenue_bpsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::get_speculations(inner) => {
                    <get_speculationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRoles(inner) => {
                    <grantRolesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasAllRoles(inner) => {
                    <hasAllRolesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasAnyRole(inner) => {
                    <hasAnyRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::new_game(inner) => {
                    <new_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ownershipHandoverExpiresAt(inner) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::place_bet(inner) => {
                    <place_betCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pyth_enabled(inner) => {
                    <pyth_enabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomizerCallback(inner) => {
                    <randomizerCallbackCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomizer_deposit(inner) => {
                    <randomizer_depositCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomizer_enabled(inner) => {
                    <randomizer_enabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomizer_withdraw(inner) => {
                    <randomizer_withdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recover_erc20(inner) => {
                    <recover_erc20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recover_erc721(inner) => {
                    <recover_erc721Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recover_eth(inner) => {
                    <recover_ethCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::register(inner) => {
                    <registerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRoles(inner) => {
                    <renounceRolesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestOwnershipHandover(inner) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revenue_wallet(inner) => {
                    <revenue_walletCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRoles(inner) => {
                    <revokeRolesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rolesOf(inner) => {
                    <rolesOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sav_callback(inner) => {
                    <sav_callbackCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sav_enabled(inner) => {
                    <sav_enabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sav_last_key_update_timestamp(inner) => {
                    <sav_last_key_update_timestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::set_revenue(inner) => {
                    <set_revenueCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::set_revenue_address(inner) => {
                    <set_revenue_addressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::set_sav_public_key(inner) => {
                    <set_sav_public_keyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::set_sources(inner) => {
                    <set_sourcesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::start_game(inner) => {
                    <start_gameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verify_beta(inner) => {
                    <verify_betaCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BATTLE_ROUNDS(inner) => {
                    <BATTLE_ROUNDSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HEALTH_PER_LIFE(inner) => {
                    <HEALTH_PER_LIFECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_HEALTH(inner) => {
                    <INITIAL_HEALTHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NFT_CONTRACT(inner) => {
                    <NFT_CONTRACTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PYTH_ENTROPY(inner) => {
                    <PYTH_ENTROPYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PYTH_PROVIDER(inner) => {
                    <PYTH_PROVIDERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RANDOMIZER(inner) => {
                    <RANDOMIZERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SAV_PUB_KEY(inner) => {
                    <SAV_PUB_KEYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOKEN_CONTRACT(inner) => {
                    <TOKEN_CONTRACTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WINS_REQUIRED(inner) => {
                    <WINS_REQUIREDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_entropyCallback(inner) => {
                    <_entropyCallbackCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::abort_game(inner) => {
                    <abort_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::abort_request(inner) => {
                    <abort_requestCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calc_book(inner) => {
                    <calc_bookCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calc_fee(inner) => {
                    <calc_feeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cancelOwnershipHandover(inner) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::completeOwnershipHandover(inner) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::compute_alpha(inner) => {
                    <compute_alphaCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::compute_fast_verify_params(inner) => {
                    <compute_fast_verify_paramsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decoded_proof_to_hash(inner) => {
                    <decoded_proof_to_hashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::end_game(inner) => {
                    <end_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exec_game(inner) => {
                    <exec_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_active_game_ids(inner) => {
                    <get_active_game_idsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_active_sources(inner) => {
                    <get_active_sourcesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_alpha(inner) => {
                    <get_alphaCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_current_game_id(inner) => {
                    <get_current_game_idCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_game(inner) => {
                    <get_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_onka_stats(inner) => {
                    <get_onka_statsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_pyth_fee(inner) => {
                    <get_pyth_feeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_pyth_request(inner) => {
                    <get_pyth_requestCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_random_value(inner) => {
                    <get_random_valueCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_randomizer_balance(inner) => {
                    <get_randomizer_balanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_randomizer_fee(inner) => {
                    <get_randomizer_feeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_request_status(inner) => {
                    <get_request_statusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_revenue_bps(inner) => {
                    <get_revenue_bpsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::get_speculations(inner) => {
                    <get_speculationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRoles(inner) => {
                    <grantRolesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasAllRoles(inner) => {
                    <hasAllRolesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasAnyRole(inner) => {
                    <hasAnyRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::new_game(inner) => {
                    <new_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::ownershipHandoverExpiresAt(inner) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::place_bet(inner) => {
                    <place_betCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pyth_enabled(inner) => {
                    <pyth_enabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomizerCallback(inner) => {
                    <randomizerCallbackCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomizer_deposit(inner) => {
                    <randomizer_depositCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomizer_enabled(inner) => {
                    <randomizer_enabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomizer_withdraw(inner) => {
                    <randomizer_withdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recover_erc20(inner) => {
                    <recover_erc20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recover_erc721(inner) => {
                    <recover_erc721Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recover_eth(inner) => {
                    <recover_ethCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::register(inner) => {
                    <registerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRoles(inner) => {
                    <renounceRolesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestOwnershipHandover(inner) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revenue_wallet(inner) => {
                    <revenue_walletCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRoles(inner) => {
                    <revokeRolesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rolesOf(inner) => {
                    <rolesOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sav_callback(inner) => {
                    <sav_callbackCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sav_enabled(inner) => {
                    <sav_enabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sav_last_key_update_timestamp(inner) => {
                    <sav_last_key_update_timestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::set_revenue(inner) => {
                    <set_revenueCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::set_revenue_address(inner) => {
                    <set_revenue_addressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::set_sav_public_key(inner) => {
                    <set_sav_public_keyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::set_sources(inner) => {
                    <set_sourcesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::start_game(inner) => {
                    <start_gameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verify_beta(inner) => {
                    <verify_betaCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`OnkasOujiGame`](self) custom errors.
    pub enum OnkasOujiGameErrors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        GameExecNotReady(GameExecNotReady),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InsufficientFee(InsufficientFee),
        #[allow(missing_docs)]
        InvalidAmount(InvalidAmount),
        #[allow(missing_docs)]
        InvalidGame(InvalidGame),
        #[allow(missing_docs)]
        InvalidGameID(InvalidGameID),
        #[allow(missing_docs)]
        InvalidGameStatus(InvalidGameStatus),
        #[allow(missing_docs)]
        InvalidInput(InvalidInput),
        #[allow(missing_docs)]
        InvalidNFTOwnership(InvalidNFTOwnership),
        #[allow(missing_docs)]
        InvalidPrediction(InvalidPrediction),
        #[allow(missing_docs)]
        InvalidRequest(InvalidRequest),
        #[allow(missing_docs)]
        InvalidVRFProof(InvalidVRFProof),
        #[allow(missing_docs)]
        NewOwnerIsZeroAddress(NewOwnerIsZeroAddress),
        #[allow(missing_docs)]
        NoHandoverRequest(NoHandoverRequest),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        RegistrationFailed(RegistrationFailed),
        #[allow(missing_docs)]
        RequestCollision(RequestCollision),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
        #[allow(missing_docs)]
        UnauthorizedCaller(UnauthorizedCaller),
    }
    #[automatically_derived]
    impl OnkasOujiGameErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 193u8, 73u8, 240u8],
            [18u8, 207u8, 79u8, 214u8],
            [44u8, 82u8, 17u8, 198u8],
            [50u8, 146u8, 110u8, 221u8],
            [62u8, 229u8, 174u8, 181u8],
            [65u8, 171u8, 200u8, 1u8],
            [67u8, 65u8, 124u8, 68u8],
            [87u8, 226u8, 90u8, 9u8],
            [92u8, 66u8, 124u8, 217u8],
            [106u8, 224u8, 9u8, 103u8],
            [111u8, 94u8, 136u8, 24u8],
            [116u8, 72u8, 251u8, 174u8],
            [119u8, 101u8, 218u8, 53u8],
            [130u8, 180u8, 41u8, 0u8],
            [131u8, 47u8, 152u8, 181u8],
            [164u8, 88u8, 38u8, 27u8],
            [180u8, 250u8, 63u8, 179u8],
            [187u8, 236u8, 77u8, 194u8],
            [234u8, 5u8, 153u8, 248u8],
            [251u8, 218u8, 79u8, 104u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for OnkasOujiGameErrors {
        const NAME: &'static str = "OnkasOujiGameErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GameExecNotReady(_) => {
                    <GameExecNotReady as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientFee(_) => {
                    <InsufficientFee as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAmount(_) => {
                    <InvalidAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidGame(_) => {
                    <InvalidGame as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidGameID(_) => {
                    <InvalidGameID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidGameStatus(_) => {
                    <InvalidGameStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInput(_) => {
                    <InvalidInput as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNFTOwnership(_) => {
                    <InvalidNFTOwnership as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidPrediction(_) => {
                    <InvalidPrediction as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidRequest(_) => {
                    <InvalidRequest as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidVRFProof(_) => {
                    <InvalidVRFProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewOwnerIsZeroAddress(_) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoHandoverRequest(_) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RegistrationFailed(_) => {
                    <RegistrationFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RequestCollision(_) => {
                    <RequestCollision as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedCaller(_) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<OnkasOujiGameErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn InvalidNFTOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidNFTOwnership as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidNFTOwnership)
                    }
                    InvalidNFTOwnership
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn GameExecNotReady(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <GameExecNotReady as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::GameExecNotReady)
                    }
                    GameExecNotReady
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn InvalidRequest(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidRequest as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidRequest)
                    }
                    InvalidRequest
                },
                {
                    fn RegistrationFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <RegistrationFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::RegistrationFailed)
                    }
                    RegistrationFailed
                },
                {
                    fn InvalidGame(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidGame as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidGame)
                    }
                    InvalidGame
                },
                {
                    fn UnauthorizedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <UnauthorizedCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::UnauthorizedCaller)
                    }
                    UnauthorizedCaller
                },
                {
                    fn RequestCollision(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <RequestCollision as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::RequestCollision)
                    }
                    RequestCollision
                },
                {
                    fn NoHandoverRequest(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <NoHandoverRequest as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::NoHandoverRequest)
                    }
                    NoHandoverRequest
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn InvalidGameStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidGameStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidGameStatus)
                    }
                    InvalidGameStatus
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn InsufficientFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InsufficientFee as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InsufficientFee)
                    }
                    InsufficientFee
                },
                {
                    fn InvalidInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidInput as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidInput)
                    }
                    InvalidInput
                },
                {
                    fn InvalidGameID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidGameID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidGameID)
                    }
                    InvalidGameID
                },
                {
                    fn InvalidPrediction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidPrediction as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidPrediction)
                    }
                    InvalidPrediction
                },
                {
                    fn InvalidVRFProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OnkasOujiGameErrors> {
                        <InvalidVRFProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OnkasOujiGameErrors::InvalidVRFProof)
                    }
                    InvalidVRFProof
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::GameExecNotReady(inner) => {
                    <GameExecNotReady as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientFee(inner) => {
                    <InsufficientFee as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidGame(inner) => {
                    <InvalidGame as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidGameID(inner) => {
                    <InvalidGameID as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidGameStatus(inner) => {
                    <InvalidGameStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidNFTOwnership(inner) => {
                    <InvalidNFTOwnership as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidPrediction(inner) => {
                    <InvalidPrediction as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidRequest(inner) => {
                    <InvalidRequest as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidVRFProof(inner) => {
                    <InvalidVRFProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoHandoverRequest(inner) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RegistrationFailed(inner) => {
                    <RegistrationFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RequestCollision(inner) => {
                    <RequestCollision as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GameExecNotReady(inner) => {
                    <GameExecNotReady as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientFee(inner) => {
                    <InsufficientFee as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidGame(inner) => {
                    <InvalidGame as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidGameID(inner) => {
                    <InvalidGameID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidGameStatus(inner) => {
                    <InvalidGameStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNFTOwnership(inner) => {
                    <InvalidNFTOwnership as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidPrediction(inner) => {
                    <InvalidPrediction as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidRequest(inner) => {
                    <InvalidRequest as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidVRFProof(inner) => {
                    <InvalidVRFProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoHandoverRequest(inner) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RegistrationFailed(inner) => {
                    <RegistrationFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RequestCollision(inner) => {
                    <RequestCollision as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`OnkasOujiGame`](self) events.
    pub enum OnkasOujiGameEvents {
        #[allow(missing_docs)]
        BetPlaced(BetPlaced),
        #[allow(missing_docs)]
        CallbackOnInactiveGame(CallbackOnInactiveGame),
        #[allow(missing_docs)]
        CallbackOnInactiveRequest(CallbackOnInactiveRequest),
        #[allow(missing_docs)]
        GameAborted(GameAborted),
        #[allow(missing_docs)]
        GameCompleted(GameCompleted),
        #[allow(missing_docs)]
        GameCreated(GameCreated),
        #[allow(missing_docs)]
        GameExecuted(GameExecuted),
        #[allow(missing_docs)]
        GameStarted(GameStarted),
        #[allow(missing_docs)]
        OwnershipHandoverCanceled(OwnershipHandoverCanceled),
        #[allow(missing_docs)]
        OwnershipHandoverRequested(OwnershipHandoverRequested),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        RandomnessGenerated(RandomnessGenerated),
        #[allow(missing_docs)]
        RandomnessRequested(RandomnessRequested),
        #[allow(missing_docs)]
        RandomnessSourcesUpdated(RandomnessSourcesUpdated),
        #[allow(missing_docs)]
        RequestAborted(RequestAborted),
        #[allow(missing_docs)]
        RequestCompleted(RequestCompleted),
        #[allow(missing_docs)]
        RevenueSet(RevenueSet),
        #[allow(missing_docs)]
        RolesUpdated(RolesUpdated),
        #[allow(missing_docs)]
        SAVPublicKeyUpdated(SAVPublicKeyUpdated),
        #[allow(missing_docs)]
        TokenNotSupported(TokenNotSupported),
        #[allow(missing_docs)]
        UserRegistered(UserRegistered),
    }
    #[automatically_derived]
    impl OnkasOujiGameEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                24u8,
                251u8,
                68u8,
                203u8,
                206u8,
                56u8,
                61u8,
                27u8,
                201u8,
                98u8,
                71u8,
                148u8,
                176u8,
                146u8,
                74u8,
                180u8,
                119u8,
                185u8,
                91u8,
                229u8,
                154u8,
                219u8,
                179u8,
                132u8,
                199u8,
                94u8,
                68u8,
                5u8,
                228u8,
                116u8,
                212u8,
                141u8,
            ],
            [
                37u8,
                84u8,
                189u8,
                111u8,
                75u8,
                171u8,
                218u8,
                254u8,
                64u8,
                238u8,
                205u8,
                198u8,
                82u8,
                212u8,
                48u8,
                17u8,
                253u8,
                66u8,
                3u8,
                150u8,
                101u8,
                184u8,
                66u8,
                26u8,
                69u8,
                57u8,
                87u8,
                225u8,
                32u8,
                151u8,
                140u8,
                0u8,
            ],
            [
                49u8,
                84u8,
                57u8,
                97u8,
                186u8,
                214u8,
                225u8,
                184u8,
                134u8,
                254u8,
                75u8,
                60u8,
                6u8,
                13u8,
                61u8,
                151u8,
                194u8,
                31u8,
                188u8,
                128u8,
                230u8,
                58u8,
                178u8,
                46u8,
                158u8,
                234u8,
                101u8,
                217u8,
                210u8,
                220u8,
                124u8,
                119u8,
            ],
            [
                62u8,
                200u8,
                100u8,
                47u8,
                139u8,
                118u8,
                132u8,
                153u8,
                17u8,
                94u8,
                161u8,
                135u8,
                220u8,
                104u8,
                154u8,
                107u8,
                3u8,
                229u8,
                2u8,
                208u8,
                129u8,
                9u8,
                199u8,
                139u8,
                132u8,
                109u8,
                226u8,
                2u8,
                2u8,
                246u8,
                249u8,
                16u8,
            ],
            [
                74u8,
                247u8,
                27u8,
                2u8,
                30u8,
                121u8,
                156u8,
                98u8,
                193u8,
                88u8,
                189u8,
                84u8,
                99u8,
                108u8,
                168u8,
                218u8,
                47u8,
                162u8,
                97u8,
                21u8,
                162u8,
                26u8,
                45u8,
                198u8,
                239u8,
                228u8,
                134u8,
                236u8,
                16u8,
                79u8,
                209u8,
                95u8,
            ],
            [
                80u8,
                173u8,
                8u8,
                245u8,
                138u8,
                39u8,
                242u8,
                133u8,
                29u8,
                126u8,
                58u8,
                27u8,
                58u8,
                106u8,
                70u8,
                178u8,
                144u8,
                242u8,
                206u8,
                103u8,
                126u8,
                153u8,
                100u8,
                45u8,
                48u8,
                255u8,
                99u8,
                151u8,
                33u8,
                231u8,
                119u8,
                144u8,
            ],
            [
                98u8,
                72u8,
                213u8,
                162u8,
                9u8,
                112u8,
                45u8,
                184u8,
                114u8,
                184u8,
                48u8,
                69u8,
                213u8,
                110u8,
                75u8,
                175u8,
                72u8,
                54u8,
                44u8,
                231u8,
                167u8,
                205u8,
                162u8,
                133u8,
                166u8,
                113u8,
                231u8,
                193u8,
                230u8,
                63u8,
                68u8,
                185u8,
            ],
            [
                113u8,
                90u8,
                213u8,
                206u8,
                97u8,
                252u8,
                149u8,
                149u8,
                199u8,
                180u8,
                21u8,
                40u8,
                157u8,
                89u8,
                207u8,
                32u8,
                63u8,
                35u8,
                169u8,
                79u8,
                160u8,
                111u8,
                4u8,
                175u8,
                126u8,
                72u8,
                154u8,
                10u8,
                118u8,
                225u8,
                254u8,
                38u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                142u8,
                240u8,
                29u8,
                231u8,
                72u8,
                85u8,
                92u8,
                209u8,
                213u8,
                67u8,
                29u8,
                101u8,
                61u8,
                171u8,
                134u8,
                67u8,
                42u8,
                29u8,
                125u8,
                117u8,
                9u8,
                102u8,
                33u8,
                222u8,
                202u8,
                122u8,
                110u8,
                75u8,
                65u8,
                77u8,
                230u8,
                54u8,
            ],
            [
                155u8,
                46u8,
                217u8,
                79u8,
                145u8,
                50u8,
                43u8,
                216u8,
                179u8,
                61u8,
                31u8,
                67u8,
                167u8,
                83u8,
                125u8,
                143u8,
                176u8,
                183u8,
                150u8,
                98u8,
                136u8,
                216u8,
                240u8,
                63u8,
                23u8,
                191u8,
                131u8,
                167u8,
                195u8,
                166u8,
                139u8,
                77u8,
            ],
            [
                161u8,
                136u8,
                147u8,
                161u8,
                107u8,
                129u8,
                143u8,
                62u8,
                140u8,
                83u8,
                24u8,
                146u8,
                49u8,
                37u8,
                12u8,
                176u8,
                43u8,
                181u8,
                92u8,
                179u8,
                40u8,
                2u8,
                166u8,
                213u8,
                194u8,
                181u8,
                235u8,
                133u8,
                108u8,
                219u8,
                127u8,
                30u8,
            ],
            [
                178u8,
                111u8,
                224u8,
                142u8,
                78u8,
                81u8,
                192u8,
                30u8,
                92u8,
                255u8,
                255u8,
                95u8,
                72u8,
                135u8,
                36u8,
                149u8,
                153u8,
                119u8,
                154u8,
                160u8,
                212u8,
                248u8,
                99u8,
                111u8,
                244u8,
                231u8,
                205u8,
                72u8,
                49u8,
                180u8,
                149u8,
                237u8,
            ],
            [
                179u8,
                152u8,
                202u8,
                35u8,
                91u8,
                62u8,
                255u8,
                47u8,
                103u8,
                231u8,
                39u8,
                7u8,
                36u8,
                101u8,
                13u8,
                19u8,
                228u8,
                124u8,
                213u8,
                249u8,
                218u8,
                193u8,
                59u8,
                145u8,
                135u8,
                237u8,
                129u8,
                177u8,
                39u8,
                206u8,
                36u8,
                199u8,
            ],
            [
                193u8,
                33u8,
                216u8,
                13u8,
                234u8,
                38u8,
                72u8,
                72u8,
                131u8,
                28u8,
                249u8,
                49u8,
                251u8,
                182u8,
                86u8,
                215u8,
                167u8,
                143u8,
                122u8,
                128u8,
                54u8,
                23u8,
                119u8,
                154u8,
                212u8,
                169u8,
                41u8,
                192u8,
                151u8,
                222u8,
                207u8,
                85u8,
            ],
            [
                198u8,
                164u8,
                104u8,
                184u8,
                67u8,
                133u8,
                205u8,
                77u8,
                252u8,
                68u8,
                13u8,
                178u8,
                29u8,
                13u8,
                246u8,
                240u8,
                54u8,
                18u8,
                186u8,
                67u8,
                179u8,
                94u8,
                254u8,
                25u8,
                13u8,
                238u8,
                153u8,
                59u8,
                70u8,
                106u8,
                81u8,
                152u8,
            ],
            [
                212u8,
                120u8,
                250u8,
                36u8,
                114u8,
                1u8,
                28u8,
                160u8,
                121u8,
                141u8,
                53u8,
                17u8,
                95u8,
                195u8,
                202u8,
                167u8,
                38u8,
                140u8,
                73u8,
                203u8,
                125u8,
                200u8,
                138u8,
                37u8,
                24u8,
                52u8,
                79u8,
                201u8,
                99u8,
                27u8,
                191u8,
                44u8,
            ],
            [
                219u8,
                243u8,
                106u8,
                16u8,
                125u8,
                161u8,
                158u8,
                73u8,
                82u8,
                122u8,
                113u8,
                118u8,
                161u8,
                186u8,
                191u8,
                150u8,
                59u8,
                75u8,
                15u8,
                248u8,
                205u8,
                227u8,
                94u8,
                227u8,
                93u8,
                108u8,
                216u8,
                241u8,
                249u8,
                172u8,
                126u8,
                29u8,
            ],
            [
                236u8,
                94u8,
                162u8,
                63u8,
                114u8,
                160u8,
                10u8,
                46u8,
                71u8,
                125u8,
                113u8,
                77u8,
                192u8,
                18u8,
                152u8,
                98u8,
                113u8,
                205u8,
                60u8,
                150u8,
                173u8,
                149u8,
                199u8,
                254u8,
                95u8,
                98u8,
                159u8,
                247u8,
                152u8,
                71u8,
                253u8,
                33u8,
            ],
            [
                246u8,
                43u8,
                164u8,
                127u8,
                227u8,
                255u8,
                97u8,
                8u8,
                137u8,
                22u8,
                15u8,
                2u8,
                87u8,
                19u8,
                150u8,
                232u8,
                110u8,
                33u8,
                183u8,
                170u8,
                220u8,
                189u8,
                226u8,
                113u8,
                145u8,
                146u8,
                226u8,
                6u8,
                133u8,
                59u8,
                51u8,
                31u8,
            ],
            [
                250u8,
                123u8,
                142u8,
                171u8,
                125u8,
                166u8,
                127u8,
                65u8,
                44u8,
                201u8,
                87u8,
                94u8,
                212u8,
                52u8,
                100u8,
                70u8,
                143u8,
                155u8,
                251u8,
                174u8,
                137u8,
                209u8,
                103u8,
                89u8,
                23u8,
                52u8,
                108u8,
                166u8,
                216u8,
                254u8,
                60u8,
                146u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for OnkasOujiGameEvents {
        const NAME: &'static str = "OnkasOujiGameEvents";
        const COUNT: usize = 21usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<BetPlaced as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BetPlaced as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BetPlaced)
                }
                Some(
                    <CallbackOnInactiveGame as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CallbackOnInactiveGame as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CallbackOnInactiveGame)
                }
                Some(
                    <CallbackOnInactiveRequest as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CallbackOnInactiveRequest as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CallbackOnInactiveRequest)
                }
                Some(<GameAborted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameAborted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::GameAborted)
                }
                Some(<GameCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::GameCompleted)
                }
                Some(<GameCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::GameCreated)
                }
                Some(<GameExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::GameExecuted)
                }
                Some(<GameStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <GameStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::GameStarted)
                }
                Some(
                    <OwnershipHandoverCanceled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipHandoverCanceled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipHandoverCanceled)
                }
                Some(
                    <OwnershipHandoverRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipHandoverRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipHandoverRequested)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <RandomnessGenerated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RandomnessGenerated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RandomnessGenerated)
                }
                Some(
                    <RandomnessRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RandomnessRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RandomnessRequested)
                }
                Some(
                    <RandomnessSourcesUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RandomnessSourcesUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RandomnessSourcesUpdated)
                }
                Some(<RequestAborted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RequestAborted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RequestAborted)
                }
                Some(<RequestCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RequestCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RequestCompleted)
                }
                Some(<RevenueSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RevenueSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RevenueSet)
                }
                Some(<RolesUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RolesUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RolesUpdated)
                }
                Some(
                    <SAVPublicKeyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SAVPublicKeyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SAVPublicKeyUpdated)
                }
                Some(
                    <TokenNotSupported as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TokenNotSupported as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TokenNotSupported)
                }
                Some(<UserRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <UserRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UserRegistered)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for OnkasOujiGameEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BetPlaced(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CallbackOnInactiveGame(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CallbackOnInactiveRequest(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GameStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipHandoverCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipHandoverRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RandomnessGenerated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RandomnessRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RandomnessSourcesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RequestAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RequestCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RevenueSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RolesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SAVPublicKeyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TokenNotSupported(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UserRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BetPlaced(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CallbackOnInactiveGame(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CallbackOnInactiveRequest(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GameStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipHandoverCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipHandoverRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RandomnessGenerated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RandomnessRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RandomnessSourcesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RequestAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RequestCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RevenueSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RolesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SAVPublicKeyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TokenNotSupported(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UserRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`OnkasOujiGame`](self) contract instance.

See the [wrapper's documentation](`OnkasOujiGameInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> OnkasOujiGameInstance<T, P, N> {
        OnkasOujiGameInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _nft_contract: alloy::sol_types::private::Address,
        _token_contract: alloy::sol_types::private::Address,
        _pyth_entropy: alloy::sol_types::private::Address,
        _pyth_provider: alloy::sol_types::private::Address,
        _randomizer: alloy::sol_types::private::Address,
        _sav_pk: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        _revenue_wallet: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<OnkasOujiGameInstance<T, P, N>>,
    > {
        OnkasOujiGameInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            _nft_contract,
            _token_contract,
            _pyth_entropy,
            _pyth_provider,
            _randomizer,
            _sav_pk,
            _revenue_wallet,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _nft_contract: alloy::sol_types::private::Address,
        _token_contract: alloy::sol_types::private::Address,
        _pyth_entropy: alloy::sol_types::private::Address,
        _pyth_provider: alloy::sol_types::private::Address,
        _randomizer: alloy::sol_types::private::Address,
        _sav_pk: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        _revenue_wallet: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        OnkasOujiGameInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            _nft_contract,
            _token_contract,
            _pyth_entropy,
            _pyth_provider,
            _randomizer,
            _sav_pk,
            _revenue_wallet,
        )
    }
    /**A [`OnkasOujiGame`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`OnkasOujiGame`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct OnkasOujiGameInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for OnkasOujiGameInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("OnkasOujiGameInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OnkasOujiGameInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`OnkasOujiGame`](self) contract instance.

See the [wrapper's documentation](`OnkasOujiGameInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _nft_contract: alloy::sol_types::private::Address,
            _token_contract: alloy::sol_types::private::Address,
            _pyth_entropy: alloy::sol_types::private::Address,
            _pyth_provider: alloy::sol_types::private::Address,
            _randomizer: alloy::sol_types::private::Address,
            _sav_pk: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            _revenue_wallet: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<OnkasOujiGameInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _nft_contract,
                _token_contract,
                _pyth_entropy,
                _pyth_provider,
                _randomizer,
                _sav_pk,
                _revenue_wallet,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _nft_contract: alloy::sol_types::private::Address,
            _token_contract: alloy::sol_types::private::Address,
            _pyth_entropy: alloy::sol_types::private::Address,
            _pyth_provider: alloy::sol_types::private::Address,
            _randomizer: alloy::sol_types::private::Address,
            _sav_pk: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            _revenue_wallet: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _nft_contract,
                            _token_contract,
                            _pyth_entropy,
                            _pyth_provider,
                            _randomizer,
                            _sav_pk,
                            _revenue_wallet,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> OnkasOujiGameInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> OnkasOujiGameInstance<T, P, N> {
            OnkasOujiGameInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OnkasOujiGameInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BATTLE_ROUNDS`] function.
        pub fn BATTLE_ROUNDS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BATTLE_ROUNDSCall, N> {
            self.call_builder(&BATTLE_ROUNDSCall {})
        }
        ///Creates a new call builder for the [`HEALTH_PER_LIFE`] function.
        pub fn HEALTH_PER_LIFE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, HEALTH_PER_LIFECall, N> {
            self.call_builder(&HEALTH_PER_LIFECall {})
        }
        ///Creates a new call builder for the [`INITIAL_HEALTH`] function.
        pub fn INITIAL_HEALTH(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_HEALTHCall, N> {
            self.call_builder(&INITIAL_HEALTHCall {})
        }
        ///Creates a new call builder for the [`NFT_CONTRACT`] function.
        pub fn NFT_CONTRACT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NFT_CONTRACTCall, N> {
            self.call_builder(&NFT_CONTRACTCall {})
        }
        ///Creates a new call builder for the [`PYTH_ENTROPY`] function.
        pub fn PYTH_ENTROPY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PYTH_ENTROPYCall, N> {
            self.call_builder(&PYTH_ENTROPYCall {})
        }
        ///Creates a new call builder for the [`PYTH_PROVIDER`] function.
        pub fn PYTH_PROVIDER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PYTH_PROVIDERCall, N> {
            self.call_builder(&PYTH_PROVIDERCall {})
        }
        ///Creates a new call builder for the [`RANDOMIZER`] function.
        pub fn RANDOMIZER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, RANDOMIZERCall, N> {
            self.call_builder(&RANDOMIZERCall {})
        }
        ///Creates a new call builder for the [`SAV_PUB_KEY`] function.
        pub fn SAV_PUB_KEY(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, SAV_PUB_KEYCall, N> {
            self.call_builder(&SAV_PUB_KEYCall { _0 })
        }
        ///Creates a new call builder for the [`TOKEN_CONTRACT`] function.
        pub fn TOKEN_CONTRACT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOKEN_CONTRACTCall, N> {
            self.call_builder(&TOKEN_CONTRACTCall {})
        }
        ///Creates a new call builder for the [`WINS_REQUIRED`] function.
        pub fn WINS_REQUIRED(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, WINS_REQUIREDCall, N> {
            self.call_builder(&WINS_REQUIREDCall {})
        }
        ///Creates a new call builder for the [`_entropyCallback`] function.
        pub fn _entropyCallback(
            &self,
            sequence: u64,
            provider: alloy::sol_types::private::Address,
            randomNumber: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, _entropyCallbackCall, N> {
            self.call_builder(
                &_entropyCallbackCall {
                    sequence,
                    provider,
                    randomNumber,
                },
            )
        }
        ///Creates a new call builder for the [`abort_game`] function.
        pub fn abort_game(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, abort_gameCall, N> {
            self.call_builder(&abort_gameCall { game_id })
        }
        ///Creates a new call builder for the [`abort_request`] function.
        pub fn abort_request(
            &self,
            req_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, abort_requestCall, N> {
            self.call_builder(&abort_requestCall { req_id })
        }
        ///Creates a new call builder for the [`calc_book`] function.
        pub fn calc_book(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calc_bookCall, N> {
            self.call_builder(&calc_bookCall { game_id })
        }
        ///Creates a new call builder for the [`calc_fee`] function.
        pub fn calc_fee(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, calc_feeCall, N> {
            self.call_builder(&calc_feeCall {})
        }
        ///Creates a new call builder for the [`cancelOwnershipHandover`] function.
        pub fn cancelOwnershipHandover(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, cancelOwnershipHandoverCall, N> {
            self.call_builder(&cancelOwnershipHandoverCall {})
        }
        ///Creates a new call builder for the [`completeOwnershipHandover`] function.
        pub fn completeOwnershipHandover(
            &self,
            pendingOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, completeOwnershipHandoverCall, N> {
            self.call_builder(
                &completeOwnershipHandoverCall {
                    pendingOwner,
                },
            )
        }
        ///Creates a new call builder for the [`compute_alpha`] function.
        pub fn compute_alpha(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, compute_alphaCall, N> {
            self.call_builder(&compute_alphaCall { game_id })
        }
        ///Creates a new call builder for the [`compute_fast_verify_params`] function.
        pub fn compute_fast_verify_params(
            &self,
            _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            _alpha: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, compute_fast_verify_paramsCall, N> {
            self.call_builder(
                &compute_fast_verify_paramsCall {
                    _proof,
                    _alpha,
                },
            )
        }
        ///Creates a new call builder for the [`decoded_proof_to_hash`] function.
        pub fn decoded_proof_to_hash(
            &self,
            pi: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        ) -> alloy_contract::SolCallBuilder<T, &P, decoded_proof_to_hashCall, N> {
            self.call_builder(&decoded_proof_to_hashCall { pi })
        }
        ///Creates a new call builder for the [`end_game`] function.
        pub fn end_game(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, end_gameCall, N> {
            self.call_builder(&end_gameCall { game_id })
        }
        ///Creates a new call builder for the [`exec_game`] function.
        pub fn exec_game(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, exec_gameCall, N> {
            self.call_builder(&exec_gameCall { game_id })
        }
        ///Creates a new call builder for the [`get_active_game_ids`] function.
        pub fn get_active_game_ids(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_active_game_idsCall, N> {
            self.call_builder(&get_active_game_idsCall {})
        }
        ///Creates a new call builder for the [`get_active_sources`] function.
        pub fn get_active_sources(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_active_sourcesCall, N> {
            self.call_builder(&get_active_sourcesCall {})
        }
        ///Creates a new call builder for the [`get_alpha`] function.
        pub fn get_alpha(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_alphaCall, N> {
            self.call_builder(&get_alphaCall { game_id })
        }
        ///Creates a new call builder for the [`get_current_game_id`] function.
        pub fn get_current_game_id(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_current_game_idCall, N> {
            self.call_builder(&get_current_game_idCall {})
        }
        ///Creates a new call builder for the [`get_game`] function.
        pub fn get_game(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_gameCall, N> {
            self.call_builder(&get_gameCall { game_id })
        }
        ///Creates a new call builder for the [`get_onka_stats`] function.
        pub fn get_onka_stats(
            &self,
            nft_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_onka_statsCall, N> {
            self.call_builder(&get_onka_statsCall { nft_id })
        }
        ///Creates a new call builder for the [`get_pyth_fee`] function.
        pub fn get_pyth_fee(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_pyth_feeCall, N> {
            self.call_builder(&get_pyth_feeCall {})
        }
        ///Creates a new call builder for the [`get_pyth_request`] function.
        pub fn get_pyth_request(
            &self,
            src_id: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_pyth_requestCall, N> {
            self.call_builder(&get_pyth_requestCall { src_id })
        }
        ///Creates a new call builder for the [`get_random_value`] function.
        pub fn get_random_value(
            &self,
            req_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_random_valueCall, N> {
            self.call_builder(&get_random_valueCall { req_id })
        }
        ///Creates a new call builder for the [`get_randomizer_balance`] function.
        pub fn get_randomizer_balance(
            &self,
            liquid: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_randomizer_balanceCall, N> {
            self.call_builder(
                &get_randomizer_balanceCall {
                    liquid,
                },
            )
        }
        ///Creates a new call builder for the [`get_randomizer_fee`] function.
        pub fn get_randomizer_fee(
            &self,
            atomic: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_randomizer_feeCall, N> {
            self.call_builder(&get_randomizer_feeCall { atomic })
        }
        ///Creates a new call builder for the [`get_request_status`] function.
        pub fn get_request_status(
            &self,
            req_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_request_statusCall, N> {
            self.call_builder(&get_request_statusCall { req_id })
        }
        ///Creates a new call builder for the [`get_revenue_bps`] function.
        pub fn get_revenue_bps(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_revenue_bpsCall, N> {
            self.call_builder(&get_revenue_bpsCall {})
        }
        ///Creates a new call builder for the [`get_speculations`] function.
        pub fn get_speculations(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, get_speculationsCall, N> {
            self.call_builder(&get_speculationsCall { game_id })
        }
        ///Creates a new call builder for the [`grantRoles`] function.
        pub fn grantRoles(
            &self,
            user: alloy::sol_types::private::Address,
            roles: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRolesCall, N> {
            self.call_builder(&grantRolesCall { user, roles })
        }
        ///Creates a new call builder for the [`hasAllRoles`] function.
        pub fn hasAllRoles(
            &self,
            user: alloy::sol_types::private::Address,
            roles: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasAllRolesCall, N> {
            self.call_builder(&hasAllRolesCall { user, roles })
        }
        ///Creates a new call builder for the [`hasAnyRole`] function.
        pub fn hasAnyRole(
            &self,
            user: alloy::sol_types::private::Address,
            roles: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasAnyRoleCall, N> {
            self.call_builder(&hasAnyRoleCall { user, roles })
        }
        ///Creates a new call builder for the [`new_game`] function.
        pub fn new_game(
            &self,
            players: [<Player as alloy::sol_types::SolType>::RustType; 2usize],
            amount: alloy::sol_types::private::primitives::aliases::U256,
            alpha_prefix: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, new_gameCall, N> {
            self.call_builder(
                &new_gameCall {
                    players,
                    amount,
                    alpha_prefix,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`ownershipHandoverExpiresAt`] function.
        pub fn ownershipHandoverExpiresAt(
            &self,
            pendingOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, ownershipHandoverExpiresAtCall, N> {
            self.call_builder(
                &ownershipHandoverExpiresAtCall {
                    pendingOwner,
                },
            )
        }
        ///Creates a new call builder for the [`place_bet`] function.
        pub fn place_bet(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
            speculator: alloy::sol_types::private::Address,
            prediction: bool,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, place_betCall, N> {
            self.call_builder(
                &place_betCall {
                    game_id,
                    speculator,
                    prediction,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`pyth_enabled`] function.
        pub fn pyth_enabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pyth_enabledCall, N> {
            self.call_builder(&pyth_enabledCall {})
        }
        ///Creates a new call builder for the [`randomizerCallback`] function.
        pub fn randomizerCallback(
            &self,
            _id: alloy::sol_types::private::primitives::aliases::U256,
            _beta: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomizerCallbackCall, N> {
            self.call_builder(
                &randomizerCallbackCall {
                    _id,
                    _beta,
                },
            )
        }
        ///Creates a new call builder for the [`randomizer_deposit`] function.
        pub fn randomizer_deposit(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomizer_depositCall, N> {
            self.call_builder(&randomizer_depositCall { amount })
        }
        ///Creates a new call builder for the [`randomizer_enabled`] function.
        pub fn randomizer_enabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomizer_enabledCall, N> {
            self.call_builder(&randomizer_enabledCall {})
        }
        ///Creates a new call builder for the [`randomizer_withdraw`] function.
        pub fn randomizer_withdraw(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomizer_withdrawCall, N> {
            self.call_builder(&randomizer_withdrawCall { amount })
        }
        ///Creates a new call builder for the [`recover_erc20`] function.
        pub fn recover_erc20(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, recover_erc20Call, N> {
            self.call_builder(&recover_erc20Call { token })
        }
        ///Creates a new call builder for the [`recover_erc721`] function.
        pub fn recover_erc721(
            &self,
            token: alloy::sol_types::private::Address,
            token_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, recover_erc721Call, N> {
            self.call_builder(
                &recover_erc721Call {
                    token,
                    token_id,
                },
            )
        }
        ///Creates a new call builder for the [`recover_eth`] function.
        pub fn recover_eth(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, recover_ethCall, N> {
            self.call_builder(&recover_ethCall {})
        }
        ///Creates a new call builder for the [`register`] function.
        pub fn register(
            &self,
            secret: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerCall, N> {
            self.call_builder(&registerCall { secret })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`renounceRoles`] function.
        pub fn renounceRoles(
            &self,
            roles: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRolesCall, N> {
            self.call_builder(&renounceRolesCall { roles })
        }
        ///Creates a new call builder for the [`requestOwnershipHandover`] function.
        pub fn requestOwnershipHandover(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, requestOwnershipHandoverCall, N> {
            self.call_builder(&requestOwnershipHandoverCall {})
        }
        ///Creates a new call builder for the [`revenue_wallet`] function.
        pub fn revenue_wallet(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revenue_walletCall, N> {
            self.call_builder(&revenue_walletCall {})
        }
        ///Creates a new call builder for the [`revokeRoles`] function.
        pub fn revokeRoles(
            &self,
            user: alloy::sol_types::private::Address,
            roles: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRolesCall, N> {
            self.call_builder(&revokeRolesCall { user, roles })
        }
        ///Creates a new call builder for the [`rolesOf`] function.
        pub fn rolesOf(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, rolesOfCall, N> {
            self.call_builder(&rolesOfCall { user })
        }
        ///Creates a new call builder for the [`sav_callback`] function.
        pub fn sav_callback(
            &self,
            req_id: alloy::sol_types::private::primitives::aliases::U256,
            _alpha: alloy::sol_types::private::Bytes,
            beta: alloy::sol_types::private::FixedBytes<32>,
            _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            _U: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            _V: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        ) -> alloy_contract::SolCallBuilder<T, &P, sav_callbackCall, N> {
            self.call_builder(
                &sav_callbackCall {
                    req_id,
                    _alpha,
                    beta,
                    _proof,
                    _U,
                    _V,
                },
            )
        }
        ///Creates a new call builder for the [`sav_enabled`] function.
        pub fn sav_enabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sav_enabledCall, N> {
            self.call_builder(&sav_enabledCall {})
        }
        ///Creates a new call builder for the [`sav_last_key_update_timestamp`] function.
        pub fn sav_last_key_update_timestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            sav_last_key_update_timestampCall,
            N,
        > {
            self.call_builder(
                &sav_last_key_update_timestampCall {
                },
            )
        }
        ///Creates a new call builder for the [`set_revenue`] function.
        pub fn set_revenue(
            &self,
            bps: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, set_revenueCall, N> {
            self.call_builder(&set_revenueCall { bps })
        }
        ///Creates a new call builder for the [`set_revenue_address`] function.
        pub fn set_revenue_address(
            &self,
            addr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, set_revenue_addressCall, N> {
            self.call_builder(&set_revenue_addressCall { addr })
        }
        ///Creates a new call builder for the [`set_sav_public_key`] function.
        pub fn set_sav_public_key(
            &self,
            _publicKey: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        ) -> alloy_contract::SolCallBuilder<T, &P, set_sav_public_keyCall, N> {
            self.call_builder(
                &set_sav_public_keyCall {
                    _publicKey,
                },
            )
        }
        ///Creates a new call builder for the [`set_sources`] function.
        pub fn set_sources(
            &self,
            sources: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, set_sourcesCall, N> {
            self.call_builder(&set_sourcesCall { sources })
        }
        ///Creates a new call builder for the [`start_game`] function.
        pub fn start_game(
            &self,
            game_id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, start_gameCall, N> {
            self.call_builder(&start_gameCall { game_id })
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`verify_beta`] function.
        pub fn verify_beta(
            &self,
            _proof: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            _beta: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, verify_betaCall, N> {
            self.call_builder(&verify_betaCall { _proof, _beta })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OnkasOujiGameInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BetPlaced`] event.
        pub fn BetPlaced_filter(&self) -> alloy_contract::Event<T, &P, BetPlaced, N> {
            self.event_filter::<BetPlaced>()
        }
        ///Creates a new event filter for the [`CallbackOnInactiveGame`] event.
        pub fn CallbackOnInactiveGame_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CallbackOnInactiveGame, N> {
            self.event_filter::<CallbackOnInactiveGame>()
        }
        ///Creates a new event filter for the [`CallbackOnInactiveRequest`] event.
        pub fn CallbackOnInactiveRequest_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CallbackOnInactiveRequest, N> {
            self.event_filter::<CallbackOnInactiveRequest>()
        }
        ///Creates a new event filter for the [`GameAborted`] event.
        pub fn GameAborted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, GameAborted, N> {
            self.event_filter::<GameAborted>()
        }
        ///Creates a new event filter for the [`GameCompleted`] event.
        pub fn GameCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, GameCompleted, N> {
            self.event_filter::<GameCompleted>()
        }
        ///Creates a new event filter for the [`GameCreated`] event.
        pub fn GameCreated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, GameCreated, N> {
            self.event_filter::<GameCreated>()
        }
        ///Creates a new event filter for the [`GameExecuted`] event.
        pub fn GameExecuted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, GameExecuted, N> {
            self.event_filter::<GameExecuted>()
        }
        ///Creates a new event filter for the [`GameStarted`] event.
        pub fn GameStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, GameStarted, N> {
            self.event_filter::<GameStarted>()
        }
        ///Creates a new event filter for the [`OwnershipHandoverCanceled`] event.
        pub fn OwnershipHandoverCanceled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipHandoverCanceled, N> {
            self.event_filter::<OwnershipHandoverCanceled>()
        }
        ///Creates a new event filter for the [`OwnershipHandoverRequested`] event.
        pub fn OwnershipHandoverRequested_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipHandoverRequested, N> {
            self.event_filter::<OwnershipHandoverRequested>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`RandomnessGenerated`] event.
        pub fn RandomnessGenerated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RandomnessGenerated, N> {
            self.event_filter::<RandomnessGenerated>()
        }
        ///Creates a new event filter for the [`RandomnessRequested`] event.
        pub fn RandomnessRequested_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RandomnessRequested, N> {
            self.event_filter::<RandomnessRequested>()
        }
        ///Creates a new event filter for the [`RandomnessSourcesUpdated`] event.
        pub fn RandomnessSourcesUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RandomnessSourcesUpdated, N> {
            self.event_filter::<RandomnessSourcesUpdated>()
        }
        ///Creates a new event filter for the [`RequestAborted`] event.
        pub fn RequestAborted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RequestAborted, N> {
            self.event_filter::<RequestAborted>()
        }
        ///Creates a new event filter for the [`RequestCompleted`] event.
        pub fn RequestCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RequestCompleted, N> {
            self.event_filter::<RequestCompleted>()
        }
        ///Creates a new event filter for the [`RevenueSet`] event.
        pub fn RevenueSet_filter(&self) -> alloy_contract::Event<T, &P, RevenueSet, N> {
            self.event_filter::<RevenueSet>()
        }
        ///Creates a new event filter for the [`RolesUpdated`] event.
        pub fn RolesUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RolesUpdated, N> {
            self.event_filter::<RolesUpdated>()
        }
        ///Creates a new event filter for the [`SAVPublicKeyUpdated`] event.
        pub fn SAVPublicKeyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SAVPublicKeyUpdated, N> {
            self.event_filter::<SAVPublicKeyUpdated>()
        }
        ///Creates a new event filter for the [`TokenNotSupported`] event.
        pub fn TokenNotSupported_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TokenNotSupported, N> {
            self.event_filter::<TokenNotSupported>()
        }
        ///Creates a new event filter for the [`UserRegistered`] event.
        pub fn UserRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UserRegistered, N> {
            self.event_filter::<UserRegistered>()
        }
    }
}
